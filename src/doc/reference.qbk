[/
 / Copyright (c) 2003-2011 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:reference Reference]


[section:associated_allocator associated_allocator]


Traits type used to obtain the allocator associated with an object. 


  template<
      typename T,
      typename Allocator = std::allocator<void>>
  struct associated_allocator


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.associated_allocator.type [*type]]]
    [If T has a nested type allocator_type, T::allocator_type. Otherwise Allocator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.associated_allocator.get [*get]]]
    [If T has a nested type allocator_type, returns t.get_allocator(). Otherwise returns a. ]
  ]
  
]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Allocator` shall be a type meeting the Allocator requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `a` is an object of type `Allocator`.


* Provide a nested typedef `type` that identifies a type meeting the Allocator requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,a)` and with return type `type`. 




[section:get associated_allocator::get]


If `T` has a nested type `allocator_type`, returns `t.get_allocator()`. Otherwise returns `a`. 


  static type get(
      const T & t,
      const Allocator & a = Allocator());



[endsect]



[section:type associated_allocator::type]


If `T` has a nested type `allocator_type`, `T::allocator_type`. Otherwise `Allocator`. 


  typedef see_below type;




[endsect]



[endsect]

[section:associated_executor associated_executor]


Traits type used to obtain the executor associated with an object. 


  template<
      typename T,
      typename Executor = system_executor>
  struct associated_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.associated_executor.type [*type]]]
    [If T has a nested type executor_type, T::executor_type. Otherwise Executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.associated_executor.get [*get]]]
    [If T has a nested type executor_type, returns t.get_executor(). Otherwise returns ex. ]
  ]
  
]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Executor` shall be a type meeting the Executor requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `e` is an object of type `Executor`.


* Provide a nested typedef `type` that identifies a type meeting the Executor requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,e)` and with return type `type`. 




[section:get associated_executor::get]


If `T` has a nested type `executor_type`, returns `t.get_executor()`. Otherwise returns `ex`. 


  static type get(
      const T & t,
      const Executor & ex = Executor());



[endsect]



[section:type associated_executor::type]


If `T` has a nested type `executor_type`, `T::executor_type`. Otherwise `Executor`. 


  typedef see_below type;




[endsect]



[endsect]

[section:async_completion async_completion]


Helper template to deduce the handler type from a CompletionToken, capture a local copy of the handler, and then create an [link networking_ts.reference.async_result `async_result`] for the handler. 


  template<
      typename CompletionToken,
      typename Signature>
  struct async_completion


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.async_completion.completion_handler_type [*completion_handler_type]]]
    [The real handler type to be used for the asynchronous operation. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.async_completion.async_completion [*async_completion]]]
    [Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.async_completion.completion_handler [*completion_handler]]]
    [A copy of, or reference to, a real handler object. ]
  ]

  [
    [[link networking_ts.reference.async_completion.result [*result]]]
    [The result of the asynchronous operation's initiating function. ]
  ]

]


[section:async_completion async_completion::async_completion]


Constructor. 


  async_completion(
      CompletionToken & token);


The constructor creates the concrete completion handler and makes the link between the handler and the asynchronous result. 


[endsect]



[section:completion_handler async_completion::completion_handler]


A copy of, or reference to, a real handler object. 


  conditional< is_same< CompletionToken, completion_handler_type >::value, completion_handler_type &, completion_handler_type >::type completion_handler;



[endsect]



[section:completion_handler_type async_completion::completion_handler_type]


The real handler type to be used for the asynchronous operation. 


  typedef std::experimental::net::async_result< typename decay< CompletionToken >::type, Signature >::completion_handler_type completion_handler_type;




[endsect]



[section:result async_completion::result]


The result of the asynchronous operation's initiating function. 


  async_result< typename decay< CompletionToken >::type, Signature > result;



[endsect]



[endsect]

[section:async_connect async_connect]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

      
  template<
      typename Protocol,
      typename EndpointSequence,
      typename RangeConnectHandler>
  DEDUCED ``[link networking_ts.reference.async_connect.overload1 async_connect]``(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      RangeConnectHandler && handler,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_connect.overload1 more...]]``

  template<
      typename Protocol,
      typename Iterator,
      typename IteratorConnectHandler>
  DEDUCED ``[link networking_ts.reference.async_connect.overload2 async_connect]``(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      IteratorConnectHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.async_connect.overload2 more...]]``

  template<
      typename Protocol,
      typename EndpointSequence,
      typename ConnectCondition,
      typename RangeConnectHandler>
  DEDUCED ``[link networking_ts.reference.async_connect.overload3 async_connect]``(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      RangeConnectHandler && handler,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_connect.overload3 more...]]``

  template<
      typename Protocol,
      typename Iterator,
      typename ConnectCondition,
      typename IteratorConnectHandler>
  DEDUCED ``[link networking_ts.reference.async_connect.overload4 async_connect]``(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      IteratorConnectHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.async_connect.overload4 more...]]``


[section:overload1 async_connect (1 of 4 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename EndpointSequence,
      typename RangeConnectHandler>
  DEDUCED async_connect(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      RangeConnectHandler && handler,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // std::experimental::net::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const std::error_code& error,

     // On success, the successfully connected endpoint.
     // Otherwise, a default-constructed endpoint.
     const typename Protocol::endpoint& endpoint
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(io_context);

   // ...

   r.async_resolve(q, resolve_handler);

   // ...

   void resolve_handler(
       const std::error_code& ec,
       tcp::resolver::results_type results)
   {
     if (!ec)
     {
       std::experimental::net::async_connect(s, results, connect_handler);
     }
   }

   // ...

   void connect_handler(
       const std::error_code& ec,
       const tcp::endpoint& endpoint)
   {
     // ...
   } 







[endsect]



[section:overload2 async_connect (2 of 4 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename Iterator,
      typename IteratorConnectHandler>
  DEDUCED async_connect(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      IteratorConnectHandler && handler);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // std::experimental::net::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const std::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   std::vector<tcp::endpoint> endpoints = ...;
   tcp::socket s(io_context);
   std::experimental::net::async_connect(s,
       endpoints.begin(), endpoints.end(),
       connect_handler);

   // ...

   void connect_handler(
       const std::error_code& ec,
       std::vector<tcp::endpoint>::iterator i)
   {
     // ...
   } 







[endsect]



[section:overload3 async_connect (3 of 4 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename EndpointSequence,
      typename ConnectCondition,
      typename RangeConnectHandler>
  DEDUCED async_connect(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      RangeConnectHandler && handler,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const std::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // std::experimental::net::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const std::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const std::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the std::experimental::net::connect function as follows: 

   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(io_context);

   // ...

   r.async_resolve(q, resolve_handler);

   // ...

   void resolve_handler(
       const std::error_code& ec,
       tcp::resolver::results_type results)
   {
     if (!ec)
     {
       std::experimental::net::async_connect(s, results,
           my_connect_condition(),
           connect_handler);
     }
   }

   // ...

   void connect_handler(
       const std::error_code& ec,
       const tcp::endpoint& endpoint)
   {
     if (ec)
     {
       // An error occurred.
     }
     else
     {
       std::cout << "Connected to: " << endpoint << std::endl;
     }
   } 







[endsect]



[section:overload4 async_connect (4 of 4 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename Iterator,
      typename ConnectCondition,
      typename IteratorConnectHandler>
  DEDUCED async_connect(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      IteratorConnectHandler && handler);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const std::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // std::experimental::net::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const std::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const std::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the std::experimental::net::connect function as follows: 

   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(io_context);

   // ...

   r.async_resolve(q, resolve_handler);

   // ...

   void resolve_handler(
       const std::error_code& ec,
       tcp::resolver::iterator i)
   {
     if (!ec)
     {
       tcp::resolver::iterator end;
       std::experimental::net::async_connect(s, i, end,
           my_connect_condition(),
           connect_handler);
     }
   }

   // ...

   void connect_handler(
       const std::error_code& ec,
       tcp::resolver::iterator i)
   {
     if (ec)
     {
       // An error occurred.
     }
     else
     {
       std::cout << "Connected to: " << i->endpoint() << std::endl;
     }
   } 







[endsect]


[endsect]

[section:async_read async_read]


Start an asynchronous operation to read a certain amount of data from a stream. 

      
  template<
      typename AsyncReadStream,
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.async_read.overload1 async_read]``(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      ReadHandler && handler,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_read.overload1 more...]]``

  template<
      typename AsyncReadStream,
      typename MutableBufferSequence,
      typename CompletionCondition,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.async_read.overload2 async_read]``(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_read.overload2 more...]]``

  template<
      typename AsyncReadStream,
      typename DynamicBuffer,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.async_read.overload3 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer && buffers,
      ReadHandler && handler,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_read.overload3 more...]]``

  template<
      typename AsyncReadStream,
      typename DynamicBuffer,
      typename CompletionCondition,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.async_read.overload4 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_read.overload4 more...]]``


[section:overload1 async_read (1 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename AsyncReadStream,
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED async_read(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      ReadHandler && handler,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a [*composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  
To read into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::async_read(s, std::experimental::net::buffer(data, size), handler);


See the `std::experimental::net::buffer`  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::async_read(
       s, buffers,
       std::experimental::net::transfer_all(),
       handler); 







[endsect]



[section:overload2 async_read (2 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename AsyncReadStream,
      typename MutableBufferSequence,
      typename CompletionCondition,
      typename ReadHandler>
  DEDUCED async_read(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  
To read into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::async_read(s,
       std::experimental::net::buffer(data, size),
       std::experimental::net::transfer_at_least(32),
       handler); 


See the `std::experimental::net::buffer`  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload3 async_read (3 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename AsyncReadStream,
      typename DynamicBuffer,
      typename ReadHandler>
  DEDUCED async_read(
      AsyncReadStream & s,
      DynamicBuffer && buffers,
      ReadHandler && handler,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a [*composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::async_read(
       s, buffers,
       std::experimental::net::transfer_all(),
       handler); 







[endsect]



[section:overload4 async_read (4 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename AsyncReadStream,
      typename DynamicBuffer,
      typename CompletionCondition,
      typename ReadHandler>
  DEDUCED async_read(
      AsyncReadStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a [*composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`. ]]

]




[endsect]


[endsect]

[section:async_read_until async_read_until]


Start an asynchronous operation to read data into a dynamic buffer sequence, or into a streambuf, until it contains a delimiter, matches a regular expression, or a function object indicates a match. 

      
  template<
      typename AsyncReadStream,
      typename DynamicBuffer,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.async_read_until.overload1 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer && buffers,
      char delim,
      ReadHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.async_read_until.overload1 more...]]``

  template<
      typename AsyncReadStream,
      typename DynamicBuffer,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.async_read_until.overload2 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer && buffers,
      string_view delim,
      ReadHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.async_read_until.overload2 more...]]``


[section:overload1 async_read_until (1 of 2 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename AsyncReadStream,
      typename DynamicBuffer,
      typename ReadHandler>
  DEDUCED async_read_until(
      AsyncReadStream & s,
      DynamicBuffer && buffers,
      char delim,
      ReadHandler && handler);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a [*composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[delim][The delimiter character.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const std::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a newline is encountered: 

   std::string data;
   ...
   void handler(const std::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   std::experimental::net::async_read_until(s, data, '\n', handler); 


After the `async_read_until` operation completes successfully, the buffer `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation. 




[endsect]



[section:overload2 async_read_until (2 of 2 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename AsyncReadStream,
      typename DynamicBuffer,
      typename ReadHandler>
  DEDUCED async_read_until(
      AsyncReadStream & s,
      DynamicBuffer && buffers,
      string_view delim,
      ReadHandler && handler);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a [*composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[delim][The delimiter string.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const std::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   ...
   void handler(const std::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   std::experimental::net::async_read_until(s, data, "\r\n", handler); 


After the `async_read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the string `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation. 




[endsect]


[endsect]

[section:async_result async_result]


An interface for customising the behaviour of an initiating function. 


  template<
      typename CompletionToken,
      typename Signature>
  class async_result


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.async_result.completion_handler_type [*completion_handler_type]]]
    [The concrete completion handler type for the specific signature. ]
  
  ]

  [

    [[link networking_ts.reference.async_result.return_type [*return_type]]]
    [The return type of the initiating function. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.async_result.async_result [*async_result]]]
    [Construct an async result from a given handler. ]
  ]
  
  [
    [[link networking_ts.reference.async_result.get [*get]]]
    [Obtain the value to be returned from the initiating function. ]
  ]
  
]

The [link networking_ts.reference.async_result `async_result`] traits class is used for determining:


* the concrete completion handler type to be called at the end of the asynchronous operation;


* the initiating function return type; and


* how the return value of the initiating function is obtained.

The trait allows the handler and return types to be determined at the point where the specific completion handler signature is known.

This template may be specialised for user-defined completion token types. The primary template assumes that the CompletionToken is the completion handler. 


[section:async_result async_result::async_result]


Construct an async result from a given handler. 


  async_result(
      completion_handler_type & h);


When using a specalised [link networking_ts.reference.async_result `async_result`], the constructor has an opportunity to initialise some state associated with the completion handler, which is then returned from the initiating function. 


[endsect]



[section:completion_handler_type async_result::completion_handler_type]


The concrete completion handler type for the specific signature. 


  typedef CompletionToken completion_handler_type;




[endsect]



[section:get async_result::get]


Obtain the value to be returned from the initiating function. 


  return_type get();



[endsect]



[section:return_type async_result::return_type]


The return type of the initiating function. 


  typedef void return_type;




[endsect]



[endsect]

[section:async_result_lt__std__packaged_task_lt__Result_lb_Args_ellipsis__rb__gt__comma__Signature__gt_ async_result< std::packaged_task< Result(Args...)>, Signature >]


Partial specialisation of `async_result` for `std::packaged_task`. 


  template<
      typename Result,
      typename... Args,
      typename Signature>
  class async_result< std::packaged_task< Result(Args...)>, Signature >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.async_result_lt__std__packaged_task_lt__Result_lb_Args_ellipsis__rb__gt__comma__Signature__gt_.completion_handler_type [*completion_handler_type]]]
    [The packaged task is the concrete completion handler type. ]
  
  ]

  [

    [[link networking_ts.reference.async_result_lt__std__packaged_task_lt__Result_lb_Args_ellipsis__rb__gt__comma__Signature__gt_.return_type [*return_type]]]
    [The return type of the initiating function is the future obtained from the packaged task. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.async_result_lt__std__packaged_task_lt__Result_lb_Args_ellipsis__rb__gt__comma__Signature__gt_.async_result [*async_result]]]
    [The constructor extracts the future from the packaged task. ]
  ]
  
  [
    [[link networking_ts.reference.async_result_lt__std__packaged_task_lt__Result_lb_Args_ellipsis__rb__gt__comma__Signature__gt_.get [*get]]]
    [Returns the packaged task's future. ]
  ]
  
]


[section:async_result async_result< std::packaged_task< Result(Args...)>, Signature >::async_result]


The constructor extracts the future from the packaged task. 


  async_result(
      completion_handler_type & h);



[endsect]



[section:completion_handler_type async_result< std::packaged_task< Result(Args...)>, Signature >::completion_handler_type]


The packaged task is the concrete completion handler type. 


  typedef std::packaged_task< Result(Args...)> completion_handler_type;




[endsect]



[section:get async_result< std::packaged_task< Result(Args...)>, Signature >::get]


Returns the packaged task's future. 


  return_type get();



[endsect]



[section:return_type async_result< std::packaged_task< Result(Args...)>, Signature >::return_type]


The return type of the initiating function is the future obtained from the packaged task. 


  typedef std::future< Result > return_type;




[endsect]



[endsect]

[section:async_write async_write]


Start an asynchronous operation to write a certain amount of data to a stream. 

      
  template<
      typename AsyncWriteStream,
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.async_write.overload1 async_write]``(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      WriteHandler && handler,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_write.overload1 more...]]``

  template<
      typename AsyncWriteStream,
      typename ConstBufferSequence,
      typename CompletionCondition,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.async_write.overload2 async_write]``(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_write.overload2 more...]]``

  template<
      typename AsyncWriteStream,
      typename DynamicBuffer,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.async_write.overload3 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer && buffers,
      WriteHandler && handler,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_write.overload3 more...]]``

  template<
      typename AsyncWriteStream,
      typename DynamicBuffer,
      typename CompletionCondition,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.async_write.overload4 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.async_write.overload4 more...]]``


[section:overload1 async_write (1 of 4 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename AsyncWriteStream,
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED async_write(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      WriteHandler && handler,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a [*composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  
To write a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::async_write(s, std::experimental::net::buffer(data, size), handler);


See the `std::experimental::net::buffer`  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 async_write (2 of 4 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename AsyncWriteStream,
      typename ConstBufferSequence,
      typename CompletionCondition,
      typename WriteHandler>
  DEDUCED async_write(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a [*composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  
To write a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::async_write(s,
       std::experimental::net::buffer(data, size),
       std::experimental::net::transfer_at_least(32),
       handler); 


See the `std::experimental::net::buffer`  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload3 async_write (3 of 4 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename AsyncWriteStream,
      typename DynamicBuffer,
      typename WriteHandler>
  DEDUCED async_write(
      AsyncWriteStream & s,
      DynamicBuffer && buffers,
      WriteHandler && handler,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a [*composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`. ]]

]




[endsect]



[section:overload4 async_write (4 of 4 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename AsyncWriteStream,
      typename DynamicBuffer,
      typename CompletionCondition,
      typename WriteHandler>
  DEDUCED async_write(
      AsyncWriteStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a [*composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`. ]]

]




[endsect]


[endsect]

[section:bad_executor bad_executor]


Exception thrown when trying to access an empty polymorphic executor. 


  class bad_executor :
    public std::exception


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.bad_executor.bad_executor [*bad_executor]]]
    [Constructor. ]
  ]
  
  [
    [[link networking_ts.reference.bad_executor.what [*what]]]
    [Obtain message associated with exception. ]
  ]
  
]


[section:bad_executor bad_executor::bad_executor]


Constructor. 


  bad_executor();



[endsect]



[section:what bad_executor::what]


Obtain message associated with exception. 


  virtual const char * what() const;



[endsect]



[endsect]

[section:basic_datagram_socket basic_datagram_socket]


Provides datagram-oriented socket functionality. 


  template<
      typename Protocol>
  class basic_datagram_socket :
    public basic_socket< Protocol >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_datagram_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_datagram_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.basic_datagram_socket [*basic_datagram_socket]]]
    [Construct a basic_datagram_socket without opening it. 

     Construct and open a basic_datagram_socket. 

     Construct a basic_datagram_socket, opening it and binding it to the given local endpoint. 

     Construct a basic_datagram_socket on an existing native socket. 

     Move-construct a basic_datagram_socket from another. 

     Move-construct a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 

     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 

     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_datagram_socket from another. 

     Move-assign a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.receive_from [*receive_from]]]
    [Receive a datagram with the endpoint of the sender. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.send_to [*send_to]]]
    [Send a datagram to the specified endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket._basic_datagram_socket [*~basic_datagram_socket]]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_datagram_socket.max_listen_connections [*max_listen_connections]]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link networking_ts.reference.basic_datagram_socket.message_do_not_route [*message_do_not_route]]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link networking_ts.reference.basic_datagram_socket.message_end_of_record [*message_end_of_record]]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link networking_ts.reference.basic_datagram_socket.message_out_of_band [*message_out_of_band]]]
    [Process out-of-band data. ]
  ]

  [
    [[link networking_ts.reference.basic_datagram_socket.message_peek [*message_peek]]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] class template provides asynchronous and blocking datagram-oriented socket functionality.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:assign basic_datagram_socket::assign]


Assign an existing native socket to the socket. 


  void ``[link networking_ts.reference.basic_datagram_socket.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.assign.overload1 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.assign.overload2 more...]]``


[section:overload1 basic_datagram_socket::assign (1 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket);



[endsect]



[section:overload2 basic_datagram_socket::assign (2 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      std::error_code & ec);



[endsect]


[endsect]


[section:async_connect basic_datagram_socket::async_connect]


['Inherited from basic_socket.]


Start an asynchronous connect. 


  template<
      typename ConnectHandler>
  DEDUCED async_connect(
      const endpoint_type & peer_endpoint,
      ConnectHandler && handler);


This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.]]

[[handler][The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void connect_handler(const std::error_code& error)
   {
     if (!error)
     {
       // Connect succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::socket socket(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_connect(endpoint, connect_handler);







[endsect]


[section:async_receive basic_datagram_socket::async_receive]


Start an asynchronous receive on a connected socket. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.basic_datagram_socket.async_receive.overload1 async_receive]``(
      const MutableBufferSequence & buffers,
      ReadHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.async_receive.overload1 more...]]``

  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.basic_datagram_socket.async_receive.overload2 async_receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.async_receive.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_receive (1 of 2 overloads)]


Start an asynchronous receive on a connected socket. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED async_receive(
      const MutableBufferSequence & buffers,
      ReadHandler && handler);


This function is used to asynchronously receive data from the datagram socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The async\_receive operation can only be used with a connected socket. Use the async\_receive\_from function to receive data on an unconnected datagram socket.


[heading Example]
  
To receive into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.async_receive(std::experimental::net::buffer(data, size), handler);


See the `std::experimental::net::buffer`  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::async_receive (2 of 2 overloads)]


Start an asynchronous receive on a connected socket. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED async_receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler);


This function is used to asynchronously receive data from the datagram socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The async\_receive operation can only be used with a connected socket. Use the async\_receive\_from function to receive data on an unconnected datagram socket. 




[endsect]


[endsect]

[section:async_receive_from basic_datagram_socket::async_receive_from]


Start an asynchronous receive. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.basic_datagram_socket.async_receive_from.overload1 async_receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      ReadHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.async_receive_from.overload1 more...]]``

  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.basic_datagram_socket.async_receive_from.overload2 async_receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      ReadHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.async_receive_from.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_receive_from (1 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED async_receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      ReadHandler && handler);


This function is used to asynchronously receive a datagram. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram. Ownership of the sender\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  
To receive into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.async_receive_from(
       std::experimental::net::buffer(data, size), sender_endpoint, handler); 


See the `std::experimental::net::buffer`  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::async_receive_from (2 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED async_receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      ReadHandler && handler);


This function is used to asynchronously receive a datagram. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram. Ownership of the sender\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`. ]]

]




[endsect]


[endsect]

[section:async_send basic_datagram_socket::async_send]


Start an asynchronous send on a connected socket. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.basic_datagram_socket.async_send.overload1 async_send]``(
      const ConstBufferSequence & buffers,
      WriteHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.async_send.overload1 more...]]``

  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.basic_datagram_socket.async_send.overload2 async_send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.async_send.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_send (1 of 2 overloads)]


Start an asynchronous send on a connected socket. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED async_send(
      const ConstBufferSequence & buffers,
      WriteHandler && handler);


This function is used to asynchronously send data on the datagram socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The async\_send operation can only be used with a connected socket. Use the async\_send\_to function to send data on an unconnected datagram socket.


[heading Example]
  
To send a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.async_send(std::experimental::net::buffer(data, size), handler);


See the `std::experimental::net::buffer`  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::async_send (2 of 2 overloads)]


Start an asynchronous send on a connected socket. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED async_send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler);


This function is used to asynchronously send data on the datagram socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The async\_send operation can only be used with a connected socket. Use the async\_send\_to function to send data on an unconnected datagram socket. 




[endsect]


[endsect]

[section:async_send_to basic_datagram_socket::async_send_to]


Start an asynchronous send. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.basic_datagram_socket.async_send_to.overload1 async_send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      WriteHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.async_send_to.overload1 more...]]``

  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.basic_datagram_socket.async_send_to.overload2 async_send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      WriteHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.async_send_to.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_send_to (1 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED async_send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      WriteHandler && handler);


This function is used to asynchronously send a datagram to the specified remote endpoint. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[destination][The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  
To send a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::ip::udp::endpoint destination(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_send_to(
       std::experimental::net::buffer(data, size), destination, handler);


See the `std::experimental::net::buffer`  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::async_send_to (2 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED async_send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      WriteHandler && handler);


This function is used to asynchronously send a datagram to the specified remote endpoint. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[destination][The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`. ]]

]




[endsect]


[endsect]


[section:async_wait basic_datagram_socket::async_wait]


['Inherited from basic_socket.]


Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename WaitHandler>
  DEDUCED async_wait(
      wait_type w,
      WaitHandler && handler);


This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void wait_handler(const std::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   socket.async_wait(std::experimental::net::ip::tcp::socket::wait_read, wait_handler);







[endsect]


[section:at_mark basic_datagram_socket::at_mark]


Determine whether the socket is at the out-of-band data mark. 


  bool ``[link networking_ts.reference.basic_datagram_socket.at_mark.overload1 at_mark]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.at_mark.overload1 more...]]``

  bool ``[link networking_ts.reference.basic_datagram_socket.at_mark.overload2 at_mark]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.at_mark.overload2 more...]]``


[section:overload1 basic_datagram_socket::at_mark (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark() const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_datagram_socket::at_mark (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark(
      std::error_code & ec) const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark. 




[endsect]


[endsect]

[section:available basic_datagram_socket::available]


Determine the number of bytes available for reading. 


  std::size_t ``[link networking_ts.reference.basic_datagram_socket.available.overload1 available]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.available.overload1 more...]]``

  std::size_t ``[link networking_ts.reference.basic_datagram_socket.available.overload2 available]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.available.overload2 more...]]``


[section:overload1 basic_datagram_socket::available (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available() const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_datagram_socket::available (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available(
      std::error_code & ec) const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs. 




[endsect]


[endsect]

[section:basic_datagram_socket basic_datagram_socket::basic_datagram_socket]


Construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] without opening it. 


  explicit ``[link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload1 basic_datagram_socket]``(
      std::experimental::net::io_context & io_context);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload1 more...]]``


Construct and open a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`]. 


  ``[link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload2 basic_datagram_socket]``(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload2 more...]]``


Construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`], opening it and binding it to the given local endpoint. 


  ``[link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload3 basic_datagram_socket]``(
      std::experimental::net::io_context & io_context,
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload3 more...]]``


Construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] on an existing native socket. 


  ``[link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload4 basic_datagram_socket]``(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload4 more...]]``


Move-construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  ``[link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload5 basic_datagram_socket]``(
      basic_datagram_socket && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload5 more...]]``


Move-construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  ``[link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload6 basic_datagram_socket]``(
      basic_datagram_socket< Protocol1 > && other,
      typename enable_if< is_convertible< Protocol1, Protocol >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.basic_datagram_socket.overload6 more...]]``


[section:overload1 basic_datagram_socket::basic_datagram_socket (1 of 6 overloads)]


Construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] without opening it. 


  basic_datagram_socket(
      std::experimental::net::io_context & io_context);


This constructor creates a datagram socket without opening it. The `open()` function must be called before data can be sent or received on the socket.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the datagram socket will use to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload2 basic_datagram_socket::basic_datagram_socket (2 of 6 overloads)]


Construct and open a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`]. 


  basic_datagram_socket(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol);


This constructor creates and opens a datagram socket.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the datagram socket will use to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_datagram_socket::basic_datagram_socket (3 of 6 overloads)]


Construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`], opening it and binding it to the given local endpoint. 


  basic_datagram_socket(
      std::experimental::net::io_context & io_context,
      const endpoint_type & endpoint);


This constructor creates a datagram socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the datagram socket will use to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the datagram socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_datagram_socket::basic_datagram_socket (4 of 6 overloads)]


Construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] on an existing native socket. 


  basic_datagram_socket(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol,
      const native_handle_type & native_socket);


This constructor creates a datagram socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the datagram socket will use to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_datagram_socket::basic_datagram_socket (5 of 6 overloads)]


Move-construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  basic_datagram_socket(
      basic_datagram_socket && other);


This constructor moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(io_context&) constructor`. 




[endsect]



[section:overload6 basic_datagram_socket::basic_datagram_socket (6 of 6 overloads)]


Move-construct a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  basic_datagram_socket(
      basic_datagram_socket< Protocol1 > && other,
      typename enable_if< is_convertible< Protocol1, Protocol >::value >::type *  = 0);


This constructor moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(io_context&) constructor`. 




[endsect]


[endsect]

[section:bind basic_datagram_socket::bind]


Bind the socket to the given local endpoint. 


  void ``[link networking_ts.reference.basic_datagram_socket.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.bind.overload1 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.bind.overload2 more...]]``


[section:overload1 basic_datagram_socket::bind (1 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   socket.open(std::experimental::net::ip::tcp::v4());
   socket.bind(std::experimental::net::ip::tcp::endpoint(
         std::experimental::net::ip::tcp::v4(), 12345));







[endsect]



[section:overload2 basic_datagram_socket::bind (2 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      std::error_code & ec);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   socket.open(std::experimental::net::ip::tcp::v4());
   std::error_code ec;
   socket.bind(std::experimental::net::ip::tcp::endpoint(
         std::experimental::net::ip::tcp::v4(), 12345), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_datagram_socket::broadcast]


['Inherited from socket_base.]


Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:bytes_readable basic_datagram_socket::bytes_readable]


['Inherited from socket_base.]


IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();








[endsect]


[section:cancel basic_datagram_socket::cancel]


Cancel all asynchronous operations associated with the socket. 


  void ``[link networking_ts.reference.basic_datagram_socket.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.cancel.overload1 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.cancel.overload2 cancel]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.cancel.overload2 more...]]``


[section:overload1 basic_datagram_socket::cancel (1 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with std::experimental::net::error::operation\_not\_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless NET\_TS\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining NET\_TS\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_datagram_socket::cancel (2 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel(
      std::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with std::experimental::net::error::operation\_not\_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless NET\_TS\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining NET\_TS\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_datagram_socket::close]


Close the socket. 


  void ``[link networking_ts.reference.basic_datagram_socket.close.overload1 close]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.close.overload1 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.close.overload2 close]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.close.overload2 more...]]``


[section:overload1 basic_datagram_socket::close (1 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close();


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the std::experimental::net::error::operation\_aborted error.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]



[section:overload2 basic_datagram_socket::close (2 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close(
      std::error_code & ec);


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the std::experimental::net::error::operation\_aborted error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   socket.close(ec);
   if (ec)
   {
     // An error occurred.
   }





[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]


[endsect]

[section:connect basic_datagram_socket::connect]


Connect the socket to the specified endpoint. 


  void ``[link networking_ts.reference.basic_datagram_socket.connect.overload1 connect]``(
      const endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.connect.overload1 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.connect.overload2 connect]``(
      const endpoint_type & peer_endpoint,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.connect.overload2 more...]]``


[section:overload1 basic_datagram_socket::connect (1 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   socket.connect(endpoint);







[endsect]



[section:overload2 basic_datagram_socket::connect (2 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint,
      std::error_code & ec);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   std::error_code ec;
   socket.connect(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_datagram_socket::debug]


['Inherited from socket_base.]


Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:do_not_route basic_datagram_socket::do_not_route]


['Inherited from socket_base.]


Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:enable_connection_aborted basic_datagram_socket::enable_connection_aborted]


['Inherited from socket_base.]


Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with std::experimental::net::error::connection\_aborted. By default the option is false.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]



[section:endpoint_type basic_datagram_socket::endpoint_type]


The endpoint type. 


  typedef Protocol::endpoint endpoint_type;




[endsect]



[section:executor_type basic_datagram_socket::executor_type]


['Inherited from basic_socket.]


The type of the executor associated with the object. 


  typedef io_context::executor_type executor_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.defer [*defer]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.dispatch [*dispatch]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_finished [*on_work_finished]]]
    [Inform the io_context that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_started [*on_work_started]]]
    [Inform the io_context that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.post [*post]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the io_context is running in the current thread. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]



[endsect]



[section:get_executor basic_datagram_socket::get_executor]


['Inherited from basic_socket.]


Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_datagram_socket::get_option]


Get an option from the socket. 


  template<
      typename GettableSocketOption>
  void ``[link networking_ts.reference.basic_datagram_socket.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.get_option.overload1 more...]]``

  template<
      typename GettableSocketOption>
  void ``[link networking_ts.reference.basic_datagram_socket.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.get_option.overload2 more...]]``


[section:overload1 basic_datagram_socket::get_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename GettableSocketOption>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[endsect]



[section:overload2 basic_datagram_socket::get_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename GettableSocketOption>
  void get_option(
      GettableSocketOption & option,
      std::error_code & ec) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::keep_alive option;
   std::error_code ec;
   socket.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.value();







[endsect]


[endsect]

[section:io_control basic_datagram_socket::io_control]


Perform an IO control command on the socket. 


  template<
      typename IoControlCommand>
  void ``[link networking_ts.reference.basic_datagram_socket.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.io_control.overload1 more...]]``

  template<
      typename IoControlCommand>
  void ``[link networking_ts.reference.basic_datagram_socket.io_control.overload2 io_control]``(
      IoControlCommand & command,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.io_control.overload2 more...]]``


[section:overload1 basic_datagram_socket::io_control (1 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename IoControlCommand>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::bytes_readable command;
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 basic_datagram_socket::io_control (2 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename IoControlCommand>
  void io_control(
      IoControlCommand & command,
      std::error_code & ec);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::bytes_readable command;
   std::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open basic_datagram_socket::is_open]


['Inherited from basic_socket.]


Determine whether the socket is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_datagram_socket::keep_alive]


['Inherited from socket_base.]


Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:linger basic_datagram_socket::linger]


['Inherited from socket_base.]


Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();








[endsect]


[section:local_endpoint basic_datagram_socket::local_endpoint]


Get the local endpoint of the socket. 


  endpoint_type ``[link networking_ts.reference.basic_datagram_socket.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.local_endpoint.overload1 more...]]``

  endpoint_type ``[link networking_ts.reference.basic_datagram_socket.local_endpoint.overload2 local_endpoint]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.local_endpoint.overload2 more...]]``


[section:overload1 basic_datagram_socket::local_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Return Value]
      
An object that represents the local endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint = socket.local_endpoint();







[endsect]



[section:overload2 basic_datagram_socket::local_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint(
      std::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   std::experimental::net::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:max_listen_connections basic_datagram_socket::max_listen_connections]


['Inherited from socket_base.]


The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_datagram_socket::message_do_not_route]


['Inherited from socket_base.]


Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_datagram_socket::message_end_of_record]


['Inherited from socket_base.]


Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_datagram_socket::message_flags]


['Inherited from socket_base.]


Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;




[endsect]



[section:message_out_of_band basic_datagram_socket::message_out_of_band]


['Inherited from socket_base.]


Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_datagram_socket::message_peek]


['Inherited from socket_base.]


Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_datagram_socket::native_handle]


['Inherited from basic_socket.]


Get the native socket representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_datagram_socket::native_handle_type]


The native representation of a socket. 


  typedef implementation_defined native_handle_type;




[endsect]


[section:native_non_blocking basic_datagram_socket::native_non_blocking]


Gets the non-blocking mode of the native socket implementation. 


  bool ``[link networking_ts.reference.basic_datagram_socket.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native socket implementation. 


  void ``[link networking_ts.reference.basic_datagram_socket.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.native_non_blocking.overload2 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.native_non_blocking.overload3 more...]]``


[section:overload1 basic_datagram_socket::native_non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the native socket implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.


[heading Return Value]
      
`true` if the underlying socket is in non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(std::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = std::error_code(n < 0 ? errno : 0,
               std::experimental::net::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == std::experimental::net::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == std::experimental::net::error::would_block
               || ec == std::experimental::net::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload2 basic_datagram_socket::native_non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with std::experimental::net::error::invalid\_argument, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(std::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = std::error_code(n < 0 ? errno : 0,
               std::experimental::net::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == std::experimental::net::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == std::experimental::net::error::would_block
               || ec == std::experimental::net::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload3 basic_datagram_socket::native_non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode,
      std::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with std::experimental::net::error::invalid\_argument, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(std::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = std::error_code(n < 0 ? errno : 0,
               std::experimental::net::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == std::experimental::net::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == std::experimental::net::error::would_block
               || ec == std::experimental::net::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]


[endsect]

[section:non_blocking basic_datagram_socket::non_blocking]


Gets the non-blocking mode of the socket. 


  bool ``[link networking_ts.reference.basic_datagram_socket.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the socket. 


  void ``[link networking_ts.reference.basic_datagram_socket.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.non_blocking.overload2 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.non_blocking.overload3 non_blocking]``(
      bool mode,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.non_blocking.overload3 more...]]``


[section:overload1 basic_datagram_socket::non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the socket. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the socket's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]



[section:overload2 basic_datagram_socket::non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]



[section:overload3 basic_datagram_socket::non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode,
      std::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]


[endsect]

[section:open basic_datagram_socket::open]


Open the socket using the specified protocol. 


  void ``[link networking_ts.reference.basic_datagram_socket.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.open.overload1 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.open.overload2 open]``(
      const protocol_type & protocol,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.open.overload2 more...]]``


[section:overload1 basic_datagram_socket::open (1 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   socket.open(std::experimental::net::ip::tcp::v4());







[endsect]



[section:overload2 basic_datagram_socket::open (2 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol,
      std::error_code & ec);


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   std::error_code ec;
   socket.open(std::experimental::net::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_datagram_socket::operator=]


Move-assign a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  basic_datagram_socket & ``[link networking_ts.reference.basic_datagram_socket.operator_eq_.overload1 operator=]``(
      basic_datagram_socket && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.operator_eq_.overload1 more...]]``


Move-assign a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  enable_if< is_convertible< Protocol1, Protocol >::value, basic_datagram_socket >::type & ``[link networking_ts.reference.basic_datagram_socket.operator_eq_.overload2 operator=]``(
      basic_datagram_socket< Protocol1 > && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.operator_eq_.overload2 more...]]``


[section:overload1 basic_datagram_socket::operator= (1 of 2 overloads)]


Move-assign a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  basic_datagram_socket & operator=(
      basic_datagram_socket && other);


This assignment operator moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(io_context&) constructor`. 




[endsect]



[section:overload2 basic_datagram_socket::operator= (2 of 2 overloads)]


Move-assign a [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  enable_if< is_convertible< Protocol1, Protocol >::value, basic_datagram_socket >::type & operator=(
      basic_datagram_socket< Protocol1 > && other);


This assignment operator moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(io_context&) constructor`. 




[endsect]


[endsect]


[section:out_of_band_inline basic_datagram_socket::out_of_band_inline]


['Inherited from socket_base.]


Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();








[endsect]



[section:protocol_type basic_datagram_socket::protocol_type]


The protocol type. 


  typedef Protocol protocol_type;




[endsect]


[section:receive basic_datagram_socket::receive]


Receive some data on a connected socket. 


  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.receive.overload1 receive]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.receive.overload1 more...]]``

  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.receive.overload2 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.receive.overload2 more...]]``

  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.receive.overload3 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.receive.overload3 more...]]``


[section:overload1 basic_datagram_socket::receive (1 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename MutableBufferSequence>
  std::size_t receive(
      const MutableBufferSequence & buffers);


This function is used to receive data on the datagram socket. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The receive operation can only be used with a connected socket. Use the receive\_from function to receive data on an unconnected datagram socket.


[heading Example]
  
To receive into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.receive(std::experimental::net::buffer(data, size)); 


See the `std::experimental::net::buffer`  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::receive (2 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename MutableBufferSequence>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to receive data on the datagram socket. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The receive operation can only be used with a connected socket. Use the receive\_from function to receive data on an unconnected datagram socket. 




[endsect]



[section:overload3 basic_datagram_socket::receive (3 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename MutableBufferSequence>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      std::error_code & ec);


This function is used to receive data on the datagram socket. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Remarks]
      
The receive operation can only be used with a connected socket. Use the receive\_from function to receive data on an unconnected datagram socket. 




[endsect]


[endsect]


[section:receive_buffer_size basic_datagram_socket::receive_buffer_size]


['Inherited from socket_base.]


Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]


[section:receive_from basic_datagram_socket::receive_from]


Receive a datagram with the endpoint of the sender. 


  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.receive_from.overload1 receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.receive_from.overload1 more...]]``

  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.receive_from.overload2 receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.receive_from.overload2 more...]]``

  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.receive_from.overload3 receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.receive_from.overload3 more...]]``


[section:overload1 basic_datagram_socket::receive_from (1 of 3 overloads)]


Receive a datagram with the endpoint of the sender. 


  template<
      typename MutableBufferSequence>
  std::size_t receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint);


This function is used to receive a datagram. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  
To receive into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::ip::udp::endpoint sender_endpoint;
   socket.receive_from(
       std::experimental::net::buffer(data, size), sender_endpoint);


See the `std::experimental::net::buffer`  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::receive_from (2 of 3 overloads)]


Receive a datagram with the endpoint of the sender. 


  template<
      typename MutableBufferSequence>
  std::size_t receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags);


This function is used to receive a datagram. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram.]]

[[flags][Flags specifying how the receive call is to be made.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_datagram_socket::receive_from (3 of 3 overloads)]


Receive a datagram with the endpoint of the sender. 


  template<
      typename MutableBufferSequence>
  std::size_t receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      std::error_code & ec);


This function is used to receive a datagram. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes received. 




[endsect]


[endsect]


[section:receive_low_watermark basic_datagram_socket::receive_low_watermark]


['Inherited from socket_base.]


Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]


[section:release basic_datagram_socket::release]


Release ownership of the underlying native socket. 


  native_handle_type ``[link networking_ts.reference.basic_datagram_socket.release.overload1 release]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.release.overload1 more...]]``

  native_handle_type ``[link networking_ts.reference.basic_datagram_socket.release.overload2 release]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.release.overload2 more...]]``


[section:overload1 basic_datagram_socket::release (1 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error. Ownership of the native socket is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with std::experimental::net::error::operation\_not\_supported on these platforms. 




[endsect]



[section:overload2 basic_datagram_socket::release (2 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release(
      std::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error. Ownership of the native socket is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with std::experimental::net::error::operation\_not\_supported on these platforms. 




[endsect]


[endsect]

[section:remote_endpoint basic_datagram_socket::remote_endpoint]


Get the remote endpoint of the socket. 


  endpoint_type ``[link networking_ts.reference.basic_datagram_socket.remote_endpoint.overload1 remote_endpoint]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.remote_endpoint.overload1 more...]]``

  endpoint_type ``[link networking_ts.reference.basic_datagram_socket.remote_endpoint.overload2 remote_endpoint]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.remote_endpoint.overload2 more...]]``


[section:overload1 basic_datagram_socket::remote_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint() const;


This function is used to obtain the remote endpoint of the socket.


[heading Return Value]
      
An object that represents the remote endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint = socket.remote_endpoint();







[endsect]



[section:overload2 basic_datagram_socket::remote_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint(
      std::error_code & ec) const;


This function is used to obtain the remote endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   std::experimental::net::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:reuse_address basic_datagram_socket::reuse_address]


['Inherited from socket_base.]


Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]


[section:send basic_datagram_socket::send]


Send some data on a connected socket. 


  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.send.overload1 send]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.send.overload1 more...]]``

  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.send.overload2 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.send.overload2 more...]]``

  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.send.overload3 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.send.overload3 more...]]``


[section:overload1 basic_datagram_socket::send (1 of 3 overloads)]


Send some data on a connected socket. 


  template<
      typename ConstBufferSequence>
  std::size_t send(
      const ConstBufferSequence & buffers);


This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One ore more data buffers to be sent on the socket.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation can only be used with a connected socket. Use the send\_to function to send data on an unconnected datagram socket.


[heading Example]
  
To send a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.send(std::experimental::net::buffer(data, size)); 


See the `std::experimental::net::buffer`  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::send (2 of 3 overloads)]


Send some data on a connected socket. 


  template<
      typename ConstBufferSequence>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One ore more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation can only be used with a connected socket. Use the send\_to function to send data on an unconnected datagram socket. 




[endsect]



[section:overload3 basic_datagram_socket::send (3 of 3 overloads)]


Send some data on a connected socket. 


  template<
      typename ConstBufferSequence>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      std::error_code & ec);


This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Remarks]
      
The send operation can only be used with a connected socket. Use the send\_to function to send data on an unconnected datagram socket. 




[endsect]


[endsect]


[section:send_buffer_size basic_datagram_socket::send_buffer_size]


['Inherited from socket_base.]


Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:send_low_watermark basic_datagram_socket::send_low_watermark]


['Inherited from socket_base.]


Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]


[section:send_to basic_datagram_socket::send_to]


Send a datagram to the specified endpoint. 


  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.send_to.overload1 send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.send_to.overload1 more...]]``

  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.send_to.overload2 send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.send_to.overload2 more...]]``

  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_datagram_socket.send_to.overload3 send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.send_to.overload3 more...]]``


[section:overload1 basic_datagram_socket::send_to (1 of 3 overloads)]


Send a datagram to the specified endpoint. 


  template<
      typename ConstBufferSequence>
  std::size_t send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination);


This function is used to send a datagram to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint.]]

[[destination][The remote endpoint to which the data will be sent.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  
To send a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::ip::udp::endpoint destination(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   socket.send_to(std::experimental::net::buffer(data, size), destination);


See the `std::experimental::net::buffer`  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::send_to (2 of 3 overloads)]


Send a datagram to the specified endpoint. 


  template<
      typename ConstBufferSequence>
  std::size_t send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags);


This function is used to send a datagram to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint.]]

[[destination][The remote endpoint to which the data will be sent.]]

[[flags][Flags specifying how the send call is to be made.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_datagram_socket::send_to (3 of 3 overloads)]


Send a datagram to the specified endpoint. 


  template<
      typename ConstBufferSequence>
  std::size_t send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      std::error_code & ec);


This function is used to send a datagram to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint.]]

[[destination][The remote endpoint to which the data will be sent.]]

[[flags][Flags specifying how the send call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes sent. 




[endsect]


[endsect]

[section:set_option basic_datagram_socket::set_option]


Set an option on the socket. 


  template<
      typename SettableSocketOption>
  void ``[link networking_ts.reference.basic_datagram_socket.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.set_option.overload1 more...]]``

  template<
      typename SettableSocketOption>
  void ``[link networking_ts.reference.basic_datagram_socket.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.set_option.overload2 more...]]``


[section:overload1 basic_datagram_socket::set_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename SettableSocketOption>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::no_delay option(true);
   socket.set_option(option);







[endsect]



[section:overload2 basic_datagram_socket::set_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename SettableSocketOption>
  void set_option(
      const SettableSocketOption & option,
      std::error_code & ec);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::no_delay option(true);
   std::error_code ec;
   socket.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:shutdown basic_datagram_socket::shutdown]


Disable sends or receives on the socket. 


  void ``[link networking_ts.reference.basic_datagram_socket.shutdown.overload1 shutdown]``(
      shutdown_type what);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.shutdown.overload1 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.shutdown.overload2 shutdown]``(
      shutdown_type what,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.shutdown.overload2 more...]]``


[section:overload1 basic_datagram_socket::shutdown (1 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   socket.shutdown(std::experimental::net::ip::tcp::socket::shutdown_send);







[endsect]



[section:overload2 basic_datagram_socket::shutdown (2 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what,
      std::error_code & ec);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   socket.shutdown(std::experimental::net::ip::tcp::socket::shutdown_send, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_datagram_socket::shutdown_type]


['Inherited from socket_base.]


Different ways a socket may be shutdown. 


  enum shutdown_type


[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_datagram_socket::wait]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link networking_ts.reference.basic_datagram_socket.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.wait.overload1 more...]]``

  void ``[link networking_ts.reference.basic_datagram_socket.wait.overload2 wait]``(
      wait_type w,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_datagram_socket.wait.overload2 more...]]``


[section:overload1 basic_datagram_socket::wait (1 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   socket.wait(std::experimental::net::ip::tcp::socket::wait_read);







[endsect]



[section:overload2 basic_datagram_socket::wait (2 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      std::error_code & ec);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   socket.wait(std::experimental::net::ip::tcp::socket::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_datagram_socket::wait_type]


['Inherited from socket_base.]


Wait types. 


  enum wait_type


[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_basic_datagram_socket basic_datagram_socket::~basic_datagram_socket]


Destroys the socket. 


  ~basic_datagram_socket();


This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_io_object basic_io_object]


Base class for all I/O objects. 


  template<
      typename IoObjectService>
  class basic_io_object


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_io_object.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_io_object.implementation_type [*implementation_type]]]
    [The underlying implementation type of I/O object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_io_object.service_type [*service_type]]]
    [The type of the service that will be used to provide I/O operations. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_io_object.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_io_object.basic_io_object [*basic_io_object]]]
    [Construct a basic_io_object. 

     Move-construct a basic_io_object. 

     Perform a converting move-construction of a basic_io_object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_io_object.get_implementation [*get_implementation]]]
    [Get the underlying implementation of the I/O object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_io_object.get_service [*get_service]]]
    [Get the service associated with the I/O object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_io_object.operator_eq_ [*operator=]]]
    [Move-assign a basic_io_object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_io_object._basic_io_object [*~basic_io_object]]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]


[heading Remarks]
      
All I/O objects are non-copyable. However, when using C++0x, certain I/O objects do support move construction and move assignment. 



[section:basic_io_object basic_io_object::basic_io_object]


Construct a [link networking_ts.reference.basic_io_object `basic_io_object`]. 


  explicit ``[link networking_ts.reference.basic_io_object.basic_io_object.overload1 basic_io_object]``(
      std::experimental::net::io_context & io_context);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_io_object.basic_io_object.overload1 more...]]``


Move-construct a [link networking_ts.reference.basic_io_object `basic_io_object`]. 


  ``[link networking_ts.reference.basic_io_object.basic_io_object.overload2 basic_io_object]``(
      basic_io_object && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_io_object.basic_io_object.overload2 more...]]``


Perform a converting move-construction of a [link networking_ts.reference.basic_io_object `basic_io_object`]. 


  template<
      typename IoObjectService1>
  ``[link networking_ts.reference.basic_io_object.basic_io_object.overload3 basic_io_object]``(
      IoObjectService1 & other_service,
      typename IoObjectService1::implementation_type & other_implementation);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_io_object.basic_io_object.overload3 more...]]``


[section:overload1 basic_io_object::basic_io_object (1 of 3 overloads)]


Construct a [link networking_ts.reference.basic_io_object `basic_io_object`]. 


  basic_io_object(
      std::experimental::net::io_context & io_context);


Performs: 

   get_service().construct(get_implementation()); 





[endsect]



[section:overload2 basic_io_object::basic_io_object (2 of 3 overloads)]


Move-construct a [link networking_ts.reference.basic_io_object `basic_io_object`]. 


  basic_io_object(
      basic_io_object && other);


Performs: 

   get_service().move_construct(
       get_implementation(), other.get_implementation()); 





[heading Remarks]
      
Available only for services that support movability, 




[endsect]



[section:overload3 basic_io_object::basic_io_object (3 of 3 overloads)]


Perform a converting move-construction of a [link networking_ts.reference.basic_io_object `basic_io_object`]. 


  template<
      typename IoObjectService1>
  basic_io_object(
      IoObjectService1 & other_service,
      typename IoObjectService1::implementation_type & other_implementation);



[endsect]


[endsect]


[section:executor_type basic_io_object::executor_type]


The type of the executor associated with the object. 


  typedef std::experimental::net::io_context::executor_type executor_type;




[endsect]



[section:get_executor basic_io_object::get_executor]


Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_implementation basic_io_object::get_implementation]


Get the underlying implementation of the I/O object. 


  implementation_type & ``[link networking_ts.reference.basic_io_object.get_implementation.overload1 get_implementation]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_io_object.get_implementation.overload1 more...]]``

  const implementation_type & ``[link networking_ts.reference.basic_io_object.get_implementation.overload2 get_implementation]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_io_object.get_implementation.overload2 more...]]``


[section:overload1 basic_io_object::get_implementation (1 of 2 overloads)]


Get the underlying implementation of the I/O object. 


  implementation_type & get_implementation();



[endsect]



[section:overload2 basic_io_object::get_implementation (2 of 2 overloads)]


Get the underlying implementation of the I/O object. 


  const implementation_type & get_implementation() const;



[endsect]


[endsect]

[section:get_service basic_io_object::get_service]


Get the service associated with the I/O object. 


  service_type & ``[link networking_ts.reference.basic_io_object.get_service.overload1 get_service]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_io_object.get_service.overload1 more...]]``

  const service_type & ``[link networking_ts.reference.basic_io_object.get_service.overload2 get_service]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_io_object.get_service.overload2 more...]]``


[section:overload1 basic_io_object::get_service (1 of 2 overloads)]


Get the service associated with the I/O object. 


  service_type & get_service();



[endsect]



[section:overload2 basic_io_object::get_service (2 of 2 overloads)]


Get the service associated with the I/O object. 


  const service_type & get_service() const;



[endsect]


[endsect]


[section:implementation_type basic_io_object::implementation_type]


The underlying implementation type of I/O object. 


  typedef service_type::implementation_type implementation_type;




[endsect]



[section:operator_eq_ basic_io_object::operator=]


Move-assign a [link networking_ts.reference.basic_io_object `basic_io_object`]. 


  basic_io_object & operator=(
      basic_io_object && other);


Performs: 

   get_service().move_assign(get_implementation(),
       other.get_service(), other.get_implementation()); 





[heading Remarks]
      
Available only for services that support movability, 




[endsect]



[section:service_type basic_io_object::service_type]


The type of the service that will be used to provide I/O operations. 


  typedef IoObjectService service_type;




[endsect]



[section:_basic_io_object basic_io_object::~basic_io_object]


Protected destructor to prevent deletion through this type. 


  ~basic_io_object();


Performs: 

   get_service().destroy(get_implementation()); 





[endsect]



[endsect]

[section:basic_socket basic_socket]


Provides socket functionality. 


  template<
      typename Protocol>
  class basic_socket :
    public socket_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.basic_socket [*basic_socket]]]
    [Construct a basic_socket without opening it. 

     Construct and open a basic_socket. 

     Construct a basic_socket, opening it and binding it to the given local endpoint. 

     Construct a basic_socket on an existing native socket. 

     Move-construct a basic_socket from another. 

     Move-construct a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 

     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 

     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket from another. 

     Move-assign a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket._basic_socket [*~basic_socket]]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket.max_listen_connections [*max_listen_connections]]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link networking_ts.reference.basic_socket.message_do_not_route [*message_do_not_route]]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link networking_ts.reference.basic_socket.message_end_of_record [*message_end_of_record]]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link networking_ts.reference.basic_socket.message_out_of_band [*message_out_of_band]]]
    [Process out-of-band data. ]
  ]

  [
    [[link networking_ts.reference.basic_socket.message_peek [*message_peek]]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link networking_ts.reference.basic_socket `basic_socket`] class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:assign basic_socket::assign]


Assign an existing native socket to the socket. 


  void ``[link networking_ts.reference.basic_socket.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.assign.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.assign.overload2 more...]]``


[section:overload1 basic_socket::assign (1 of 2 overloads)]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket);



[endsect]



[section:overload2 basic_socket::assign (2 of 2 overloads)]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      std::error_code & ec);



[endsect]


[endsect]


[section:async_connect basic_socket::async_connect]


Start an asynchronous connect. 


  template<
      typename ConnectHandler>
  DEDUCED async_connect(
      const endpoint_type & peer_endpoint,
      ConnectHandler && handler);


This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.]]

[[handler][The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void connect_handler(const std::error_code& error)
   {
     if (!error)
     {
       // Connect succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::socket socket(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_connect(endpoint, connect_handler);







[endsect]



[section:async_wait basic_socket::async_wait]


Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename WaitHandler>
  DEDUCED async_wait(
      wait_type w,
      WaitHandler && handler);


This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void wait_handler(const std::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   socket.async_wait(std::experimental::net::ip::tcp::socket::wait_read, wait_handler);







[endsect]


[section:at_mark basic_socket::at_mark]


Determine whether the socket is at the out-of-band data mark. 


  bool ``[link networking_ts.reference.basic_socket.at_mark.overload1 at_mark]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.at_mark.overload1 more...]]``

  bool ``[link networking_ts.reference.basic_socket.at_mark.overload2 at_mark]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.at_mark.overload2 more...]]``


[section:overload1 basic_socket::at_mark (1 of 2 overloads)]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark() const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket::at_mark (2 of 2 overloads)]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark(
      std::error_code & ec) const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark. 




[endsect]


[endsect]

[section:available basic_socket::available]


Determine the number of bytes available for reading. 


  std::size_t ``[link networking_ts.reference.basic_socket.available.overload1 available]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.available.overload1 more...]]``

  std::size_t ``[link networking_ts.reference.basic_socket.available.overload2 available]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.available.overload2 more...]]``


[section:overload1 basic_socket::available (1 of 2 overloads)]


Determine the number of bytes available for reading. 


  std::size_t available() const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket::available (2 of 2 overloads)]


Determine the number of bytes available for reading. 


  std::size_t available(
      std::error_code & ec) const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs. 




[endsect]


[endsect]

[section:basic_socket basic_socket::basic_socket]


Construct a [link networking_ts.reference.basic_socket `basic_socket`] without opening it. 


  explicit ``[link networking_ts.reference.basic_socket.basic_socket.overload1 basic_socket]``(
      std::experimental::net::io_context & io_context);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.basic_socket.overload1 more...]]``


Construct and open a [link networking_ts.reference.basic_socket `basic_socket`]. 


  ``[link networking_ts.reference.basic_socket.basic_socket.overload2 basic_socket]``(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.basic_socket.overload2 more...]]``


Construct a [link networking_ts.reference.basic_socket `basic_socket`], opening it and binding it to the given local endpoint. 


  ``[link networking_ts.reference.basic_socket.basic_socket.overload3 basic_socket]``(
      std::experimental::net::io_context & io_context,
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.basic_socket.overload3 more...]]``


Construct a [link networking_ts.reference.basic_socket `basic_socket`] on an existing native socket. 


  ``[link networking_ts.reference.basic_socket.basic_socket.overload4 basic_socket]``(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.basic_socket.overload4 more...]]``


Move-construct a [link networking_ts.reference.basic_socket `basic_socket`] from another. 


  ``[link networking_ts.reference.basic_socket.basic_socket.overload5 basic_socket]``(
      basic_socket && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.basic_socket.overload5 more...]]``


Move-construct a [link networking_ts.reference.basic_socket `basic_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  ``[link networking_ts.reference.basic_socket.basic_socket.overload6 basic_socket]``(
      basic_socket< Protocol1 > && other,
      typename enable_if< is_convertible< Protocol1, Protocol >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.basic_socket.overload6 more...]]``


[section:overload1 basic_socket::basic_socket (1 of 6 overloads)]


Construct a [link networking_ts.reference.basic_socket `basic_socket`] without opening it. 


  basic_socket(
      std::experimental::net::io_context & io_context);


This constructor creates a socket without opening it.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the socket will use to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload2 basic_socket::basic_socket (2 of 6 overloads)]


Construct and open a [link networking_ts.reference.basic_socket `basic_socket`]. 


  basic_socket(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol);


This constructor creates and opens a socket.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the socket will use to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_socket::basic_socket (3 of 6 overloads)]


Construct a [link networking_ts.reference.basic_socket `basic_socket`], opening it and binding it to the given local endpoint. 


  basic_socket(
      std::experimental::net::io_context & io_context,
      const endpoint_type & endpoint);


This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the socket will use to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_socket::basic_socket (4 of 6 overloads)]


Construct a [link networking_ts.reference.basic_socket `basic_socket`] on an existing native socket. 


  basic_socket(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol,
      const native_handle_type & native_socket);


This constructor creates a socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the socket will use to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][A native socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_socket::basic_socket (5 of 6 overloads)]


Move-construct a [link networking_ts.reference.basic_socket `basic_socket`] from another. 


  basic_socket(
      basic_socket && other);


This constructor moves a socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_socket `basic_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(io_context&) constructor`. 




[endsect]



[section:overload6 basic_socket::basic_socket (6 of 6 overloads)]


Move-construct a [link networking_ts.reference.basic_socket `basic_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  basic_socket(
      basic_socket< Protocol1 > && other,
      typename enable_if< is_convertible< Protocol1, Protocol >::value >::type *  = 0);


This constructor moves a socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_socket `basic_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(io_context&) constructor`. 




[endsect]


[endsect]

[section:bind basic_socket::bind]


Bind the socket to the given local endpoint. 


  void ``[link networking_ts.reference.basic_socket.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.bind.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.bind.overload2 more...]]``


[section:overload1 basic_socket::bind (1 of 2 overloads)]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   socket.open(std::experimental::net::ip::tcp::v4());
   socket.bind(std::experimental::net::ip::tcp::endpoint(
         std::experimental::net::ip::tcp::v4(), 12345));







[endsect]



[section:overload2 basic_socket::bind (2 of 2 overloads)]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      std::error_code & ec);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   socket.open(std::experimental::net::ip::tcp::v4());
   std::error_code ec;
   socket.bind(std::experimental::net::ip::tcp::endpoint(
         std::experimental::net::ip::tcp::v4(), 12345), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_socket::broadcast]


['Inherited from socket_base.]


Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:bytes_readable basic_socket::bytes_readable]


['Inherited from socket_base.]


IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();








[endsect]


[section:cancel basic_socket::cancel]


Cancel all asynchronous operations associated with the socket. 


  void ``[link networking_ts.reference.basic_socket.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.cancel.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket.cancel.overload2 cancel]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.cancel.overload2 more...]]``


[section:overload1 basic_socket::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the socket. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with std::experimental::net::error::operation\_not\_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless NET\_TS\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining NET\_TS\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_socket::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the socket. 


  void cancel(
      std::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with std::experimental::net::error::operation\_not\_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless NET\_TS\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining NET\_TS\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_socket::close]


Close the socket. 


  void ``[link networking_ts.reference.basic_socket.close.overload1 close]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.close.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket.close.overload2 close]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.close.overload2 more...]]``


[section:overload1 basic_socket::close (1 of 2 overloads)]


Close the socket. 


  void close();


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the std::experimental::net::error::operation\_aborted error.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]



[section:overload2 basic_socket::close (2 of 2 overloads)]


Close the socket. 


  void close(
      std::error_code & ec);


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the std::experimental::net::error::operation\_aborted error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   socket.close(ec);
   if (ec)
   {
     // An error occurred.
   }





[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]


[endsect]

[section:connect basic_socket::connect]


Connect the socket to the specified endpoint. 


  void ``[link networking_ts.reference.basic_socket.connect.overload1 connect]``(
      const endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.connect.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket.connect.overload2 connect]``(
      const endpoint_type & peer_endpoint,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.connect.overload2 more...]]``


[section:overload1 basic_socket::connect (1 of 2 overloads)]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   socket.connect(endpoint);







[endsect]



[section:overload2 basic_socket::connect (2 of 2 overloads)]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint,
      std::error_code & ec);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   std::error_code ec;
   socket.connect(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_socket::debug]


['Inherited from socket_base.]


Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:do_not_route basic_socket::do_not_route]


['Inherited from socket_base.]


Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:enable_connection_aborted basic_socket::enable_connection_aborted]


['Inherited from socket_base.]


Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with std::experimental::net::error::connection\_aborted. By default the option is false.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]



[section:endpoint_type basic_socket::endpoint_type]


The endpoint type. 


  typedef Protocol::endpoint endpoint_type;




[endsect]



[section:executor_type basic_socket::executor_type]


The type of the executor associated with the object. 


  typedef io_context::executor_type executor_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.defer [*defer]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.dispatch [*dispatch]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_finished [*on_work_finished]]]
    [Inform the io_context that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_started [*on_work_started]]]
    [Inform the io_context that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.post [*post]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the io_context is running in the current thread. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]



[endsect]



[section:get_executor basic_socket::get_executor]


Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_socket::get_option]


Get an option from the socket. 


  template<
      typename GettableSocketOption>
  void ``[link networking_ts.reference.basic_socket.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.get_option.overload1 more...]]``

  template<
      typename GettableSocketOption>
  void ``[link networking_ts.reference.basic_socket.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.get_option.overload2 more...]]``


[section:overload1 basic_socket::get_option (1 of 2 overloads)]


Get an option from the socket. 


  template<
      typename GettableSocketOption>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[endsect]



[section:overload2 basic_socket::get_option (2 of 2 overloads)]


Get an option from the socket. 


  template<
      typename GettableSocketOption>
  void get_option(
      GettableSocketOption & option,
      std::error_code & ec) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::keep_alive option;
   std::error_code ec;
   socket.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.value();







[endsect]


[endsect]

[section:io_control basic_socket::io_control]


Perform an IO control command on the socket. 


  template<
      typename IoControlCommand>
  void ``[link networking_ts.reference.basic_socket.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.io_control.overload1 more...]]``

  template<
      typename IoControlCommand>
  void ``[link networking_ts.reference.basic_socket.io_control.overload2 io_control]``(
      IoControlCommand & command,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.io_control.overload2 more...]]``


[section:overload1 basic_socket::io_control (1 of 2 overloads)]


Perform an IO control command on the socket. 


  template<
      typename IoControlCommand>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::bytes_readable command;
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 basic_socket::io_control (2 of 2 overloads)]


Perform an IO control command on the socket. 


  template<
      typename IoControlCommand>
  void io_control(
      IoControlCommand & command,
      std::error_code & ec);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::bytes_readable command;
   std::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open basic_socket::is_open]


Determine whether the socket is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_socket::keep_alive]


['Inherited from socket_base.]


Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:linger basic_socket::linger]


['Inherited from socket_base.]


Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();








[endsect]


[section:local_endpoint basic_socket::local_endpoint]


Get the local endpoint of the socket. 


  endpoint_type ``[link networking_ts.reference.basic_socket.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.local_endpoint.overload1 more...]]``

  endpoint_type ``[link networking_ts.reference.basic_socket.local_endpoint.overload2 local_endpoint]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.local_endpoint.overload2 more...]]``


[section:overload1 basic_socket::local_endpoint (1 of 2 overloads)]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Return Value]
      
An object that represents the local endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint = socket.local_endpoint();







[endsect]



[section:overload2 basic_socket::local_endpoint (2 of 2 overloads)]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint(
      std::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   std::experimental::net::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:max_listen_connections basic_socket::max_listen_connections]


['Inherited from socket_base.]


The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_socket::message_do_not_route]


['Inherited from socket_base.]


Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_socket::message_end_of_record]


['Inherited from socket_base.]


Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_socket::message_flags]


['Inherited from socket_base.]


Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;




[endsect]



[section:message_out_of_band basic_socket::message_out_of_band]


['Inherited from socket_base.]


Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_socket::message_peek]


['Inherited from socket_base.]


Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_socket::native_handle]


Get the native socket representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_socket::native_handle_type]


The native representation of a socket. 


  typedef implementation_defined native_handle_type;




[endsect]


[section:native_non_blocking basic_socket::native_non_blocking]


Gets the non-blocking mode of the native socket implementation. 


  bool ``[link networking_ts.reference.basic_socket.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native socket implementation. 


  void ``[link networking_ts.reference.basic_socket.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.native_non_blocking.overload2 more...]]``

  void ``[link networking_ts.reference.basic_socket.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.native_non_blocking.overload3 more...]]``


[section:overload1 basic_socket::native_non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the native socket implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.


[heading Return Value]
      
`true` if the underlying socket is in non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(std::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = std::error_code(n < 0 ? errno : 0,
               std::experimental::net::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == std::experimental::net::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == std::experimental::net::error::would_block
               || ec == std::experimental::net::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload2 basic_socket::native_non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with std::experimental::net::error::invalid\_argument, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(std::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = std::error_code(n < 0 ? errno : 0,
               std::experimental::net::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == std::experimental::net::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == std::experimental::net::error::would_block
               || ec == std::experimental::net::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload3 basic_socket::native_non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode,
      std::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with std::experimental::net::error::invalid\_argument, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(std::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = std::error_code(n < 0 ? errno : 0,
               std::experimental::net::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == std::experimental::net::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == std::experimental::net::error::would_block
               || ec == std::experimental::net::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]


[endsect]

[section:non_blocking basic_socket::non_blocking]


Gets the non-blocking mode of the socket. 


  bool ``[link networking_ts.reference.basic_socket.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the socket. 


  void ``[link networking_ts.reference.basic_socket.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.non_blocking.overload2 more...]]``

  void ``[link networking_ts.reference.basic_socket.non_blocking.overload3 non_blocking]``(
      bool mode,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.non_blocking.overload3 more...]]``


[section:overload1 basic_socket::non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the socket. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the socket's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]



[section:overload2 basic_socket::non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]



[section:overload3 basic_socket::non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode,
      std::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]


[endsect]

[section:open basic_socket::open]


Open the socket using the specified protocol. 


  void ``[link networking_ts.reference.basic_socket.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.open.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket.open.overload2 open]``(
      const protocol_type & protocol,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.open.overload2 more...]]``


[section:overload1 basic_socket::open (1 of 2 overloads)]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   socket.open(std::experimental::net::ip::tcp::v4());







[endsect]



[section:overload2 basic_socket::open (2 of 2 overloads)]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol,
      std::error_code & ec);


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   std::error_code ec;
   socket.open(std::experimental::net::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_socket::operator=]


Move-assign a [link networking_ts.reference.basic_socket `basic_socket`] from another. 


  basic_socket & ``[link networking_ts.reference.basic_socket.operator_eq_.overload1 operator=]``(
      basic_socket && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.operator_eq_.overload1 more...]]``


Move-assign a [link networking_ts.reference.basic_socket `basic_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  enable_if< is_convertible< Protocol1, Protocol >::value, basic_socket >::type & ``[link networking_ts.reference.basic_socket.operator_eq_.overload2 operator=]``(
      basic_socket< Protocol1 > && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.operator_eq_.overload2 more...]]``


[section:overload1 basic_socket::operator= (1 of 2 overloads)]


Move-assign a [link networking_ts.reference.basic_socket `basic_socket`] from another. 


  basic_socket & operator=(
      basic_socket && other);


This assignment operator moves a socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_socket `basic_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(io_context&) constructor`. 




[endsect]



[section:overload2 basic_socket::operator= (2 of 2 overloads)]


Move-assign a [link networking_ts.reference.basic_socket `basic_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  enable_if< is_convertible< Protocol1, Protocol >::value, basic_socket >::type & operator=(
      basic_socket< Protocol1 > && other);


This assignment operator moves a socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_socket `basic_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(io_context&) constructor`. 




[endsect]


[endsect]


[section:out_of_band_inline basic_socket::out_of_band_inline]


['Inherited from socket_base.]


Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();








[endsect]



[section:protocol_type basic_socket::protocol_type]


The protocol type. 


  typedef Protocol protocol_type;




[endsect]



[section:receive_buffer_size basic_socket::receive_buffer_size]


['Inherited from socket_base.]


Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:receive_low_watermark basic_socket::receive_low_watermark]


['Inherited from socket_base.]


Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]


[section:release basic_socket::release]


Release ownership of the underlying native socket. 


  native_handle_type ``[link networking_ts.reference.basic_socket.release.overload1 release]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.release.overload1 more...]]``

  native_handle_type ``[link networking_ts.reference.basic_socket.release.overload2 release]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.release.overload2 more...]]``


[section:overload1 basic_socket::release (1 of 2 overloads)]


Release ownership of the underlying native socket. 


  native_handle_type release();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error. Ownership of the native socket is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with std::experimental::net::error::operation\_not\_supported on these platforms. 




[endsect]



[section:overload2 basic_socket::release (2 of 2 overloads)]


Release ownership of the underlying native socket. 


  native_handle_type release(
      std::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error. Ownership of the native socket is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with std::experimental::net::error::operation\_not\_supported on these platforms. 




[endsect]


[endsect]

[section:remote_endpoint basic_socket::remote_endpoint]


Get the remote endpoint of the socket. 


  endpoint_type ``[link networking_ts.reference.basic_socket.remote_endpoint.overload1 remote_endpoint]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.remote_endpoint.overload1 more...]]``

  endpoint_type ``[link networking_ts.reference.basic_socket.remote_endpoint.overload2 remote_endpoint]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.remote_endpoint.overload2 more...]]``


[section:overload1 basic_socket::remote_endpoint (1 of 2 overloads)]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint() const;


This function is used to obtain the remote endpoint of the socket.


[heading Return Value]
      
An object that represents the remote endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint = socket.remote_endpoint();







[endsect]



[section:overload2 basic_socket::remote_endpoint (2 of 2 overloads)]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint(
      std::error_code & ec) const;


This function is used to obtain the remote endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   std::experimental::net::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:reuse_address basic_socket::reuse_address]


['Inherited from socket_base.]


Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]



[section:send_buffer_size basic_socket::send_buffer_size]


['Inherited from socket_base.]


Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:send_low_watermark basic_socket::send_low_watermark]


['Inherited from socket_base.]


Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]


[section:set_option basic_socket::set_option]


Set an option on the socket. 


  template<
      typename SettableSocketOption>
  void ``[link networking_ts.reference.basic_socket.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.set_option.overload1 more...]]``

  template<
      typename SettableSocketOption>
  void ``[link networking_ts.reference.basic_socket.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.set_option.overload2 more...]]``


[section:overload1 basic_socket::set_option (1 of 2 overloads)]


Set an option on the socket. 


  template<
      typename SettableSocketOption>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::no_delay option(true);
   socket.set_option(option);







[endsect]



[section:overload2 basic_socket::set_option (2 of 2 overloads)]


Set an option on the socket. 


  template<
      typename SettableSocketOption>
  void set_option(
      const SettableSocketOption & option,
      std::error_code & ec);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::no_delay option(true);
   std::error_code ec;
   socket.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:shutdown basic_socket::shutdown]


Disable sends or receives on the socket. 


  void ``[link networking_ts.reference.basic_socket.shutdown.overload1 shutdown]``(
      shutdown_type what);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.shutdown.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket.shutdown.overload2 shutdown]``(
      shutdown_type what,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.shutdown.overload2 more...]]``


[section:overload1 basic_socket::shutdown (1 of 2 overloads)]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   socket.shutdown(std::experimental::net::ip::tcp::socket::shutdown_send);







[endsect]



[section:overload2 basic_socket::shutdown (2 of 2 overloads)]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what,
      std::error_code & ec);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   socket.shutdown(std::experimental::net::ip::tcp::socket::shutdown_send, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_socket::shutdown_type]


['Inherited from socket_base.]


Different ways a socket may be shutdown. 


  enum shutdown_type


[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_socket::wait]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link networking_ts.reference.basic_socket.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.wait.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket.wait.overload2 wait]``(
      wait_type w,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket.wait.overload2 more...]]``


[section:overload1 basic_socket::wait (1 of 2 overloads)]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   socket.wait(std::experimental::net::ip::tcp::socket::wait_read);







[endsect]



[section:overload2 basic_socket::wait (2 of 2 overloads)]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      std::error_code & ec);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   socket.wait(std::experimental::net::ip::tcp::socket::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_socket::wait_type]


['Inherited from socket_base.]


Wait types. 


  enum wait_type


[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_basic_socket basic_socket::~basic_socket]


Protected destructor to prevent deletion through this type. 


  ~basic_socket();


This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_socket_acceptor basic_socket_acceptor]


Provides the ability to accept new connections. 


  template<
      typename Protocol>
  class basic_socket_acceptor :
    public socket_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_socket_acceptor.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.native_handle_type [*native_handle_type]]]
    [The native representation of an acceptor. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket_acceptor.accept [*accept]]]
    [Accept a new connection. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.assign [*assign]]]
    [Assigns an existing native acceptor to the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.async_accept [*async_accept]]]
    [Start an asynchronous accept. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.async_wait [*async_wait]]]
    [Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor [*basic_socket_acceptor]]]
    [Construct an acceptor without opening it. 

     Construct an open acceptor. 

     Construct an acceptor opened on the given endpoint. 

     Construct a basic_socket_acceptor on an existing native acceptor. 

     Move-construct a basic_socket_acceptor from another. 

     Move-construct a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.bind [*bind]]]
    [Bind the acceptor to the given local endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.get_option [*get_option]]]
    [Get an option from the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.io_control [*io_control]]]
    [Perform an IO control command on the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.is_open [*is_open]]]
    [Determine whether the acceptor is open. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.listen [*listen]]]
    [Place the acceptor into the state where it will listen for new connections. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.native_handle [*native_handle]]]
    [Get the native acceptor representation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native acceptor implementation. 

     Sets the non-blocking mode of the native acceptor implementation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the acceptor. 

     Sets the non-blocking mode of the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.open [*open]]]
    [Open the acceptor using the specified protocol. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_acceptor from another. 

     Move-assign a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.release [*release]]]
    [Release ownership of the underlying native acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.set_option [*set_option]]]
    [Set an option on the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.wait [*wait]]]
    [Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor._basic_socket_acceptor [*~basic_socket_acceptor]]]
    [Destroys the acceptor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket_acceptor.max_listen_connections [*max_listen_connections]]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link networking_ts.reference.basic_socket_acceptor.message_do_not_route [*message_do_not_route]]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link networking_ts.reference.basic_socket_acceptor.message_end_of_record [*message_end_of_record]]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link networking_ts.reference.basic_socket_acceptor.message_out_of_band [*message_out_of_band]]]
    [Process out-of-band data. ]
  ]

  [
    [[link networking_ts.reference.basic_socket_acceptor.message_peek [*message_peek]]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] class template is used for accepting new socket connections.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.


[heading Example]
  
Opening a socket acceptor with the SO\_REUSEADDR option enabled: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(std::experimental::net::ip::tcp::v4(), port);
   acceptor.open(endpoint.protocol());
   acceptor.set_option(std::experimental::net::ip::tcp::acceptor::reuse_address(true));
   acceptor.bind(endpoint);
   acceptor.listen();






[section:accept basic_socket_acceptor::accept]


Accept a new connection. 


  Protocol::socket ``[link networking_ts.reference.basic_socket_acceptor.accept.overload1 accept]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.accept.overload1 more...]]``

  Protocol::socket ``[link networking_ts.reference.basic_socket_acceptor.accept.overload2 accept]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.accept.overload2 more...]]``

  Protocol::socket ``[link networking_ts.reference.basic_socket_acceptor.accept.overload3 accept]``(
      std::experimental::net::io_context & io_context);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.accept.overload3 more...]]``

  Protocol::socket ``[link networking_ts.reference.basic_socket_acceptor.accept.overload4 accept]``(
      std::experimental::net::io_context & io_context,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.accept.overload4 more...]]``

  Protocol::socket ``[link networking_ts.reference.basic_socket_acceptor.accept.overload5 accept]``(
      endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.accept.overload5 more...]]``

  Protocol::socket ``[link networking_ts.reference.basic_socket_acceptor.accept.overload6 accept]``(
      endpoint_type & peer_endpoint,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.accept.overload6 more...]]``

  Protocol::socket ``[link networking_ts.reference.basic_socket_acceptor.accept.overload7 accept]``(
      std::experimental::net::io_context & io_context,
      endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.accept.overload7 more...]]``

  Protocol::socket ``[link networking_ts.reference.basic_socket_acceptor.accept.overload8 accept]``(
      std::experimental::net::io_context & io_context,
      endpoint_type & peer_endpoint,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.accept.overload8 more...]]``


[section:overload1 basic_socket_acceptor::accept (1 of 8 overloads)]


Accept a new connection. 


  Protocol::socket accept();


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::socket socket(acceptor.accept());







[endsect]



[section:overload2 basic_socket_acceptor::accept (2 of 8 overloads)]


Accept a new connection. 


  Protocol::socket accept(
      std::error_code & ec);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::socket socket(acceptor.accept(ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload3 basic_socket_acceptor::accept (3 of 8 overloads)]


Accept a new connection. 


  Protocol::socket accept(
      std::experimental::net::io_context & io_context);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object to be used for the newly accepted socket.]]

]


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::socket socket(acceptor.accept());







[endsect]



[section:overload4 basic_socket_acceptor::accept (4 of 8 overloads)]


Accept a new connection. 


  Protocol::socket accept(
      std::experimental::net::io_context & io_context,
      std::error_code & ec);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object to be used for the newly accepted socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::socket socket(acceptor.accept(io_context2, ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload5 basic_socket_acceptor::accept (5 of 8 overloads)]


Accept a new connection. 


  Protocol::socket accept(
      endpoint_type & peer_endpoint);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

]


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint;
   std::experimental::net::ip::tcp::socket socket(acceptor.accept(endpoint));







[endsect]



[section:overload6 basic_socket_acceptor::accept (6 of 8 overloads)]


Accept a new connection. 


  Protocol::socket accept(
      endpoint_type & peer_endpoint,
      std::error_code & ec);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint;
   std::experimental::net::ip::tcp::socket socket(acceptor.accept(endpoint, ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload7 basic_socket_acceptor::accept (7 of 8 overloads)]


Accept a new connection. 


  Protocol::socket accept(
      std::experimental::net::io_context & io_context,
      endpoint_type & peer_endpoint);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object to be used for the newly accepted socket.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

]


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint;
   std::experimental::net::ip::tcp::socket socket(
       acceptor.accept(io_context2, endpoint));







[endsect]



[section:overload8 basic_socket_acceptor::accept (8 of 8 overloads)]


Accept a new connection. 


  Protocol::socket accept(
      std::experimental::net::io_context & io_context,
      endpoint_type & peer_endpoint,
      std::error_code & ec);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object to be used for the newly accepted socket.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint;
   std::experimental::net::ip::tcp::socket socket(
       acceptor.accept(io_context2, endpoint, ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:assign basic_socket_acceptor::assign]


Assigns an existing native acceptor to the acceptor. 


  void ``[link networking_ts.reference.basic_socket_acceptor.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_acceptor);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.assign.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket_acceptor.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_acceptor,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.assign.overload2 more...]]``


[section:overload1 basic_socket_acceptor::assign (1 of 2 overloads)]


Assigns an existing native acceptor to the acceptor. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_acceptor);



[endsect]



[section:overload2 basic_socket_acceptor::assign (2 of 2 overloads)]


Assigns an existing native acceptor to the acceptor. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_acceptor,
      std::error_code & ec);



[endsect]


[endsect]

[section:async_accept basic_socket_acceptor::async_accept]


Start an asynchronous accept. 


  template<
      typename MoveAcceptHandler>
  DEDUCED ``[link networking_ts.reference.basic_socket_acceptor.async_accept.overload1 async_accept]``(
      MoveAcceptHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.async_accept.overload1 more...]]``

  template<
      typename MoveAcceptHandler>
  DEDUCED ``[link networking_ts.reference.basic_socket_acceptor.async_accept.overload2 async_accept]``(
      std::experimental::net::io_context & io_context,
      MoveAcceptHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.async_accept.overload2 more...]]``

  template<
      typename MoveAcceptHandler>
  DEDUCED ``[link networking_ts.reference.basic_socket_acceptor.async_accept.overload3 async_accept]``(
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.async_accept.overload3 more...]]``

  template<
      typename MoveAcceptHandler>
  DEDUCED ``[link networking_ts.reference.basic_socket_acceptor.async_accept.overload4 async_accept]``(
      std::experimental::net::io_context & io_context,
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.async_accept.overload4 more...]]``


[section:overload1 basic_socket_acceptor::async_accept (1 of 4 overloads)]


Start an asynchronous accept. 


  template<
      typename MoveAcceptHandler>
  DEDUCED async_accept(
      MoveAcceptHandler && handler);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     typename Protocol::socket peer // On success, the newly accepted socket.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void accept_handler(const std::error_code& error,
       std::experimental::net::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   acceptor.async_accept(accept_handler);







[endsect]



[section:overload2 basic_socket_acceptor::async_accept (2 of 4 overloads)]


Start an asynchronous accept. 


  template<
      typename MoveAcceptHandler>
  DEDUCED async_accept(
      std::experimental::net::io_context & io_context,
      MoveAcceptHandler && handler);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object to be used for the newly accepted socket.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     typename Protocol::socket peer // On success, the newly accepted socket.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void accept_handler(const std::error_code& error,
       std::experimental::net::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   acceptor.async_accept(io_context2, accept_handler);







[endsect]



[section:overload3 basic_socket_acceptor::async_accept (3 of 4 overloads)]


Start an asynchronous accept. 


  template<
      typename MoveAcceptHandler>
  DEDUCED async_accept(
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     typename Protocol::socket peer // On success, the newly accepted socket.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void accept_handler(const std::error_code& error,
       std::experimental::net::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint;
   acceptor.async_accept(endpoint, accept_handler);







[endsect]



[section:overload4 basic_socket_acceptor::async_accept (4 of 4 overloads)]


Start an asynchronous accept. 


  template<
      typename MoveAcceptHandler>
  DEDUCED async_accept(
      std::experimental::net::io_context & io_context,
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object to be used for the newly accepted socket.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     typename Protocol::socket peer // On success, the newly accepted socket.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void accept_handler(const std::error_code& error,
       std::experimental::net::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint;
   acceptor.async_accept(io_context2, endpoint, accept_handler);







[endsect]


[endsect]


[section:async_wait basic_socket_acceptor::async_wait]


Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename WaitHandler>
  DEDUCED async_wait(
      wait_type w,
      WaitHandler && handler);


This function is used to perform an asynchronous wait for an acceptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired acceptor state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void wait_handler(const std::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   acceptor.async_wait(
       std::experimental::net::ip::tcp::acceptor::wait_read,
       wait_handler);







[endsect]


[section:basic_socket_acceptor basic_socket_acceptor::basic_socket_acceptor]


Construct an acceptor without opening it. 


  explicit ``[link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload1 basic_socket_acceptor]``(
      std::experimental::net::io_context & io_context);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload1 more...]]``


Construct an open acceptor. 


  ``[link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload2 basic_socket_acceptor]``(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload2 more...]]``


Construct an acceptor opened on the given endpoint. 


  ``[link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload3 basic_socket_acceptor]``(
      std::experimental::net::io_context & io_context,
      const endpoint_type & endpoint,
      bool reuse_addr = true);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload3 more...]]``


Construct a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] on an existing native acceptor. 


  ``[link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload4 basic_socket_acceptor]``(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol,
      const native_handle_type & native_acceptor);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload4 more...]]``


Move-construct a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] from another. 


  ``[link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload5 basic_socket_acceptor]``(
      basic_socket_acceptor && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload5 more...]]``


Move-construct a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] from an acceptor of another protocol type. 


  template<
      typename Protocol1>
  ``[link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload6 basic_socket_acceptor]``(
      basic_socket_acceptor< Protocol1 > && other,
      typename enable_if< is_convertible< Protocol1, Protocol >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor.overload6 more...]]``


[section:overload1 basic_socket_acceptor::basic_socket_acceptor (1 of 6 overloads)]


Construct an acceptor without opening it. 


  basic_socket_acceptor(
      std::experimental::net::io_context & io_context);


This constructor creates an acceptor without opening it to listen for new connections. The `open()` function must be called before the acceptor can accept new socket connections.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor. ]]

]




[endsect]



[section:overload2 basic_socket_acceptor::basic_socket_acceptor (2 of 6 overloads)]


Construct an open acceptor. 


  basic_socket_acceptor(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol);


This constructor creates an acceptor and automatically opens it.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_socket_acceptor::basic_socket_acceptor (3 of 6 overloads)]


Construct an acceptor opened on the given endpoint. 


  basic_socket_acceptor(
      std::experimental::net::io_context & io_context,
      const endpoint_type & endpoint,
      bool reuse_addr = true);


This constructor creates an acceptor and automatically opens it to listen for new connections on the specified endpoint.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor.]]

[[endpoint][An endpoint on the local machine on which the acceptor will listen for new connections.]]

[[reuse_addr][Whether the constructor should set the socket option `socket_base::reuse_address`.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This constructor is equivalent to the following code: 

   basic_socket_acceptor<Protocol> acceptor(io_context);
   acceptor.open(endpoint.protocol());
   if (reuse_addr)
     acceptor.set_option(socket_base::reuse_address(true));
   acceptor.bind(endpoint);
   acceptor.listen(listen_backlog);







[endsect]



[section:overload4 basic_socket_acceptor::basic_socket_acceptor (4 of 6 overloads)]


Construct a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] on an existing native acceptor. 


  basic_socket_acceptor(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol,
      const native_handle_type & native_acceptor);


This constructor creates an acceptor object to hold an existing native acceptor.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_acceptor][A native acceptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_socket_acceptor::basic_socket_acceptor (5 of 6 overloads)]


Move-construct a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] from another. 


  basic_socket_acceptor(
      basic_socket_acceptor && other);


This constructor moves an acceptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket_acceptor(io_context&) constructor`. 




[endsect]



[section:overload6 basic_socket_acceptor::basic_socket_acceptor (6 of 6 overloads)]


Move-construct a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] from an acceptor of another protocol type. 


  template<
      typename Protocol1>
  basic_socket_acceptor(
      basic_socket_acceptor< Protocol1 > && other,
      typename enable_if< is_convertible< Protocol1, Protocol >::value >::type *  = 0);


This constructor moves an acceptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(io_context&) constructor`. 




[endsect]


[endsect]

[section:bind basic_socket_acceptor::bind]


Bind the acceptor to the given local endpoint. 


  void ``[link networking_ts.reference.basic_socket_acceptor.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.bind.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket_acceptor.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.bind.overload2 more...]]``


[section:overload1 basic_socket_acceptor::bind (1 of 2 overloads)]


Bind the acceptor to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket acceptor to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket acceptor will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(std::experimental::net::ip::tcp::v4(), 12345);
   acceptor.open(endpoint.protocol());
   acceptor.bind(endpoint);







[endsect]



[section:overload2 basic_socket_acceptor::bind (2 of 2 overloads)]


Bind the acceptor to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      std::error_code & ec);


This function binds the socket acceptor to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket acceptor will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(std::experimental::net::ip::tcp::v4(), 12345);
   acceptor.open(endpoint.protocol());
   std::error_code ec;
   acceptor.bind(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_socket_acceptor::broadcast]


['Inherited from socket_base.]


Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:bytes_readable basic_socket_acceptor::bytes_readable]


['Inherited from socket_base.]


IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();








[endsect]


[section:cancel basic_socket_acceptor::cancel]


Cancel all asynchronous operations associated with the acceptor. 


  void ``[link networking_ts.reference.basic_socket_acceptor.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.cancel.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket_acceptor.cancel.overload2 cancel]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.cancel.overload2 more...]]``


[section:overload1 basic_socket_acceptor::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the acceptor. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket_acceptor::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the acceptor. 


  void cancel(
      std::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close basic_socket_acceptor::close]


Close the acceptor. 


  void ``[link networking_ts.reference.basic_socket_acceptor.close.overload1 close]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.close.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket_acceptor.close.overload2 close]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.close.overload2 more...]]``


[section:overload1 basic_socket_acceptor::close (1 of 2 overloads)]


Close the acceptor. 


  void close();


This function is used to close the acceptor. Any asynchronous accept operations will be cancelled immediately.

A subsequent call to `open()` is required before the acceptor can again be used to again perform socket accept operations.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket_acceptor::close (2 of 2 overloads)]


Close the acceptor. 


  void close(
      std::error_code & ec);


This function is used to close the acceptor. Any asynchronous accept operations will be cancelled immediately.

A subsequent call to `open()` is required before the acceptor can again be used to again perform socket accept operations.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::error_code ec;
   acceptor.close(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_socket_acceptor::debug]


['Inherited from socket_base.]


Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:do_not_route basic_socket_acceptor::do_not_route]


['Inherited from socket_base.]


Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:enable_connection_aborted basic_socket_acceptor::enable_connection_aborted]


['Inherited from socket_base.]


Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with std::experimental::net::error::connection\_aborted. By default the option is false.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]



[section:endpoint_type basic_socket_acceptor::endpoint_type]


The endpoint type. 


  typedef Protocol::endpoint endpoint_type;




[endsect]



[section:executor_type basic_socket_acceptor::executor_type]


The type of the executor associated with the object. 


  typedef io_context::executor_type executor_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.defer [*defer]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.dispatch [*dispatch]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_finished [*on_work_finished]]]
    [Inform the io_context that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_started [*on_work_started]]]
    [Inform the io_context that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.post [*post]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the io_context is running in the current thread. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]



[endsect]



[section:get_executor basic_socket_acceptor::get_executor]


Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_socket_acceptor::get_option]


Get an option from the acceptor. 


  template<
      typename GettableSocketOption>
  void ``[link networking_ts.reference.basic_socket_acceptor.get_option.overload1 get_option]``(
      GettableSocketOption & option);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.get_option.overload1 more...]]``

  template<
      typename GettableSocketOption>
  void ``[link networking_ts.reference.basic_socket_acceptor.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.get_option.overload2 more...]]``


[section:overload1 basic_socket_acceptor::get_option (1 of 2 overloads)]


Get an option from the acceptor. 


  template<
      typename GettableSocketOption>
  void get_option(
      GettableSocketOption & option);


This function is used to get the current value of an option on the acceptor.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the acceptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_REUSEADDR option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::acceptor::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.get();







[endsect]



[section:overload2 basic_socket_acceptor::get_option (2 of 2 overloads)]


Get an option from the acceptor. 


  template<
      typename GettableSocketOption>
  void get_option(
      GettableSocketOption & option,
      std::error_code & ec);


This function is used to get the current value of an option on the acceptor.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the acceptor.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_REUSEADDR option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::acceptor::reuse_address option;
   std::error_code ec;
   acceptor.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.get();







[endsect]


[endsect]

[section:io_control basic_socket_acceptor::io_control]


Perform an IO control command on the acceptor. 


  template<
      typename IoControlCommand>
  void ``[link networking_ts.reference.basic_socket_acceptor.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.io_control.overload1 more...]]``

  template<
      typename IoControlCommand>
  void ``[link networking_ts.reference.basic_socket_acceptor.io_control.overload2 io_control]``(
      IoControlCommand & command,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.io_control.overload2 more...]]``


[section:overload1 basic_socket_acceptor::io_control (1 of 2 overloads)]


Perform an IO control command on the acceptor. 


  template<
      typename IoControlCommand>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the acceptor.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the acceptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::acceptor::non_blocking_io command(true);
   socket.io_control(command);







[endsect]



[section:overload2 basic_socket_acceptor::io_control (2 of 2 overloads)]


Perform an IO control command on the acceptor. 


  template<
      typename IoControlCommand>
  void io_control(
      IoControlCommand & command,
      std::error_code & ec);


This function is used to execute an IO control command on the acceptor.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the acceptor.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::acceptor::non_blocking_io command(true);
   std::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:is_open basic_socket_acceptor::is_open]


Determine whether the acceptor is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_socket_acceptor::keep_alive]


['Inherited from socket_base.]


Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:linger basic_socket_acceptor::linger]


['Inherited from socket_base.]


Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();








[endsect]


[section:listen basic_socket_acceptor::listen]


Place the acceptor into the state where it will listen for new connections. 


  void ``[link networking_ts.reference.basic_socket_acceptor.listen.overload1 listen]``(
      int backlog = socket_base::max_listen_connections);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.listen.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket_acceptor.listen.overload2 listen]``(
      int backlog,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.listen.overload2 more...]]``


[section:overload1 basic_socket_acceptor::listen (1 of 2 overloads)]


Place the acceptor into the state where it will listen for new connections. 


  void listen(
      int backlog = socket_base::max_listen_connections);


This function puts the socket acceptor into the state where it may accept new connections.


[heading Parameters]
    

[variablelist
  
[[backlog][The maximum length of the queue of pending connections.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket_acceptor::listen (2 of 2 overloads)]


Place the acceptor into the state where it will listen for new connections. 


  void listen(
      int backlog,
      std::error_code & ec);


This function puts the socket acceptor into the state where it may accept new connections.


[heading Parameters]
    

[variablelist
  
[[backlog][The maximum length of the queue of pending connections.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::error_code ec;
   acceptor.listen(std::experimental::net::socket_base::max_listen_connections, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:local_endpoint basic_socket_acceptor::local_endpoint]


Get the local endpoint of the acceptor. 


  endpoint_type ``[link networking_ts.reference.basic_socket_acceptor.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.local_endpoint.overload1 more...]]``

  endpoint_type ``[link networking_ts.reference.basic_socket_acceptor.local_endpoint.overload2 local_endpoint]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.local_endpoint.overload2 more...]]``


[section:overload1 basic_socket_acceptor::local_endpoint (1 of 2 overloads)]


Get the local endpoint of the acceptor. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the acceptor.


[heading Return Value]
      
An object that represents the local endpoint of the acceptor.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint = acceptor.local_endpoint();







[endsect]



[section:overload2 basic_socket_acceptor::local_endpoint (2 of 2 overloads)]


Get the local endpoint of the acceptor. 


  endpoint_type local_endpoint(
      std::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the acceptor.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the acceptor. Returns a default-constructed endpoint object if an error occurred and the error handler did not throw an exception.


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::error_code ec;
   std::experimental::net::ip::tcp::endpoint endpoint = acceptor.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:max_listen_connections basic_socket_acceptor::max_listen_connections]


['Inherited from socket_base.]


The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_socket_acceptor::message_do_not_route]


['Inherited from socket_base.]


Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_socket_acceptor::message_end_of_record]


['Inherited from socket_base.]


Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_socket_acceptor::message_flags]


['Inherited from socket_base.]


Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;




[endsect]



[section:message_out_of_band basic_socket_acceptor::message_out_of_band]


['Inherited from socket_base.]


Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_socket_acceptor::message_peek]


['Inherited from socket_base.]


Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_socket_acceptor::native_handle]


Get the native acceptor representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the acceptor. This is intended to allow access to native acceptor functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_socket_acceptor::native_handle_type]


The native representation of an acceptor. 


  typedef implementation_defined native_handle_type;




[endsect]


[section:native_non_blocking basic_socket_acceptor::native_non_blocking]


Gets the non-blocking mode of the native acceptor implementation. 


  bool ``[link networking_ts.reference.basic_socket_acceptor.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native acceptor implementation. 


  void ``[link networking_ts.reference.basic_socket_acceptor.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.native_non_blocking.overload2 more...]]``

  void ``[link networking_ts.reference.basic_socket_acceptor.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.native_non_blocking.overload3 more...]]``


[section:overload1 basic_socket_acceptor::native_non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the native acceptor implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native acceptor. This mode has no effect on the behaviour of the acceptor object's synchronous operations.


[heading Return Value]
      
`true` if the underlying acceptor is in non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the acceptor object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native acceptor. 




[endsect]



[section:overload2 basic_socket_acceptor::native_non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the native acceptor implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native acceptor. It has no effect on the behaviour of the acceptor object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying acceptor is put into non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with std::experimental::net::error::invalid\_argument, as the combination does not make sense. ]]

]




[endsect]



[section:overload3 basic_socket_acceptor::native_non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the native acceptor implementation. 


  void native_non_blocking(
      bool mode,
      std::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native acceptor. It has no effect on the behaviour of the acceptor object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying acceptor is put into non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with std::experimental::net::error::invalid\_argument, as the combination does not make sense. ]]

]




[endsect]


[endsect]

[section:non_blocking basic_socket_acceptor::non_blocking]


Gets the non-blocking mode of the acceptor. 


  bool ``[link networking_ts.reference.basic_socket_acceptor.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the acceptor. 


  void ``[link networking_ts.reference.basic_socket_acceptor.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.non_blocking.overload2 more...]]``

  void ``[link networking_ts.reference.basic_socket_acceptor.non_blocking.overload3 non_blocking]``(
      bool mode,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.non_blocking.overload3 more...]]``


[section:overload1 basic_socket_acceptor::non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the acceptor. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the acceptor's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]



[section:overload2 basic_socket_acceptor::non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the acceptor. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the acceptor's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]



[section:overload3 basic_socket_acceptor::non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the acceptor. 


  void non_blocking(
      bool mode,
      std::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the acceptor's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]


[endsect]

[section:open basic_socket_acceptor::open]


Open the acceptor using the specified protocol. 


  void ``[link networking_ts.reference.basic_socket_acceptor.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.open.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket_acceptor.open.overload2 open]``(
      const protocol_type & protocol,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.open.overload2 more...]]``


[section:overload1 basic_socket_acceptor::open (1 of 2 overloads)]


Open the acceptor using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket acceptor so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   acceptor.open(std::experimental::net::ip::tcp::v4());







[endsect]



[section:overload2 basic_socket_acceptor::open (2 of 2 overloads)]


Open the acceptor using the specified protocol. 


  void open(
      const protocol_type & protocol,
      std::error_code & ec);


This function opens the socket acceptor so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   std::error_code ec;
   acceptor.open(std::experimental::net::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_socket_acceptor::operator=]


Move-assign a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] from another. 


  basic_socket_acceptor & ``[link networking_ts.reference.basic_socket_acceptor.operator_eq_.overload1 operator=]``(
      basic_socket_acceptor && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.operator_eq_.overload1 more...]]``


Move-assign a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] from an acceptor of another protocol type. 


  template<
      typename Protocol1>
  enable_if< is_convertible< Protocol1, Protocol >::value, basic_socket_acceptor >::type & ``[link networking_ts.reference.basic_socket_acceptor.operator_eq_.overload2 operator=]``(
      basic_socket_acceptor< Protocol1 > && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.operator_eq_.overload2 more...]]``


[section:overload1 basic_socket_acceptor::operator= (1 of 2 overloads)]


Move-assign a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] from another. 


  basic_socket_acceptor & operator=(
      basic_socket_acceptor && other);


This assignment operator moves an acceptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket_acceptor(io_context&) constructor`. 




[endsect]



[section:overload2 basic_socket_acceptor::operator= (2 of 2 overloads)]


Move-assign a [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] from an acceptor of another protocol type. 


  template<
      typename Protocol1>
  enable_if< is_convertible< Protocol1, Protocol >::value, basic_socket_acceptor >::type & operator=(
      basic_socket_acceptor< Protocol1 > && other);


This assignment operator moves an acceptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(io_context&) constructor`. 




[endsect]


[endsect]


[section:out_of_band_inline basic_socket_acceptor::out_of_band_inline]


['Inherited from socket_base.]


Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();








[endsect]



[section:protocol_type basic_socket_acceptor::protocol_type]


The protocol type. 


  typedef Protocol protocol_type;




[endsect]



[section:receive_buffer_size basic_socket_acceptor::receive_buffer_size]


['Inherited from socket_base.]


Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:receive_low_watermark basic_socket_acceptor::receive_low_watermark]


['Inherited from socket_base.]


Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]


[section:release basic_socket_acceptor::release]


Release ownership of the underlying native acceptor. 


  native_handle_type ``[link networking_ts.reference.basic_socket_acceptor.release.overload1 release]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.release.overload1 more...]]``

  native_handle_type ``[link networking_ts.reference.basic_socket_acceptor.release.overload2 release]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.release.overload2 more...]]``


[section:overload1 basic_socket_acceptor::release (1 of 2 overloads)]


Release ownership of the underlying native acceptor. 


  native_handle_type release();


This function causes all outstanding asynchronous accept operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error. Ownership of the native acceptor is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with std::experimental::net::error::operation\_not\_supported on these platforms. 




[endsect]



[section:overload2 basic_socket_acceptor::release (2 of 2 overloads)]


Release ownership of the underlying native acceptor. 


  native_handle_type release(
      std::error_code & ec);


This function causes all outstanding asynchronous accept operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error. Ownership of the native acceptor is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with std::experimental::net::error::operation\_not\_supported on these platforms. 




[endsect]


[endsect]


[section:reuse_address basic_socket_acceptor::reuse_address]


['Inherited from socket_base.]


Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]



[section:send_buffer_size basic_socket_acceptor::send_buffer_size]


['Inherited from socket_base.]


Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:send_low_watermark basic_socket_acceptor::send_low_watermark]


['Inherited from socket_base.]


Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]


[section:set_option basic_socket_acceptor::set_option]


Set an option on the acceptor. 


  template<
      typename SettableSocketOption>
  void ``[link networking_ts.reference.basic_socket_acceptor.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.set_option.overload1 more...]]``

  template<
      typename SettableSocketOption>
  void ``[link networking_ts.reference.basic_socket_acceptor.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.set_option.overload2 more...]]``


[section:overload1 basic_socket_acceptor::set_option (1 of 2 overloads)]


Set an option on the acceptor. 


  template<
      typename SettableSocketOption>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the acceptor.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the acceptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the SOL\_SOCKET/SO\_REUSEADDR option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::acceptor::reuse_address option(true);
   acceptor.set_option(option);







[endsect]



[section:overload2 basic_socket_acceptor::set_option (2 of 2 overloads)]


Set an option on the acceptor. 


  template<
      typename SettableSocketOption>
  void set_option(
      const SettableSocketOption & option,
      std::error_code & ec);


This function is used to set an option on the acceptor.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the acceptor.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the SOL\_SOCKET/SO\_REUSEADDR option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::experimental::net::ip::tcp::acceptor::reuse_address option(true);
   std::error_code ec;
   acceptor.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_socket_acceptor::shutdown_type]


['Inherited from socket_base.]


Different ways a socket may be shutdown. 


  enum shutdown_type


[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_socket_acceptor::wait]


Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link networking_ts.reference.basic_socket_acceptor.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.wait.overload1 more...]]``

  void ``[link networking_ts.reference.basic_socket_acceptor.wait.overload2 wait]``(
      wait_type w,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_acceptor.wait.overload2 more...]]``


[section:overload1 basic_socket_acceptor::wait (1 of 2 overloads)]


Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for an acceptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired acceptor state.]]

]


[heading Example]
  
Waiting for an acceptor to become readable. 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   acceptor.wait(std::experimental::net::ip::tcp::acceptor::wait_read);







[endsect]



[section:overload2 basic_socket_acceptor::wait (2 of 2 overloads)]


Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      std::error_code & ec);


This function is used to perform a blocking wait for an acceptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired acceptor state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for an acceptor to become readable. 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   ...
   std::error_code ec;
   acceptor.wait(std::experimental::net::ip::tcp::acceptor::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_socket_acceptor::wait_type]


['Inherited from socket_base.]


Wait types. 


  enum wait_type


[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_basic_socket_acceptor basic_socket_acceptor::~basic_socket_acceptor]


Destroys the acceptor. 


  ~basic_socket_acceptor();


This function destroys the acceptor, cancelling any outstanding asynchronous operations associated with the acceptor as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_socket_iostream basic_socket_iostream]


Iostream interface for a socket. 


  template<
      typename Protocol,
      typename Clock = chrono::steady_clock,
      typename WaitTraits = wait_traits<Clock>>
  class basic_socket_iostream


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_socket_iostream.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.duration [*duration]]]
    [The duration type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.duration_type [*duration_type]]]
    [(Deprecated: Use duration.) The duration type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.time_point [*time_point]]]
    [The time type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.time_type [*time_type]]]
    [(Deprecated: Use time_point.) The time type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket_iostream.basic_socket_iostream [*basic_socket_iostream]]]
    [Construct a basic_socket_iostream without establishing a connection. 

     Construct a basic_socket_iostream from the supplied socket. 

     Move-construct a basic_socket_iostream from another. 

     Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.close [*close]]]
    [Close the connection. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.connect [*connect]]]
    [Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.error [*error]]]
    [Get the last error associated with the stream. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.expires_after [*expires_after]]]
    [Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.expires_at [*expires_at]]]
    [Set the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.expiry [*expiry]]]
    [Get the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_iostream from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.rdbuf [*rdbuf]]]
    [Return a pointer to the underlying streambuf. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.socket [*socket]]]
    [Get a reference to the underlying socket. ]
  ]
  
]

[section:basic_socket_iostream basic_socket_iostream::basic_socket_iostream]


Construct a [link networking_ts.reference.basic_socket_iostream `basic_socket_iostream`] without establishing a connection. 


  ``[link networking_ts.reference.basic_socket_iostream.basic_socket_iostream.overload1 basic_socket_iostream]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_iostream.basic_socket_iostream.overload1 more...]]``


Construct a [link networking_ts.reference.basic_socket_iostream `basic_socket_iostream`] from the supplied socket. 


  explicit ``[link networking_ts.reference.basic_socket_iostream.basic_socket_iostream.overload2 basic_socket_iostream]``(
      basic_stream_socket< protocol_type > s);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_iostream.basic_socket_iostream.overload2 more...]]``


Move-construct a [link networking_ts.reference.basic_socket_iostream `basic_socket_iostream`] from another. 


  ``[link networking_ts.reference.basic_socket_iostream.basic_socket_iostream.overload3 basic_socket_iostream]``(
      basic_socket_iostream && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_iostream.basic_socket_iostream.overload3 more...]]``


Establish a connection to an endpoint corresponding to a resolver query. 


  template<
      typename T1,
      ... ,
      typename TN>
  explicit ``[link networking_ts.reference.basic_socket_iostream.basic_socket_iostream.overload4 basic_socket_iostream]``(
      T1 t1,
      ... ,
      TN tn);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_iostream.basic_socket_iostream.overload4 more...]]``


[section:overload1 basic_socket_iostream::basic_socket_iostream (1 of 4 overloads)]


Construct a [link networking_ts.reference.basic_socket_iostream `basic_socket_iostream`] without establishing a connection. 


  basic_socket_iostream();



[endsect]



[section:overload2 basic_socket_iostream::basic_socket_iostream (2 of 4 overloads)]


Construct a [link networking_ts.reference.basic_socket_iostream `basic_socket_iostream`] from the supplied socket. 


  basic_socket_iostream(
      basic_stream_socket< protocol_type > s);



[endsect]



[section:overload3 basic_socket_iostream::basic_socket_iostream (3 of 4 overloads)]


Move-construct a [link networking_ts.reference.basic_socket_iostream `basic_socket_iostream`] from another. 


  basic_socket_iostream(
      basic_socket_iostream && other);



[endsect]



[section:overload4 basic_socket_iostream::basic_socket_iostream (4 of 4 overloads)]


Establish a connection to an endpoint corresponding to a resolver query. 


  template<
      typename T1,
      ... ,
      typename TN>
  basic_socket_iostream(
      T1 t1,
      ... ,
      TN tn);


This constructor automatically establishes a connection based on the supplied resolver query parameters. The arguments are used to construct a resolver query object. 


[endsect]


[endsect]


[section:clock_type basic_socket_iostream::clock_type]


The clock type. 


  typedef Clock clock_type;




[endsect]



[section:close basic_socket_iostream::close]


Close the connection. 


  void close();



[endsect]



[section:connect basic_socket_iostream::connect]


Establish a connection to an endpoint corresponding to a resolver query. 


  template<
      typename T1,
      ... ,
      typename TN>
  void connect(
      T1 t1,
      ... ,
      TN tn);


This function automatically establishes a connection based on the supplied resolver query parameters. The arguments are used to construct a resolver query object. 


[endsect]



[section:duration basic_socket_iostream::duration]


The duration type. 


  typedef WaitTraits::duration duration;




[endsect]



[section:duration_type basic_socket_iostream::duration_type]


(Deprecated: Use duration.) The duration type. 


  typedef WaitTraits::duration_type duration_type;




[endsect]



[section:endpoint_type basic_socket_iostream::endpoint_type]


The endpoint type. 


  typedef Protocol::endpoint endpoint_type;




[endsect]



[section:error basic_socket_iostream::error]


Get the last error associated with the stream. 


  const std::error_code & error() const;



[heading Return Value]
      
An `error_code` corresponding to the last error from the stream.


[heading Example]
  
To print the error associated with a failure to establish a connection: 

   tcp::iostream s("www.boost.org", "http");
   if (!s)
   {
     std::cout << "Error: " << s.error().message() << std::endl;
   } 







[endsect]



[section:expires_after basic_socket_iostream::expires_after]


Set the stream's expiry time relative to now. 


  void expires_after(
      const duration & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error std::experimental::net::error::operation\_aborted.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer. ]]

]




[endsect]



[section:expires_at basic_socket_iostream::expires_at]


Set the stream's expiry time as an absolute time. 


  void expires_at(
      const time_point & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error std::experimental::net::error::operation\_aborted.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the stream. ]]

]




[endsect]



[section:expiry basic_socket_iostream::expiry]


Get the stream's expiry time as an absolute time. 


  time_point expiry() const;



[heading Return Value]
      
An absolute time value representing the stream's expiry time. 




[endsect]



[section:operator_eq_ basic_socket_iostream::operator=]


Move-assign a [link networking_ts.reference.basic_socket_iostream `basic_socket_iostream`] from another. 


  basic_socket_iostream & operator=(
      basic_socket_iostream && other);



[endsect]



[section:protocol_type basic_socket_iostream::protocol_type]


The protocol type. 


  typedef Protocol protocol_type;




[endsect]



[section:rdbuf basic_socket_iostream::rdbuf]


Return a pointer to the underlying streambuf. 


  basic_socket_streambuf< Protocol, Clock, WaitTraits > * rdbuf() const;



[endsect]



[section:socket basic_socket_iostream::socket]


Get a reference to the underlying socket. 


  basic_socket< Protocol > & socket();



[endsect]



[section:time_point basic_socket_iostream::time_point]


The time type. 


  typedef WaitTraits::time_point time_point;




[endsect]



[section:time_type basic_socket_iostream::time_type]


(Deprecated: Use time\_point.) The time type. 


  typedef WaitTraits::time_type time_type;




[endsect]



[endsect]

[section:basic_socket_streambuf basic_socket_streambuf]


Iostream streambuf for a socket. 


  template<
      typename Protocol,
      typename Clock = chrono::steady_clock,
      typename WaitTraits = wait_traits<Clock>>
  class basic_socket_streambuf :
    basic_socket< Protocol >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_socket_streambuf.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_streambuf.duration [*duration]]]
    [The duration type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_streambuf.duration_type [*duration_type]]]
    [(Deprecated: Use duration.) The duration type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_streambuf.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_streambuf.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_streambuf.time_point [*time_point]]]
    [The time type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_streambuf.time_type [*time_type]]]
    [(Deprecated: Use time_point.) The time type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket_streambuf.basic_socket_streambuf [*basic_socket_streambuf]]]
    [Construct a basic_socket_streambuf without establishing a connection. 

     Construct a basic_socket_streambuf from the supplied socket. 

     Move-construct a basic_socket_streambuf from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.close [*close]]]
    [Close the connection. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.connect [*connect]]]
    [Establish a connection. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.error [*error]]]
    [Get the last error associated with the stream buffer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.expires_after [*expires_after]]]
    [Set the stream buffer's expiry time relative to now. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.expires_at [*expires_at]]]
    [Set the stream buffer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.expiry [*expiry]]]
    [Get the stream buffer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_streambuf from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.socket [*socket]]]
    [Get a reference to the underlying socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf._basic_socket_streambuf [*~basic_socket_streambuf]]]
    [Destructor flushes buffered data. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket_streambuf.overflow [*overflow]]]
    []
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.setbuf [*setbuf]]]
    []
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.sync [*sync]]]
    []
  ]
  
  [
    [[link networking_ts.reference.basic_socket_streambuf.underflow [*underflow]]]
    []
  ]
  
]

[section:basic_socket_streambuf basic_socket_streambuf::basic_socket_streambuf]


Construct a [link networking_ts.reference.basic_socket_streambuf `basic_socket_streambuf`] without establishing a connection. 


  ``[link networking_ts.reference.basic_socket_streambuf.basic_socket_streambuf.overload1 basic_socket_streambuf]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_streambuf.basic_socket_streambuf.overload1 more...]]``


Construct a [link networking_ts.reference.basic_socket_streambuf `basic_socket_streambuf`] from the supplied socket. 


  explicit ``[link networking_ts.reference.basic_socket_streambuf.basic_socket_streambuf.overload2 basic_socket_streambuf]``(
      basic_stream_socket< protocol_type > s);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_streambuf.basic_socket_streambuf.overload2 more...]]``


Move-construct a [link networking_ts.reference.basic_socket_streambuf `basic_socket_streambuf`] from another. 


  ``[link networking_ts.reference.basic_socket_streambuf.basic_socket_streambuf.overload3 basic_socket_streambuf]``(
      basic_socket_streambuf && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_streambuf.basic_socket_streambuf.overload3 more...]]``


[section:overload1 basic_socket_streambuf::basic_socket_streambuf (1 of 3 overloads)]


Construct a [link networking_ts.reference.basic_socket_streambuf `basic_socket_streambuf`] without establishing a connection. 


  basic_socket_streambuf();



[endsect]



[section:overload2 basic_socket_streambuf::basic_socket_streambuf (2 of 3 overloads)]


Construct a [link networking_ts.reference.basic_socket_streambuf `basic_socket_streambuf`] from the supplied socket. 


  basic_socket_streambuf(
      basic_stream_socket< protocol_type > s);



[endsect]



[section:overload3 basic_socket_streambuf::basic_socket_streambuf (3 of 3 overloads)]


Move-construct a [link networking_ts.reference.basic_socket_streambuf `basic_socket_streambuf`] from another. 


  basic_socket_streambuf(
      basic_socket_streambuf && other);



[endsect]


[endsect]


[section:clock_type basic_socket_streambuf::clock_type]


The clock type. 


  typedef Clock clock_type;




[endsect]



[section:close basic_socket_streambuf::close]


Close the connection. 


  basic_socket_streambuf * close();



[heading Return Value]
      
`this` if a connection was successfully established, a null pointer otherwise. 




[endsect]


[section:connect basic_socket_streambuf::connect]


Establish a connection. 


  basic_socket_streambuf * ``[link networking_ts.reference.basic_socket_streambuf.connect.overload1 connect]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_streambuf.connect.overload1 more...]]``

  template<
      typename T1,
      ... ,
      typename TN>
  basic_socket_streambuf * ``[link networking_ts.reference.basic_socket_streambuf.connect.overload2 connect]``(
      T1 t1,
      ... ,
      TN tn);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_socket_streambuf.connect.overload2 more...]]``


[section:overload1 basic_socket_streambuf::connect (1 of 2 overloads)]


Establish a connection. 


  basic_socket_streambuf * connect(
      const endpoint_type & endpoint);


This function establishes a connection to the specified endpoint.


[heading Return Value]
      
`this` if a connection was successfully established, a null pointer otherwise. 




[endsect]



[section:overload2 basic_socket_streambuf::connect (2 of 2 overloads)]


Establish a connection. 


  template<
      typename T1,
      ... ,
      typename TN>
  basic_socket_streambuf * connect(
      T1 t1,
      ... ,
      TN tn);


This function automatically establishes a connection based on the supplied resolver query parameters. The arguments are used to construct a resolver query object.


[heading Return Value]
      
`this` if a connection was successfully established, a null pointer otherwise. 




[endsect]


[endsect]


[section:duration basic_socket_streambuf::duration]


The duration type. 


  typedef WaitTraits::duration duration;




[endsect]



[section:duration_type basic_socket_streambuf::duration_type]


(Deprecated: Use duration.) The duration type. 


  typedef WaitTraits::duration_type duration_type;




[endsect]



[section:endpoint_type basic_socket_streambuf::endpoint_type]


The endpoint type. 


  typedef Protocol::endpoint endpoint_type;




[endsect]



[section:error basic_socket_streambuf::error]


Get the last error associated with the stream buffer. 


  const std::error_code & error() const;



[heading Return Value]
      
An `error_code` corresponding to the last error from the stream buffer. 




[endsect]



[section:expires_after basic_socket_streambuf::expires_after]


Set the stream buffer's expiry time relative to now. 


  void expires_after(
      const duration & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error std::experimental::net::error::operation\_aborted.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer. ]]

]




[endsect]



[section:expires_at basic_socket_streambuf::expires_at]


Set the stream buffer's expiry time as an absolute time. 


  void expires_at(
      const time_point & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error std::experimental::net::error::operation\_aborted.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the stream. ]]

]




[endsect]



[section:expiry basic_socket_streambuf::expiry]


Get the stream buffer's expiry time as an absolute time. 


  time_point expiry() const;



[heading Return Value]
      
An absolute time value representing the stream buffer's expiry time. 




[endsect]



[section:operator_eq_ basic_socket_streambuf::operator=]


Move-assign a [link networking_ts.reference.basic_socket_streambuf `basic_socket_streambuf`] from another. 


  basic_socket_streambuf & operator=(
      basic_socket_streambuf && other);



[endsect]



[section:overflow basic_socket_streambuf::overflow]



  int_type overflow(
      int_type c);



[endsect]



[section:protocol_type basic_socket_streambuf::protocol_type]


The protocol type. 


  typedef Protocol protocol_type;




[endsect]



[section:setbuf basic_socket_streambuf::setbuf]



  std::streambuf * setbuf(
      char_type * s,
      std::streamsize n);



[endsect]



[section:socket basic_socket_streambuf::socket]


Get a reference to the underlying socket. 


  basic_socket< Protocol > & socket();



[endsect]



[section:sync basic_socket_streambuf::sync]



  int sync();



[endsect]



[section:time_point basic_socket_streambuf::time_point]


The time type. 


  typedef WaitTraits::time_point time_point;




[endsect]



[section:time_type basic_socket_streambuf::time_type]


(Deprecated: Use time\_point.) The time type. 


  typedef WaitTraits::time_type time_type;




[endsect]



[section:underflow basic_socket_streambuf::underflow]



  int_type underflow();



[endsect]



[section:_basic_socket_streambuf basic_socket_streambuf::~basic_socket_streambuf]


Destructor flushes buffered data. 


  virtual ~basic_socket_streambuf();



[endsect]



[endsect]

[section:basic_stream_socket basic_stream_socket]


Provides stream-oriented socket functionality. 


  template<
      typename Protocol>
  class basic_stream_socket :
    public basic_socket< Protocol >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_stream_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_stream_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.basic_stream_socket [*basic_stream_socket]]]
    [Construct a basic_stream_socket without opening it. 

     Construct and open a basic_stream_socket. 

     Construct a basic_stream_socket, opening it and binding it to the given local endpoint. 

     Construct a basic_stream_socket on an existing native socket. 

     Move-construct a basic_stream_socket from another. 

     Move-construct a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 

     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 

     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_socket from another. 

     Move-assign a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.read_some [*read_some]]]
    [Read some data from the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.receive [*receive]]]
    [Receive some data on the socket. 

     Receive some data on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.write_some [*write_some]]]
    [Write some data to the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket._basic_stream_socket [*~basic_stream_socket]]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_stream_socket.max_listen_connections [*max_listen_connections]]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link networking_ts.reference.basic_stream_socket.message_do_not_route [*message_do_not_route]]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link networking_ts.reference.basic_stream_socket.message_end_of_record [*message_end_of_record]]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link networking_ts.reference.basic_stream_socket.message_out_of_band [*message_out_of_band]]]
    [Process out-of-band data. ]
  ]

  [
    [[link networking_ts.reference.basic_stream_socket.message_peek [*message_peek]]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] class template provides asynchronous and blocking stream-oriented socket functionality.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.




[section:assign basic_stream_socket::assign]


Assign an existing native socket to the socket. 


  void ``[link networking_ts.reference.basic_stream_socket.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.assign.overload1 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.assign.overload2 more...]]``


[section:overload1 basic_stream_socket::assign (1 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket);



[endsect]



[section:overload2 basic_stream_socket::assign (2 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      std::error_code & ec);



[endsect]


[endsect]


[section:async_connect basic_stream_socket::async_connect]


['Inherited from basic_socket.]


Start an asynchronous connect. 


  template<
      typename ConnectHandler>
  DEDUCED async_connect(
      const endpoint_type & peer_endpoint,
      ConnectHandler && handler);


This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.]]

[[handler][The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void connect_handler(const std::error_code& error)
   {
     if (!error)
     {
       // Connect succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::socket socket(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_connect(endpoint, connect_handler);







[endsect]



[section:async_read_some basic_stream_socket::async_read_some]


Start an asynchronous read. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler);


This function is used to asynchronously read data from the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The read operation may not read all of the requested number of bytes. Consider using the `std::experimental::net::async_read`  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Example]
  
To read into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.async_read_some(std::experimental::net::buffer(data, size), handler);


See the `std::experimental::net::buffer`  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]


[section:async_receive basic_stream_socket::async_receive]


Start an asynchronous receive. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.basic_stream_socket.async_receive.overload1 async_receive]``(
      const MutableBufferSequence & buffers,
      ReadHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.async_receive.overload1 more...]]``

  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED ``[link networking_ts.reference.basic_stream_socket.async_receive.overload2 async_receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.async_receive.overload2 more...]]``


[section:overload1 basic_stream_socket::async_receive (1 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED async_receive(
      const MutableBufferSequence & buffers,
      ReadHandler && handler);


This function is used to asynchronously receive data from the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the `std::experimental::net::async_read`  function if you need to ensure that the requested amount of data is received before the asynchronous operation completes.


[heading Example]
  
To receive into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.async_receive(std::experimental::net::buffer(data, size), handler);


See the `std::experimental::net::buffer`  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::async_receive (2 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename MutableBufferSequence,
      typename ReadHandler>
  DEDUCED async_receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler);


This function is used to asynchronously receive data from the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the `std::experimental::net::async_read`  function if you need to ensure that the requested amount of data is received before the asynchronous operation completes.


[heading Example]
  
To receive into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.async_receive(std::experimental::net::buffer(data, size), 0, handler);


See the `std::experimental::net::buffer`  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]


[endsect]

[section:async_send basic_stream_socket::async_send]


Start an asynchronous send. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.basic_stream_socket.async_send.overload1 async_send]``(
      const ConstBufferSequence & buffers,
      WriteHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.async_send.overload1 more...]]``

  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED ``[link networking_ts.reference.basic_stream_socket.async_send.overload2 async_send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.async_send.overload2 more...]]``


[section:overload1 basic_stream_socket::async_send (1 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED async_send(
      const ConstBufferSequence & buffers,
      WriteHandler && handler);


This function is used to asynchronously send data on the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the `std::experimental::net::async_write`  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To send a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.async_send(std::experimental::net::buffer(data, size), handler);


See the `std::experimental::net::buffer`  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::async_send (2 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED async_send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler);


This function is used to asynchronously send data on the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the `std::experimental::net::async_write`  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To send a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.async_send(std::experimental::net::buffer(data, size), 0, handler);


See the `std::experimental::net::buffer`  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]


[endsect]


[section:async_wait basic_stream_socket::async_wait]


['Inherited from basic_socket.]


Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename WaitHandler>
  DEDUCED async_wait(
      wait_type w,
      WaitHandler && handler);


This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Example]
  


   void wait_handler(const std::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   socket.async_wait(std::experimental::net::ip::tcp::socket::wait_read, wait_handler);







[endsect]



[section:async_write_some basic_stream_socket::async_write_some]


Start an asynchronous write. 


  template<
      typename ConstBufferSequence,
      typename WriteHandler>
  DEDUCED async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler);


This function is used to asynchronously write data to the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]


[heading Remarks]
      
The write operation may not transmit all of the data to the peer. Consider using the `std::experimental::net::async_write`  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To write a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.async_write_some(std::experimental::net::buffer(data, size), handler);


See the `std::experimental::net::buffer`  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]


[section:at_mark basic_stream_socket::at_mark]


Determine whether the socket is at the out-of-band data mark. 


  bool ``[link networking_ts.reference.basic_stream_socket.at_mark.overload1 at_mark]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.at_mark.overload1 more...]]``

  bool ``[link networking_ts.reference.basic_stream_socket.at_mark.overload2 at_mark]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.at_mark.overload2 more...]]``


[section:overload1 basic_stream_socket::at_mark (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark() const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_stream_socket::at_mark (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark(
      std::error_code & ec) const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark. 




[endsect]


[endsect]

[section:available basic_stream_socket::available]


Determine the number of bytes available for reading. 


  std::size_t ``[link networking_ts.reference.basic_stream_socket.available.overload1 available]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.available.overload1 more...]]``

  std::size_t ``[link networking_ts.reference.basic_stream_socket.available.overload2 available]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.available.overload2 more...]]``


[section:overload1 basic_stream_socket::available (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available() const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_stream_socket::available (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available(
      std::error_code & ec) const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs. 




[endsect]


[endsect]

[section:basic_stream_socket basic_stream_socket::basic_stream_socket]


Construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] without opening it. 


  explicit ``[link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload1 basic_stream_socket]``(
      std::experimental::net::io_context & io_context);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload1 more...]]``


Construct and open a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`]. 


  ``[link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload2 basic_stream_socket]``(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload2 more...]]``


Construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`], opening it and binding it to the given local endpoint. 


  ``[link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload3 basic_stream_socket]``(
      std::experimental::net::io_context & io_context,
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload3 more...]]``


Construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] on an existing native socket. 


  ``[link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload4 basic_stream_socket]``(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload4 more...]]``


Move-construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] from another. 


  ``[link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload5 basic_stream_socket]``(
      basic_stream_socket && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload5 more...]]``


Move-construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  ``[link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload6 basic_stream_socket]``(
      basic_stream_socket< Protocol1 > && other,
      typename enable_if< is_convertible< Protocol1, Protocol >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.basic_stream_socket.overload6 more...]]``


[section:overload1 basic_stream_socket::basic_stream_socket (1 of 6 overloads)]


Construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] without opening it. 


  basic_stream_socket(
      std::experimental::net::io_context & io_context);


This constructor creates a stream socket without opening it. The socket needs to be opened and then connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the stream socket will use to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload2 basic_stream_socket::basic_stream_socket (2 of 6 overloads)]


Construct and open a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`]. 


  basic_stream_socket(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol);


This constructor creates and opens a stream socket. The socket needs to be connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the stream socket will use to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_stream_socket::basic_stream_socket (3 of 6 overloads)]


Construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`], opening it and binding it to the given local endpoint. 


  basic_stream_socket(
      std::experimental::net::io_context & io_context,
      const endpoint_type & endpoint);


This constructor creates a stream socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the stream socket will use to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the stream socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_stream_socket::basic_stream_socket (4 of 6 overloads)]


Construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] on an existing native socket. 


  basic_stream_socket(
      std::experimental::net::io_context & io_context,
      const protocol_type & protocol,
      const native_handle_type & native_socket);


This constructor creates a stream socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the stream socket will use to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_stream_socket::basic_stream_socket (5 of 6 overloads)]


Move-construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] from another. 


  basic_stream_socket(
      basic_stream_socket && other);


This constructor moves a stream socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_socket(io_context&) constructor`. 




[endsect]



[section:overload6 basic_stream_socket::basic_stream_socket (6 of 6 overloads)]


Move-construct a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  basic_stream_socket(
      basic_stream_socket< Protocol1 > && other,
      typename enable_if< is_convertible< Protocol1, Protocol >::value >::type *  = 0);


This constructor moves a stream socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_socket(io_context&) constructor`. 




[endsect]


[endsect]

[section:bind basic_stream_socket::bind]


Bind the socket to the given local endpoint. 


  void ``[link networking_ts.reference.basic_stream_socket.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.bind.overload1 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.bind.overload2 more...]]``


[section:overload1 basic_stream_socket::bind (1 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   socket.open(std::experimental::net::ip::tcp::v4());
   socket.bind(std::experimental::net::ip::tcp::endpoint(
         std::experimental::net::ip::tcp::v4(), 12345));







[endsect]



[section:overload2 basic_stream_socket::bind (2 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      std::error_code & ec);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   socket.open(std::experimental::net::ip::tcp::v4());
   std::error_code ec;
   socket.bind(std::experimental::net::ip::tcp::endpoint(
         std::experimental::net::ip::tcp::v4(), 12345), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_stream_socket::broadcast]


['Inherited from socket_base.]


Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:bytes_readable basic_stream_socket::bytes_readable]


['Inherited from socket_base.]


IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();








[endsect]


[section:cancel basic_stream_socket::cancel]


Cancel all asynchronous operations associated with the socket. 


  void ``[link networking_ts.reference.basic_stream_socket.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.cancel.overload1 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.cancel.overload2 cancel]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.cancel.overload2 more...]]``


[section:overload1 basic_stream_socket::cancel (1 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with std::experimental::net::error::operation\_not\_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless NET\_TS\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining NET\_TS\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_stream_socket::cancel (2 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel(
      std::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with std::experimental::net::error::operation\_not\_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless NET\_TS\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining NET\_TS\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_stream_socket::close]


Close the socket. 


  void ``[link networking_ts.reference.basic_stream_socket.close.overload1 close]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.close.overload1 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.close.overload2 close]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.close.overload2 more...]]``


[section:overload1 basic_stream_socket::close (1 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close();


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the std::experimental::net::error::operation\_aborted error.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]



[section:overload2 basic_stream_socket::close (2 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close(
      std::error_code & ec);


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the std::experimental::net::error::operation\_aborted error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   socket.close(ec);
   if (ec)
   {
     // An error occurred.
   }





[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]


[endsect]

[section:connect basic_stream_socket::connect]


Connect the socket to the specified endpoint. 


  void ``[link networking_ts.reference.basic_stream_socket.connect.overload1 connect]``(
      const endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.connect.overload1 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.connect.overload2 connect]``(
      const endpoint_type & peer_endpoint,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.connect.overload2 more...]]``


[section:overload1 basic_stream_socket::connect (1 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   socket.connect(endpoint);







[endsect]



[section:overload2 basic_stream_socket::connect (2 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint,
      std::error_code & ec);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(
       std::experimental::net::ip::address::from_string("1.2.3.4"), 12345);
   std::error_code ec;
   socket.connect(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_stream_socket::debug]


['Inherited from socket_base.]


Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:do_not_route basic_stream_socket::do_not_route]


['Inherited from socket_base.]


Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:enable_connection_aborted basic_stream_socket::enable_connection_aborted]


['Inherited from socket_base.]


Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with std::experimental::net::error::connection\_aborted. By default the option is false.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]



[section:endpoint_type basic_stream_socket::endpoint_type]


The endpoint type. 


  typedef Protocol::endpoint endpoint_type;




[endsect]



[section:executor_type basic_stream_socket::executor_type]


['Inherited from basic_socket.]


The type of the executor associated with the object. 


  typedef io_context::executor_type executor_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.defer [*defer]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.dispatch [*dispatch]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_finished [*on_work_finished]]]
    [Inform the io_context that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_started [*on_work_started]]]
    [Inform the io_context that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.post [*post]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the io_context is running in the current thread. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]



[endsect]



[section:get_executor basic_stream_socket::get_executor]


['Inherited from basic_socket.]


Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_stream_socket::get_option]


Get an option from the socket. 


  template<
      typename GettableSocketOption>
  void ``[link networking_ts.reference.basic_stream_socket.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.get_option.overload1 more...]]``

  template<
      typename GettableSocketOption>
  void ``[link networking_ts.reference.basic_stream_socket.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.get_option.overload2 more...]]``


[section:overload1 basic_stream_socket::get_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename GettableSocketOption>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[endsect]



[section:overload2 basic_stream_socket::get_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename GettableSocketOption>
  void get_option(
      GettableSocketOption & option,
      std::error_code & ec) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::keep_alive option;
   std::error_code ec;
   socket.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.value();







[endsect]


[endsect]

[section:io_control basic_stream_socket::io_control]


Perform an IO control command on the socket. 


  template<
      typename IoControlCommand>
  void ``[link networking_ts.reference.basic_stream_socket.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.io_control.overload1 more...]]``

  template<
      typename IoControlCommand>
  void ``[link networking_ts.reference.basic_stream_socket.io_control.overload2 io_control]``(
      IoControlCommand & command,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.io_control.overload2 more...]]``


[section:overload1 basic_stream_socket::io_control (1 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename IoControlCommand>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::bytes_readable command;
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 basic_stream_socket::io_control (2 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename IoControlCommand>
  void io_control(
      IoControlCommand & command,
      std::error_code & ec);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::socket::bytes_readable command;
   std::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open basic_stream_socket::is_open]


['Inherited from basic_socket.]


Determine whether the socket is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_stream_socket::keep_alive]


['Inherited from socket_base.]


Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:linger basic_stream_socket::linger]


['Inherited from socket_base.]


Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();








[endsect]


[section:local_endpoint basic_stream_socket::local_endpoint]


Get the local endpoint of the socket. 


  endpoint_type ``[link networking_ts.reference.basic_stream_socket.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.local_endpoint.overload1 more...]]``

  endpoint_type ``[link networking_ts.reference.basic_stream_socket.local_endpoint.overload2 local_endpoint]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.local_endpoint.overload2 more...]]``


[section:overload1 basic_stream_socket::local_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Return Value]
      
An object that represents the local endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint = socket.local_endpoint();







[endsect]



[section:overload2 basic_stream_socket::local_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint(
      std::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   std::experimental::net::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:max_listen_connections basic_stream_socket::max_listen_connections]


['Inherited from socket_base.]


The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_stream_socket::message_do_not_route]


['Inherited from socket_base.]


Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_stream_socket::message_end_of_record]


['Inherited from socket_base.]


Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_stream_socket::message_flags]


['Inherited from socket_base.]


Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;




[endsect]



[section:message_out_of_band basic_stream_socket::message_out_of_band]


['Inherited from socket_base.]


Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_stream_socket::message_peek]


['Inherited from socket_base.]


Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_stream_socket::native_handle]


['Inherited from basic_socket.]


Get the native socket representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_stream_socket::native_handle_type]


The native representation of a socket. 


  typedef implementation_defined native_handle_type;




[endsect]


[section:native_non_blocking basic_stream_socket::native_non_blocking]


Gets the non-blocking mode of the native socket implementation. 


  bool ``[link networking_ts.reference.basic_stream_socket.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native socket implementation. 


  void ``[link networking_ts.reference.basic_stream_socket.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.native_non_blocking.overload2 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.native_non_blocking.overload3 more...]]``


[section:overload1 basic_stream_socket::native_non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the native socket implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.


[heading Return Value]
      
`true` if the underlying socket is in non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(std::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = std::error_code(n < 0 ? errno : 0,
               std::experimental::net::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == std::experimental::net::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == std::experimental::net::error::would_block
               || ec == std::experimental::net::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload2 basic_stream_socket::native_non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with std::experimental::net::error::invalid\_argument, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(std::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = std::error_code(n < 0 ? errno : 0,
               std::experimental::net::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == std::experimental::net::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == std::experimental::net::error::would_block
               || ec == std::experimental::net::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload3 basic_stream_socket::native_non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode,
      std::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with std::experimental::net::error::would\_block (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with std::experimental::net::error::invalid\_argument, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(std::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = std::error_code(n < 0 ? errno : 0,
               std::experimental::net::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == std::experimental::net::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == std::experimental::net::error::would_block
               || ec == std::experimental::net::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]


[endsect]

[section:non_blocking basic_stream_socket::non_blocking]


Gets the non-blocking mode of the socket. 


  bool ``[link networking_ts.reference.basic_stream_socket.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the socket. 


  void ``[link networking_ts.reference.basic_stream_socket.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.non_blocking.overload2 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.non_blocking.overload3 non_blocking]``(
      bool mode,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.non_blocking.overload3 more...]]``


[section:overload1 basic_stream_socket::non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the socket. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the socket's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]



[section:overload2 basic_stream_socket::non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]



[section:overload3 basic_stream_socket::non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode,
      std::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with std::experimental::net::error::would\_block if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error std::experimental::net::error::would\_block. 




[endsect]


[endsect]

[section:open basic_stream_socket::open]


Open the socket using the specified protocol. 


  void ``[link networking_ts.reference.basic_stream_socket.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.open.overload1 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.open.overload2 open]``(
      const protocol_type & protocol,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.open.overload2 more...]]``


[section:overload1 basic_stream_socket::open (1 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   socket.open(std::experimental::net::ip::tcp::v4());







[endsect]



[section:overload2 basic_stream_socket::open (2 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol,
      std::error_code & ec);


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   std::error_code ec;
   socket.open(std::experimental::net::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_stream_socket::operator=]


Move-assign a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] from another. 


  basic_stream_socket & ``[link networking_ts.reference.basic_stream_socket.operator_eq_.overload1 operator=]``(
      basic_stream_socket && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.operator_eq_.overload1 more...]]``


Move-assign a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  enable_if< is_convertible< Protocol1, Protocol >::value, basic_stream_socket >::type & ``[link networking_ts.reference.basic_stream_socket.operator_eq_.overload2 operator=]``(
      basic_stream_socket< Protocol1 > && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.operator_eq_.overload2 more...]]``


[section:overload1 basic_stream_socket::operator= (1 of 2 overloads)]


Move-assign a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] from another. 


  basic_stream_socket & operator=(
      basic_stream_socket && other);


This assignment operator moves a stream socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_socket(io_context&) constructor`. 




[endsect]



[section:overload2 basic_stream_socket::operator= (2 of 2 overloads)]


Move-assign a [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] from a socket of another protocol type. 


  template<
      typename Protocol1>
  enable_if< is_convertible< Protocol1, Protocol >::value, basic_stream_socket >::type & operator=(
      basic_stream_socket< Protocol1 > && other);


This assignment operator moves a stream socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_socket(io_context&) constructor`. 




[endsect]


[endsect]


[section:out_of_band_inline basic_stream_socket::out_of_band_inline]


['Inherited from socket_base.]


Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();








[endsect]



[section:protocol_type basic_stream_socket::protocol_type]


The protocol type. 


  typedef Protocol protocol_type;




[endsect]


[section:read_some basic_stream_socket::read_some]


Read some data from the socket. 


  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.read_some.overload1 more...]]``

  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.read_some.overload2 more...]]``


[section:overload1 basic_stream_socket::read_some (1 of 2 overloads)]


Read some data from the socket. 


  template<
      typename MutableBufferSequence>
  std::size_t read_some(
      const MutableBufferSequence & buffers);


This function is used to read data from the stream socket. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. An error code of std::experimental::net::error::eof indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the `std::experimental::net::read`  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To read into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.read_some(std::experimental::net::buffer(data, size));


See the `std::experimental::net::buffer`  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::read_some (2 of 2 overloads)]


Read some data from the socket. 


  template<
      typename MutableBufferSequence>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      std::error_code & ec);


This function is used to read data from the stream socket. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the `std::experimental::net::read`  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]

[section:receive basic_stream_socket::receive]


Receive some data on the socket. 


  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.receive.overload1 receive]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.receive.overload1 more...]]``

  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.receive.overload2 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.receive.overload2 more...]]``


Receive some data on a connected socket. 


  template<
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.receive.overload3 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.receive.overload3 more...]]``


[section:overload1 basic_stream_socket::receive (1 of 3 overloads)]


Receive some data on the socket. 


  template<
      typename MutableBufferSequence>
  std::size_t receive(
      const MutableBufferSequence & buffers);


This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. An error code of std::experimental::net::error::eof indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the `std::experimental::net::read`  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To receive into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.receive(std::experimental::net::buffer(data, size));


See the `std::experimental::net::buffer`  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::receive (2 of 3 overloads)]


Receive some data on the socket. 


  template<
      typename MutableBufferSequence>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. An error code of std::experimental::net::error::eof indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the `std::experimental::net::read`  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To receive into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.receive(std::experimental::net::buffer(data, size), 0);


See the `std::experimental::net::buffer`  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload3 basic_stream_socket::receive (3 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename MutableBufferSequence>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      std::error_code & ec);


This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes received. Returns 0 if an error occurred.


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the `std::experimental::net::read`  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]


[section:receive_buffer_size basic_stream_socket::receive_buffer_size]


['Inherited from socket_base.]


Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:receive_low_watermark basic_stream_socket::receive_low_watermark]


['Inherited from socket_base.]


Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]


[section:release basic_stream_socket::release]


Release ownership of the underlying native socket. 


  native_handle_type ``[link networking_ts.reference.basic_stream_socket.release.overload1 release]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.release.overload1 more...]]``

  native_handle_type ``[link networking_ts.reference.basic_stream_socket.release.overload2 release]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.release.overload2 more...]]``


[section:overload1 basic_stream_socket::release (1 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error. Ownership of the native socket is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with std::experimental::net::error::operation\_not\_supported on these platforms. 




[endsect]



[section:overload2 basic_stream_socket::release (2 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release(
      std::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the std::experimental::net::error::operation\_aborted error. Ownership of the native socket is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with std::experimental::net::error::operation\_not\_supported on these platforms. 




[endsect]


[endsect]

[section:remote_endpoint basic_stream_socket::remote_endpoint]


Get the remote endpoint of the socket. 


  endpoint_type ``[link networking_ts.reference.basic_stream_socket.remote_endpoint.overload1 remote_endpoint]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.remote_endpoint.overload1 more...]]``

  endpoint_type ``[link networking_ts.reference.basic_stream_socket.remote_endpoint.overload2 remote_endpoint]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.remote_endpoint.overload2 more...]]``


[section:overload1 basic_stream_socket::remote_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint() const;


This function is used to obtain the remote endpoint of the socket.


[heading Return Value]
      
An object that represents the remote endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::endpoint endpoint = socket.remote_endpoint();







[endsect]



[section:overload2 basic_stream_socket::remote_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint(
      std::error_code & ec) const;


This function is used to obtain the remote endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   std::experimental::net::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:reuse_address basic_stream_socket::reuse_address]


['Inherited from socket_base.]


Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]


[section:send basic_stream_socket::send]


Send some data on the socket. 


  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.send.overload1 send]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.send.overload1 more...]]``

  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.send.overload2 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.send.overload2 more...]]``

  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.send.overload3 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.send.overload3 more...]]``


[section:overload1 basic_stream_socket::send (1 of 3 overloads)]


Send some data on the socket. 


  template<
      typename ConstBufferSequence>
  std::size_t send(
      const ConstBufferSequence & buffers);


This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the `std::experimental::net::write`  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To send a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.send(std::experimental::net::buffer(data, size));


See the `std::experimental::net::buffer`  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::send (2 of 3 overloads)]


Send some data on the socket. 


  template<
      typename ConstBufferSequence>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the `std::experimental::net::write`  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To send a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.send(std::experimental::net::buffer(data, size), 0);


See the `std::experimental::net::buffer`  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload3 basic_stream_socket::send (3 of 3 overloads)]


Send some data on the socket. 


  template<
      typename ConstBufferSequence>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      std::error_code & ec);


This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes sent. Returns 0 if an error occurred.


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the `std::experimental::net::write`  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:send_buffer_size basic_stream_socket::send_buffer_size]


['Inherited from socket_base.]


Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:send_low_watermark basic_stream_socket::send_low_watermark]


['Inherited from socket_base.]


Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]


[section:set_option basic_stream_socket::set_option]


Set an option on the socket. 


  template<
      typename SettableSocketOption>
  void ``[link networking_ts.reference.basic_stream_socket.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.set_option.overload1 more...]]``

  template<
      typename SettableSocketOption>
  void ``[link networking_ts.reference.basic_stream_socket.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.set_option.overload2 more...]]``


[section:overload1 basic_stream_socket::set_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename SettableSocketOption>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::no_delay option(true);
   socket.set_option(option);







[endsect]



[section:overload2 basic_stream_socket::set_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename SettableSocketOption>
  void set_option(
      const SettableSocketOption & option,
      std::error_code & ec);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::ip::tcp::no_delay option(true);
   std::error_code ec;
   socket.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:shutdown basic_stream_socket::shutdown]


Disable sends or receives on the socket. 


  void ``[link networking_ts.reference.basic_stream_socket.shutdown.overload1 shutdown]``(
      shutdown_type what);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.shutdown.overload1 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.shutdown.overload2 shutdown]``(
      shutdown_type what,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.shutdown.overload2 more...]]``


[section:overload1 basic_stream_socket::shutdown (1 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   socket.shutdown(std::experimental::net::ip::tcp::socket::shutdown_send);







[endsect]



[section:overload2 basic_stream_socket::shutdown (2 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what,
      std::error_code & ec);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   socket.shutdown(std::experimental::net::ip::tcp::socket::shutdown_send, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_stream_socket::shutdown_type]


['Inherited from socket_base.]


Different ways a socket may be shutdown. 


  enum shutdown_type


[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_stream_socket::wait]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link networking_ts.reference.basic_stream_socket.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.wait.overload1 more...]]``

  void ``[link networking_ts.reference.basic_stream_socket.wait.overload2 wait]``(
      wait_type w,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.wait.overload2 more...]]``


[section:overload1 basic_stream_socket::wait (1 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   socket.wait(std::experimental::net::ip::tcp::socket::wait_read);







[endsect]



[section:overload2 basic_stream_socket::wait (2 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      std::error_code & ec);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::error_code ec;
   socket.wait(std::experimental::net::ip::tcp::socket::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_stream_socket::wait_type]


['Inherited from socket_base.]


Wait types. 


  enum wait_type


[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]


[section:write_some basic_stream_socket::write_some]


Write some data to the socket. 


  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.write_some.overload1 more...]]``

  template<
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.basic_stream_socket.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_stream_socket.write_some.overload2 more...]]``


[section:overload1 basic_stream_socket::write_some (1 of 2 overloads)]


Write some data to the socket. 


  template<
      typename ConstBufferSequence>
  std::size_t write_some(
      const ConstBufferSequence & buffers);


This function is used to write data to the stream socket. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the socket.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. An error code of std::experimental::net::error::eof indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the `std::experimental::net::write`  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To write a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   socket.write_some(std::experimental::net::buffer(data, size));


See the `std::experimental::net::buffer`  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::write_some (2 of 2 overloads)]


Write some data to the socket. 


  template<
      typename ConstBufferSequence>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      std::error_code & ec);


This function is used to write data to the stream socket. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the `std::experimental::net::write`  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:_basic_stream_socket basic_stream_socket::~basic_stream_socket]


Destroys the socket. 


  ~basic_stream_socket();


This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_waitable_timer basic_waitable_timer]


Provides waitable timer functionality. 


  template<
      typename Clock,
      typename WaitTraits>
  class basic_waitable_timer


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_waitable_timer.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.duration [*duration]]]
    [The duration type of the clock. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.time_point [*time_point]]]
    [The time point type of the clock. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.traits_type [*traits_type]]]
    [The wait traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_waitable_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.basic_waitable_timer [*basic_waitable_timer]]]
    [Constructor. 

     Constructor to set a particular expiry time as an absolute time. 

     Constructor to set a particular expiry time relative to now. 

     Move-construct a basic_waitable_timer from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expires_after [*expires_after]]]
    [Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expires_at [*expires_at]]]
    [Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expiry [*expiry]]]
    [Get the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_waitable_timer from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer._basic_waitable_timer [*~basic_waitable_timer]]]
    [Destroys the timer. ]
  ]
  
]

The [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the std::experimental::net::steady\_timer, std::experimental::net::system\_timer or std::experimental::net::high\_resolution\_timer typedefs.


[heading Remarks]
      
This waitable timer functionality is for use with the C++11 standard library's `<chrono>` facility, or with the Boost.Chrono library.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait (C++11): 

   // Construct a timer without setting an expiry time.
   std::experimental::net::steady_timer timer(io_context);

   // Set an expiry time relative to now.
   timer.expires_after(std::chrono::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait (C++11): 

   void handler(const std::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   std::experimental::net::steady_timer timer(io_context,
       std::chrono::steady_clock::now() + std::chrono::seconds(60));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active waitable timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_after(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const std::error_code& e)
   {
     if (e != std::experimental::net::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The std::experimental::net::basic\_waitable\_timer::expires\_after() function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the std::error\_code passed to it contains the value std::experimental::net::error::operation\_aborted. 




[section:async_wait basic_waitable_timer::async_wait]


Start an asynchronous wait on the timer. 


  template<
      typename WaitHandler>
  DEDUCED async_wait(
      WaitHandler && handler);


This function may be used to initiate an asynchronous wait against the timer. It always returns immediately.

For each call to `async_wait()`, the supplied handler will be called exactly once. The handler will be called when:


* The timer has expired.


* The timer was cancelled, in which case the handler is passed the error code std::experimental::net::error::operation\_aborted.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called when the timer expires. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error // Result of operation.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`. ]]

]




[endsect]


[section:basic_waitable_timer basic_waitable_timer::basic_waitable_timer]


Constructor. 


  explicit ``[link networking_ts.reference.basic_waitable_timer.basic_waitable_timer.overload1 basic_waitable_timer]``(
      std::experimental::net::io_context & io_context);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_waitable_timer.basic_waitable_timer.overload1 more...]]``


Constructor to set a particular expiry time as an absolute time. 


  ``[link networking_ts.reference.basic_waitable_timer.basic_waitable_timer.overload2 basic_waitable_timer]``(
      std::experimental::net::io_context & io_context,
      const time_point & expiry_time);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_waitable_timer.basic_waitable_timer.overload2 more...]]``


Constructor to set a particular expiry time relative to now. 


  ``[link networking_ts.reference.basic_waitable_timer.basic_waitable_timer.overload3 basic_waitable_timer]``(
      std::experimental::net::io_context & io_context,
      const duration & expiry_time);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_waitable_timer.basic_waitable_timer.overload3 more...]]``


Move-construct a [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] from another. 


  ``[link networking_ts.reference.basic_waitable_timer.basic_waitable_timer.overload4 basic_waitable_timer]``(
      basic_waitable_timer && other);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_waitable_timer.basic_waitable_timer.overload4 more...]]``


[section:overload1 basic_waitable_timer::basic_waitable_timer (1 of 4 overloads)]


Constructor. 


  basic_waitable_timer(
      std::experimental::net::io_context & io_context);


This constructor creates a timer without setting an expiry time. The `expires_at()` or `expires_after()` functions must be called to set an expiry time before the timer can be waited on.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the timer will use to dispatch handlers for any asynchronous operations performed on the timer. ]]

]




[endsect]



[section:overload2 basic_waitable_timer::basic_waitable_timer (2 of 4 overloads)]


Constructor to set a particular expiry time as an absolute time. 


  basic_waitable_timer(
      std::experimental::net::io_context & io_context,
      const time_point & expiry_time);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the timer will use to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, expressed as an absolute time. ]]

]




[endsect]



[section:overload3 basic_waitable_timer::basic_waitable_timer (3 of 4 overloads)]


Constructor to set a particular expiry time relative to now. 


  basic_waitable_timer(
      std::experimental::net::io_context & io_context,
      const duration & expiry_time);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the timer will use to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, relative to now. ]]

]




[endsect]



[section:overload4 basic_waitable_timer::basic_waitable_timer (4 of 4 overloads)]


Move-construct a [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] from another. 


  basic_waitable_timer(
      basic_waitable_timer && other);


This constructor moves a timer from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_waitable_timer(io_context&) constructor`. 




[endsect]


[endsect]


[section:cancel basic_waitable_timer::cancel]


Cancel any asynchronous operations that are waiting on the timer. 


  std::size_t cancel();


This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the std::experimental::net::error::operation\_aborted error code.

Cancelling the timer does not change the expiry time.


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `cancel()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:cancel_one basic_waitable_timer::cancel_one]


Cancels one asynchronous operation that is waiting on the timer. 


  std::size_t cancel_one();


This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in FIFO order. The handler for the cancelled operation will be invoked with the std::experimental::net::error::operation\_aborted error code.

Cancelling the timer does not change the expiry time.


[heading Return Value]
      
The number of asynchronous operations that were cancelled. That is, either 0 or 1.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `cancel_one()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:clock_type basic_waitable_timer::clock_type]


The clock type. 


  typedef Clock clock_type;




[endsect]



[section:duration basic_waitable_timer::duration]


The duration type of the clock. 


  typedef clock_type::duration duration;




[endsect]



[section:executor_type basic_waitable_timer::executor_type]


The type of the executor associated with the object. 


  typedef io_context::executor_type executor_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.defer [*defer]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.dispatch [*dispatch]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_finished [*on_work_finished]]]
    [Inform the io_context that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_started [*on_work_started]]]
    [Inform the io_context that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.post [*post]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the io_context is running in the current thread. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]



[endsect]



[section:expires_after basic_waitable_timer::expires_after]


Set the timer's expiry time relative to now. 


  std::size_t expires_after(
      const duration & expiry_time);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the std::experimental::net::error::operation\_aborted error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `expires_after()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:expires_at basic_waitable_timer::expires_at]


Set the timer's expiry time as an absolute time. 


  std::size_t expires_at(
      const time_point & expiry_time);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the std::experimental::net::error::operation\_aborted error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `expires_at()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:expiry basic_waitable_timer::expiry]


Get the timer's expiry time as an absolute time. 


  time_point expiry() const;


This function may be used to obtain the timer's current expiry time. Whether the timer has expired or not does not affect this value. 


[endsect]



[section:get_executor basic_waitable_timer::get_executor]


Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:operator_eq_ basic_waitable_timer::operator=]


Move-assign a [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] from another. 


  basic_waitable_timer & operator=(
      basic_waitable_timer && other);


This assignment operator moves a timer from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_waitable_timer(io_context&) constructor`. 




[endsect]



[section:time_point basic_waitable_timer::time_point]


The time point type of the clock. 


  typedef clock_type::time_point time_point;




[endsect]



[section:traits_type basic_waitable_timer::traits_type]


The wait traits type. 


  typedef WaitTraits traits_type;




[endsect]


[section:wait basic_waitable_timer::wait]


Perform a blocking wait on the timer. 


  void ``[link networking_ts.reference.basic_waitable_timer.wait.overload1 wait]``();
  ``  [''''&raquo;''' [link networking_ts.reference.basic_waitable_timer.wait.overload1 more...]]``

  void ``[link networking_ts.reference.basic_waitable_timer.wait.overload2 wait]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.basic_waitable_timer.wait.overload2 more...]]``


[section:overload1 basic_waitable_timer::wait (1 of 2 overloads)]


Perform a blocking wait on the timer. 


  void wait();


This function is used to wait for the timer to expire. This function blocks and does not return until the timer has expired.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_waitable_timer::wait (2 of 2 overloads)]


Perform a blocking wait on the timer. 


  void wait(
      std::error_code & ec);


This function is used to wait for the timer to expire. This function blocks and does not return until the timer has expired.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:_basic_waitable_timer basic_waitable_timer::~basic_waitable_timer]


Destroys the timer. 


  ~basic_waitable_timer();


This function destroys the timer, cancelling any outstanding asynchronous wait operations associated with the timer as if by calling `cancel`. 


[endsect]



[endsect]

[section:bind_executor bind_executor]


Associate an object of type `T` with an executor of type `Executor`. 

    
  template<
      typename Executor,
      typename T>
  executor_binder< typename decay< T >::type, Executor > ``[link networking_ts.reference.bind_executor.overload1 bind_executor]``(
      const Executor & ex,
      T && t,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.bind_executor.overload1 more...]]``

  template<
      typename ExecutionContext,
      typename T>
  executor_binder< typename decay< T >::type, typename ExecutionContext::executor_type > ``[link networking_ts.reference.bind_executor.overload2 bind_executor]``(
      ExecutionContext & ctx,
      T && t,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.bind_executor.overload2 more...]]``


[section:overload1 bind_executor (1 of 2 overloads)]


Associate an object of type `T` with an executor of type `Executor`. 


  template<
      typename Executor,
      typename T>
  executor_binder< typename decay< T >::type, Executor > bind_executor(
      const Executor & ex,
      T && t,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);



[endsect]



[section:overload2 bind_executor (2 of 2 overloads)]


Associate an object of type `T` with an execution context's executor. 


  template<
      typename ExecutionContext,
      typename T>
  executor_binder< typename decay< T >::type, typename ExecutionContext::executor_type > bind_executor(
      ExecutionContext & ctx,
      T && t,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);



[endsect]


[endsect]

[section:buffer buffer]


The std::experimental::net::buffer function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string. 

      
  mutable_buffer ``[link networking_ts.reference.buffer.overload1 buffer]``(
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload1 more...]]``

  mutable_buffer ``[link networking_ts.reference.buffer.overload2 buffer]``(
      const mutable_buffer & b,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload2 more...]]``

  const_buffer ``[link networking_ts.reference.buffer.overload3 buffer]``(
      const const_buffer & b);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload3 more...]]``

  const_buffer ``[link networking_ts.reference.buffer.overload4 buffer]``(
      const const_buffer & b,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload4 more...]]``

  mutable_buffer ``[link networking_ts.reference.buffer.overload5 buffer]``(
      void * data,
      std::size_t size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload5 more...]]``

  const_buffer ``[link networking_ts.reference.buffer.overload6 buffer]``(
      const void * data,
      std::size_t size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload6 more...]]``

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link networking_ts.reference.buffer.overload7 buffer]``(
      PodType (&data)[N]);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload7 more...]]``

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link networking_ts.reference.buffer.overload8 buffer]``(
      PodType (&data)[N],
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload8 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload9 buffer]``(
      const PodType (&data)[N]);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload9 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload10 buffer]``(
      const PodType (&data)[N],
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload10 more...]]``

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link networking_ts.reference.buffer.overload11 buffer]``(
      boost::array< PodType, N > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload11 more...]]``

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link networking_ts.reference.buffer.overload12 buffer]``(
      boost::array< PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload12 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload13 buffer]``(
      boost::array< const PodType, N > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload13 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload14 buffer]``(
      boost::array< const PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload14 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload15 buffer]``(
      const boost::array< PodType, N > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload15 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload16 buffer]``(
      const boost::array< PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload16 more...]]``

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link networking_ts.reference.buffer.overload17 buffer]``(
      std::array< PodType, N > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload17 more...]]``

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link networking_ts.reference.buffer.overload18 buffer]``(
      std::array< PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload18 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload19 buffer]``(
      std::array< const PodType, N > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload19 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload20 buffer]``(
      std::array< const PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload20 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload21 buffer]``(
      const std::array< PodType, N > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload21 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link networking_ts.reference.buffer.overload22 buffer]``(
      const std::array< PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload22 more...]]``

  template<
      typename PodType,
      typename Allocator>
  mutable_buffer ``[link networking_ts.reference.buffer.overload23 buffer]``(
      std::vector< PodType, Allocator > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload23 more...]]``

  template<
      typename PodType,
      typename Allocator>
  mutable_buffer ``[link networking_ts.reference.buffer.overload24 buffer]``(
      std::vector< PodType, Allocator > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload24 more...]]``

  template<
      typename PodType,
      typename Allocator>
  const_buffer ``[link networking_ts.reference.buffer.overload25 buffer]``(
      const std::vector< PodType, Allocator > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload25 more...]]``

  template<
      typename PodType,
      typename Allocator>
  const_buffer ``[link networking_ts.reference.buffer.overload26 buffer]``(
      const std::vector< PodType, Allocator > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload26 more...]]``

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  mutable_buffer ``[link networking_ts.reference.buffer.overload27 buffer]``(
      std::basic_string< Elem, Traits, Allocator > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload27 more...]]``

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  mutable_buffer ``[link networking_ts.reference.buffer.overload28 buffer]``(
      std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload28 more...]]``

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  const_buffer ``[link networking_ts.reference.buffer.overload29 buffer]``(
      const std::basic_string< Elem, Traits, Allocator > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload29 more...]]``

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  const_buffer ``[link networking_ts.reference.buffer.overload30 buffer]``(
      const std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload30 more...]]``

  template<
      typename Elem,
      typename Traits>
  const_buffer ``[link networking_ts.reference.buffer.overload31 buffer]``(
      basic_string_view< Elem, Traits > data);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload31 more...]]``

  template<
      typename Elem,
      typename Traits>
  const_buffer ``[link networking_ts.reference.buffer.overload32 buffer]``(
      basic_string_view< Elem, Traits > data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer.overload32 more...]]``

A buffer object represents a contiguous region of memory as a 2-tuple consisting of a pointer and size in bytes. A tuple of the form `{void*, size_t}` specifies a mutable (modifiable) region of memory. Similarly, a tuple of the form `{const void*, size_t}` specifies a const (non-modifiable) region of memory. These two forms correspond to the classes [link networking_ts.reference.mutable_buffer `mutable_buffer`] and [link networking_ts.reference.const_buffer `const_buffer`], respectively. To mirror C++'s conversion rules, a [link networking_ts.reference.mutable_buffer `mutable_buffer`] is implicitly convertible to a [link networking_ts.reference.const_buffer `const_buffer`], and the opposite conversion is not permitted.

The simplest use case involves reading or writing a single buffer of a specified size:



   sock.send(std::experimental::net::buffer(data, size)); 




In the above example, the return value of std::experimental::net::buffer meets the requirements of the ConstBufferSequence concept so that it may be directly passed to the socket's write function. A buffer created for modifiable memory also meets the requirements of the MutableBufferSequence concept.

An individual buffer may be created from a builtin array, std::vector, std::array or boost::array of POD elements. This helps prevent buffer overruns by automatically determining the size of the buffer:



   char d1[128];
   size_t bytes_transferred = sock.receive(std::experimental::net::buffer(d1));

   std::vector<char> d2(128);
   bytes_transferred = sock.receive(std::experimental::net::buffer(d2));

   std::array<char, 128> d3;
   bytes_transferred = sock.receive(std::experimental::net::buffer(d3));

   boost::array<char, 128> d4;
   bytes_transferred = sock.receive(std::experimental::net::buffer(d4)); 




In all three cases above, the buffers created are exactly 128 bytes long. Note that a vector is [*never] automatically resized when creating or using a buffer. The buffer size is determined using the vector's `size()` member function, and not its capacity.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   std::experimental::net::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());

   std::experimental::net::const_buffer b2 = ...;
   std::size_t s2 = b2.size();
   const void* p2 = b2.data(); 




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered.

For convenience, a `buffer_size`  function is provided that works with both buffers and buffer sequences (that is, types meeting the ConstBufferSequence or MutableBufferSequence type requirements). In this case, the function returns the total size of all buffers in the sequence.


[heading Buffer Copying]
  


The `std::experimental::net::buffer_copy`  function may be used to copy raw bytes between individual buffers and buffer sequences.

In particular, when used with the `buffer_size`  function, the `std::experimental::net::buffer_copy`  function can be used to linearise a sequence of buffers. For example:



   vector<const_buffer> buffers = ...;

   vector<unsigned char> data(std::experimental::net::buffer_size(buffers));
   std::experimental::net::buffer_copy(std::experimental::net::buffer(data), buffers); 




Note that `std::experimental::net::buffer_copy`  is implemented in terms of `memcpy`, and consequently it cannot be used to copy between overlapping memory regions.


[heading Buffer Invalidation]
  


A buffer object does not have any ownership of the memory it refers to. It is the responsibility of the application to ensure the memory region remains valid until it is no longer required for an I/O operation. When the memory is no longer available, the buffer is said to have been invalidated.

For the std::experimental::net::buffer overloads that accept an argument of type std::vector, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++ Std, 23.2.4)

For the std::experimental::net::buffer overloads that accept an argument of type std::basic\_string, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++ Std, 21.3).


[heading Buffer Arithmetic]
  


Buffer objects may be manipulated using simple arithmetic in a safe way which helps prevent buffer overruns. Consider an array initialised as follows:



   boost::array<char, 6> a = { 'a', 'b', 'c', 'd', 'e' }; 




A buffer object `b1` created using:



   b1 = std::experimental::net::buffer(a); 




represents the entire array, `{ 'a', 'b', 'c', 'd', 'e' }`. An optional second argument to the std::experimental::net::buffer function may be used to limit the size, in bytes, of the buffer:



   b2 = std::experimental::net::buffer(a, 3); 




such that `b2` represents the data `{ 'a', 'b', 'c' }`. Even if the size argument exceeds the actual size of the array, the size of the buffer object created will be limited to the array size.

An offset may be applied to an existing buffer to create a new one:



   b3 = b1 + 2; 




where `b3` will set to represent `{ 'c', 'd', 'e' }`. If the offset exceeds the size of the existing buffer, the newly created buffer will be empty.

Both an offset and size may be specified to create a buffer that corresponds to a specific range of bytes within an existing buffer:



   b4 = std::experimental::net::buffer(b1 + 1, 3); 




so that `b4` will refer to the bytes `{ 'b', 'c', 'd' }`.


[heading Buffers and Scatter-Gather I/O]
  


To read or write using multiple buffers (i.e. scatter-gather I/O), multiple buffer objects may be assigned into a container that supports the MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:



   char d1[128];
   std::vector<char> d2(128);
   boost::array<char, 128> d3;

   boost::array<mutable_buffer, 3> bufs1 = {
     std::experimental::net::buffer(d1),
     std::experimental::net::buffer(d2),
     std::experimental::net::buffer(d3) };
   bytes_transferred = sock.receive(bufs1);

   std::vector<const_buffer> bufs2;
   bufs2.push_back(std::experimental::net::buffer(d1));
   bufs2.push_back(std::experimental::net::buffer(d2));
   bufs2.push_back(std::experimental::net::buffer(d3));
   bytes_transferred = sock.send(bufs2); 





[section:overload1 buffer (1 of 32 overloads)]


Create a new modifiable buffer from an existing buffer. 


  mutable_buffer buffer(
      const mutable_buffer & b);



[heading Return Value]
      
`mutable_buffer(b)`. 




[endsect]



[section:overload2 buffer (2 of 32 overloads)]


Create a new modifiable buffer from an existing buffer. 


  mutable_buffer buffer(
      const mutable_buffer & b,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       b.data(),
       min(b.size(), max_size_in_bytes)); 







[endsect]



[section:overload3 buffer (3 of 32 overloads)]


Create a new non-modifiable buffer from an existing buffer. 


  const_buffer buffer(
      const const_buffer & b);



[heading Return Value]
      
`const_buffer(b)`. 




[endsect]



[section:overload4 buffer (4 of 32 overloads)]


Create a new non-modifiable buffer from an existing buffer. 


  const_buffer buffer(
      const const_buffer & b,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       b.data(),
       min(b.size(), max_size_in_bytes)); 







[endsect]



[section:overload5 buffer (5 of 32 overloads)]


Create a new modifiable buffer that represents the given memory range. 


  mutable_buffer buffer(
      void * data,
      std::size_t size_in_bytes);



[heading Return Value]
      
`mutable_buffer(data, size_in_bytes)`. 




[endsect]



[section:overload6 buffer (6 of 32 overloads)]


Create a new non-modifiable buffer that represents the given memory range. 


  const_buffer buffer(
      const void * data,
      std::size_t size_in_bytes);



[heading Return Value]
      
`const_buffer(data, size_in_bytes)`. 




[endsect]



[section:overload7 buffer (7 of 32 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      PodType (&data)[N]);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       static_cast<void*>(data),
       N * sizeof(PodType)); 







[endsect]



[section:overload8 buffer (8 of 32 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      PodType (&data)[N],
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       static_cast<void*>(data),
       min(N * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload9 buffer (9 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const PodType (&data)[N]);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       static_cast<const void*>(data),
       N * sizeof(PodType)); 







[endsect]



[section:overload10 buffer (10 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const PodType (&data)[N],
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       static_cast<const void*>(data),
       min(N * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload11 buffer (11 of 32 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      boost::array< PodType, N > & data);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload12 buffer (12 of 32 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      boost::array< PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload13 buffer (13 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      boost::array< const PodType, N > & data);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload14 buffer (14 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      boost::array< const PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload15 buffer (15 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const boost::array< PodType, N > & data);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload16 buffer (16 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const boost::array< PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload17 buffer (17 of 32 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      std::array< PodType, N > & data);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload18 buffer (18 of 32 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      std::array< PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload19 buffer (19 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      std::array< const PodType, N > & data);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload20 buffer (20 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      std::array< const PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload21 buffer (21 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const std::array< PodType, N > & data);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload22 buffer (22 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const std::array< PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload23 buffer (23 of 32 overloads)]


Create a new modifiable buffer that represents the given POD vector. 


  template<
      typename PodType,
      typename Allocator>
  mutable_buffer buffer(
      std::vector< PodType, Allocator > & data);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.size() ? &data[0] : 0,
       data.size() * sizeof(PodType)); 





[heading Remarks]
      
The buffer is invalidated by any vector operation that would also invalidate iterators. 




[endsect]



[section:overload24 buffer (24 of 32 overloads)]


Create a new modifiable buffer that represents the given POD vector. 


  template<
      typename PodType,
      typename Allocator>
  mutable_buffer buffer(
      std::vector< PodType, Allocator > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.size() ? &data[0] : 0,
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 





[heading Remarks]
      
The buffer is invalidated by any vector operation that would also invalidate iterators. 




[endsect]



[section:overload25 buffer (25 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD vector. 


  template<
      typename PodType,
      typename Allocator>
  const_buffer buffer(
      const std::vector< PodType, Allocator > & data);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.size() ? &data[0] : 0,
       data.size() * sizeof(PodType)); 





[heading Remarks]
      
The buffer is invalidated by any vector operation that would also invalidate iterators. 




[endsect]



[section:overload26 buffer (26 of 32 overloads)]


Create a new non-modifiable buffer that represents the given POD vector. 


  template<
      typename PodType,
      typename Allocator>
  const_buffer buffer(
      const std::vector< PodType, Allocator > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.size() ? &data[0] : 0,
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 





[heading Remarks]
      
The buffer is invalidated by any vector operation that would also invalidate iterators. 




[endsect]



[section:overload27 buffer (27 of 32 overloads)]


Create a new modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  mutable_buffer buffer(
      std::basic_string< Elem, Traits, Allocator > & data);



[heading Return Value]
      
`mutable_buffer(data.size() ? &data[0] : 0, data.size() * sizeof(Elem))`.


[heading Remarks]
      
The buffer is invalidated by any non-const operation called on the given string object. 




[endsect]



[section:overload28 buffer (28 of 32 overloads)]


Create a new non-modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  mutable_buffer buffer(
      std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.size() ? &data[0] : 0,
       min(data.size() * sizeof(Elem), max_size_in_bytes)); 





[heading Remarks]
      
The buffer is invalidated by any non-const operation called on the given string object. 




[endsect]



[section:overload29 buffer (29 of 32 overloads)]


Create a new non-modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  const_buffer buffer(
      const std::basic_string< Elem, Traits, Allocator > & data);



[heading Return Value]
      
`const_buffer(data.data(), data.size() * sizeof(Elem))`.


[heading Remarks]
      
The buffer is invalidated by any non-const operation called on the given string object. 




[endsect]



[section:overload30 buffer (30 of 32 overloads)]


Create a new non-modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  const_buffer buffer(
      const std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(Elem), max_size_in_bytes)); 





[heading Remarks]
      
The buffer is invalidated by any non-const operation called on the given string object. 




[endsect]



[section:overload31 buffer (31 of 32 overloads)]


Create a new modifiable buffer that represents the given string\_view. 


  template<
      typename Elem,
      typename Traits>
  const_buffer buffer(
      basic_string_view< Elem, Traits > data);



[heading Return Value]
      
`mutable_buffer(data.size() ? &data[0] : 0, data.size() * sizeof(Elem))`. 




[endsect]



[section:overload32 buffer (32 of 32 overloads)]


Create a new non-modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits>
  const_buffer buffer(
      basic_string_view< Elem, Traits > data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link networking_ts.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.size() ? &data[0] : 0,
       min(data.size() * sizeof(Elem), max_size_in_bytes)); 







[endsect]


[endsect]

[section:buffer_copy buffer_copy]


The std::experimental::net::buffer\_copy function is used to copy bytes from a source buffer (or buffer sequence) to a target buffer (or buffer sequence). 

      
  template<
      typename MutableBufferSequence,
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.buffer_copy.overload1 buffer_copy]``(
      const MutableBufferSequence & target,
      const ConstBufferSequence & source);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_copy.overload1 more...]]``

  template<
      typename MutableBufferSequence,
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.buffer_copy.overload2 buffer_copy]``(
      const MutableBufferSequence & target,
      const ConstBufferSequence & source,
      std::size_t max_bytes_to_copy);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_copy.overload2 more...]]``

The `buffer_copy` function is available in two forms:


* A 2-argument form: `buffer_copy(target, source)` 


* A 3-argument form: `buffer_copy(target, source, max_bytes_to_copy)` 

Both forms return the number of bytes actually copied. The number of bytes copied is the lesser of:


* `buffer_size(target)` 


* `buffer_size(source)` 


* `If` specified, `max_bytes_to_copy`.

This prevents buffer overflow, regardless of the buffer sizes used in the copy operation.

Note that `std::experimental::net::buffer_copy`  is implemented in terms of `memcpy`, and consequently it cannot be used to copy between overlapping memory regions. 


[section:overload1 buffer_copy (1 of 2 overloads)]


Copies bytes from a source buffer sequence to a target buffer sequence. 


  template<
      typename MutableBufferSequence,
      typename ConstBufferSequence>
  std::size_t buffer_copy(
      const MutableBufferSequence & target,
      const ConstBufferSequence & source);



[heading Parameters]
    

[variablelist
  
[[target][A modifiable buffer sequence representing the memory regions to which the bytes will be copied.]]

[[source][A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.]]

]


[heading Return Value]
      
The number of bytes copied.


[heading Remarks]
      
The number of bytes copied is the lesser of:


* `buffer_size(target)` 


* `buffer_size(source)` 

This function is implemented in terms of `memcpy`, and consequently it cannot be used to copy between overlapping memory regions. 


[endsect]



[section:overload2 buffer_copy (2 of 2 overloads)]


Copies a limited number of bytes from a source buffer sequence to a target buffer sequence. 


  template<
      typename MutableBufferSequence,
      typename ConstBufferSequence>
  std::size_t buffer_copy(
      const MutableBufferSequence & target,
      const ConstBufferSequence & source,
      std::size_t max_bytes_to_copy);



[heading Parameters]
    

[variablelist
  
[[target][A modifiable buffer sequence representing the memory regions to which the bytes will be copied.]]

[[source][A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.]]

[[max_bytes_to_copy][The maximum number of bytes to be copied.]]

]


[heading Return Value]
      
The number of bytes copied.


[heading Remarks]
      
The number of bytes copied is the lesser of:


* `buffer_size(target)` 


* `buffer_size(source)` 


* `max_bytes_to_copy` 

This function is implemented in terms of `memcpy`, and consequently it cannot be used to copy between overlapping memory regions. 


[endsect]


[endsect]

[section:buffer_sequence_begin buffer_sequence_begin]


The std::experimental::net::buffer\_sequence\_begin function returns an iterator pointing to the first element in a buffer sequence. 

      
  const mutable_buffer * ``[link networking_ts.reference.buffer_sequence_begin.overload1 buffer_sequence_begin]``(
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_sequence_begin.overload1 more...]]``

  const const_buffer * ``[link networking_ts.reference.buffer_sequence_begin.overload2 buffer_sequence_begin]``(
      const const_buffer & b);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_sequence_begin.overload2 more...]]``

  template<
      typename C>
  auto ``[link networking_ts.reference.buffer_sequence_begin.overload3 buffer_sequence_begin]``(
      C & c);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_sequence_begin.overload3 more...]]``

  template<
      typename C>
  auto ``[link networking_ts.reference.buffer_sequence_begin.overload4 buffer_sequence_begin]``(
      const C & c);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_sequence_begin.overload4 more...]]``


[section:overload1 buffer_sequence_begin (1 of 4 overloads)]


Get an iterator to the first element in a buffer sequence. 


  const mutable_buffer * buffer_sequence_begin(
      const mutable_buffer & b);



[endsect]



[section:overload2 buffer_sequence_begin (2 of 4 overloads)]


Get an iterator to the first element in a buffer sequence. 


  const const_buffer * buffer_sequence_begin(
      const const_buffer & b);



[endsect]



[section:overload3 buffer_sequence_begin (3 of 4 overloads)]


Get an iterator to the first element in a buffer sequence. 


  template<
      typename C>
  auto buffer_sequence_begin(
      C & c);



[endsect]



[section:overload4 buffer_sequence_begin (4 of 4 overloads)]


Get an iterator to the first element in a buffer sequence. 


  template<
      typename C>
  auto buffer_sequence_begin(
      const C & c);



[endsect]


[endsect]

[section:buffer_sequence_end buffer_sequence_end]


The std::experimental::net::buffer\_sequence\_end function returns an iterator pointing to one past the end element in a buffer sequence. 

      
  const mutable_buffer * ``[link networking_ts.reference.buffer_sequence_end.overload1 buffer_sequence_end]``(
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_sequence_end.overload1 more...]]``

  const const_buffer * ``[link networking_ts.reference.buffer_sequence_end.overload2 buffer_sequence_end]``(
      const const_buffer & b);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_sequence_end.overload2 more...]]``

  template<
      typename C>
  auto ``[link networking_ts.reference.buffer_sequence_end.overload3 buffer_sequence_end]``(
      C & c);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_sequence_end.overload3 more...]]``

  template<
      typename C>
  auto ``[link networking_ts.reference.buffer_sequence_end.overload4 buffer_sequence_end]``(
      const C & c);
  ``  [''''&raquo;''' [link networking_ts.reference.buffer_sequence_end.overload4 more...]]``


[section:overload1 buffer_sequence_end (1 of 4 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  const mutable_buffer * buffer_sequence_end(
      const mutable_buffer & b);



[endsect]



[section:overload2 buffer_sequence_end (2 of 4 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  const const_buffer * buffer_sequence_end(
      const const_buffer & b);



[endsect]



[section:overload3 buffer_sequence_end (3 of 4 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  template<
      typename C>
  auto buffer_sequence_end(
      C & c);



[endsect]



[section:overload4 buffer_sequence_end (4 of 4 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  template<
      typename C>
  auto buffer_sequence_end(
      const C & c);



[endsect]


[endsect]


[section:buffer_size buffer_size]


Get the total number of bytes in a buffer sequence. 


  template<
      typename BufferSequence>
  std::size_t buffer_size(
      const BufferSequence & b);


The `buffer_size` function determines the total size of all buffers in the buffer sequence, as if computed as follows:



   size_t total_size = 0;
   auto i = std::experimental::net::buffer_sequence_begin(buffers);
   auto end = std::experimental::net::buffer_sequence_end(buffers);
   for (; i != end; ++i)
   {
     const_buffer b(*i);
     total_size += b.size();
   }
   return total_size; 




The `BufferSequence` template parameter may meet either of the `ConstBufferSequence` or `MutableBufferSequence` type requirements. 


[endsect]


[section:connect connect]


Establishes a socket connection by trying each endpoint in a sequence. 

      
  template<
      typename Protocol,
      typename EndpointSequence>
  Protocol::endpoint ``[link networking_ts.reference.connect.overload1 connect]``(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.connect.overload1 more...]]``

  template<
      typename Protocol,
      typename EndpointSequence>
  Protocol::endpoint ``[link networking_ts.reference.connect.overload2 connect]``(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      std::error_code & ec,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.connect.overload2 more...]]``

  template<
      typename Protocol,
      typename Iterator>
  Iterator ``[link networking_ts.reference.connect.overload3 connect]``(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end);
  ``  [''''&raquo;''' [link networking_ts.reference.connect.overload3 more...]]``

  template<
      typename Protocol,
      typename Iterator>
  Iterator ``[link networking_ts.reference.connect.overload4 connect]``(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.connect.overload4 more...]]``

  template<
      typename Protocol,
      typename EndpointSequence,
      typename ConnectCondition>
  Protocol::endpoint ``[link networking_ts.reference.connect.overload5 connect]``(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.connect.overload5 more...]]``

  template<
      typename Protocol,
      typename EndpointSequence,
      typename ConnectCondition>
  Protocol::endpoint ``[link networking_ts.reference.connect.overload6 connect]``(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      std::error_code & ec,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.connect.overload6 more...]]``

  template<
      typename Protocol,
      typename Iterator,
      typename ConnectCondition>
  Iterator ``[link networking_ts.reference.connect.overload7 connect]``(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition);
  ``  [''''&raquo;''' [link networking_ts.reference.connect.overload7 more...]]``

  template<
      typename Protocol,
      typename Iterator,
      typename ConnectCondition>
  Iterator ``[link networking_ts.reference.connect.overload8 connect]``(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.connect.overload8 more...]]``


[section:overload1 connect (1 of 8 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename EndpointSequence>
  Protocol::endpoint connect(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

]


[heading Return Value]
      
The successfully connected endpoint.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is std::experimental::net::error::not\_found. Otherwise, contains the error from the last connection attempt.]]

]


[heading Example]
  


   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(io_context);
   std::experimental::net::connect(s, r.resolve(q)); 







[endsect]



[section:overload2 connect (2 of 8 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename EndpointSequence>
  Protocol::endpoint connect(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      std::error_code & ec,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to std::experimental::net::error::not\_found. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.


[heading Example]
  


   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(io_context);
   std::error_code ec;
   std::experimental::net::connect(s, r.resolve(q), ec);
   if (ec)
   {
     // An error occurred.
   } 







[endsect]



[section:overload3 connect (3 of 8 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename Iterator>
  Iterator connect(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

]


[heading Return Value]
      
An iterator denoting the successfully connected endpoint.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is std::experimental::net::error::not\_found. Otherwise, contains the error from the last connection attempt.]]

]


[heading Example]
  


   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::resolver::results_type e = r.resolve(q);
   tcp::socket s(io_context);
   std::experimental::net::connect(s, e.begin(), e.end()); 







[endsect]



[section:overload4 connect (4 of 8 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename Iterator>
  Iterator connect(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      std::error_code & ec);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to std::experimental::net::error::not\_found. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.


[heading Example]
  


   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::resolver::results_type e = r.resolve(q);
   tcp::socket s(io_context);
   std::error_code ec;
   std::experimental::net::connect(s, e.begin(), e.end(), ec);
   if (ec)
   {
     // An error occurred.
   } 







[endsect]



[section:overload5 connect (5 of 8 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename EndpointSequence,
      typename ConnectCondition>
  Protocol::endpoint connect(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const std::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

]


[heading Return Value]
      
The successfully connected endpoint.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is std::experimental::net::error::not\_found. Otherwise, contains the error from the last connection attempt.]]

]


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const std::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the std::experimental::net::connect function as follows: 

   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(io_context);
   tcp::endpoint e = std::experimental::net::connect(s,
       r.resolve(q), my_connect_condition());
   std::cout << "Connected to: " << e << std::endl; 







[endsect]



[section:overload6 connect (6 of 8 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename EndpointSequence,
      typename ConnectCondition>
  Protocol::endpoint connect(
      basic_socket< Protocol > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      std::error_code & ec,
      typename enable_if< is_endpoint_sequence< EndpointSequence >::value >::type *  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const std::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to std::experimental::net::error::not\_found. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const std::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the std::experimental::net::connect function as follows: 

   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(io_context);
   std::error_code ec;
   tcp::endpoint e = std::experimental::net::connect(s,
       r.resolve(q), my_connect_condition(), ec);
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     std::cout << "Connected to: " << e << std::endl;
   } 







[endsect]



[section:overload7 connect (7 of 8 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename Iterator,
      typename ConnectCondition>
  Iterator connect(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const std::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

]


[heading Return Value]
      
An iterator denoting the successfully connected endpoint.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is std::experimental::net::error::not\_found. Otherwise, contains the error from the last connection attempt.]]

]


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const std::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the std::experimental::net::connect function as follows: 

   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::resolver::results_type e = r.resolve(q);
   tcp::socket s(io_context);
   tcp::resolver::results_type::iterator i = std::experimental::net::connect(
       s, e.begin(), e.end(), my_connect_condition());
   std::cout << "Connected to: " << i->endpoint() << std::endl; 







[endsect]



[section:overload8 connect (8 of 8 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename Protocol,
      typename Iterator,
      typename ConnectCondition>
  Iterator connect(
      basic_socket< Protocol > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      std::error_code & ec);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const std::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to std::experimental::net::error::not\_found. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const std::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the std::experimental::net::connect function as follows: 

   tcp::resolver r(io_context);
   tcp::resolver::query q("host", "service");
   tcp::resolver::results_type e = r.resolve(q);
   tcp::socket s(io_context);
   std::error_code ec;
   tcp::resolver::results_type::iterator i = std::experimental::net::connect(
       s, e.begin(), e.end(), my_connect_condition());
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     std::cout << "Connected to: " << i->endpoint() << std::endl;
   } 







[endsect]


[endsect]

[section:const_buffer const_buffer]


Holds a buffer that cannot be modified. 


  class const_buffer


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.const_buffer.const_buffer [*const_buffer]]]
    [Construct an empty buffer. 

     Construct a buffer to represent a given memory range. 

     Construct a non-modifiable buffer from a modifiable one. ]
  ]
  
  [
    [[link networking_ts.reference.const_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link networking_ts.reference.const_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link networking_ts.reference.const_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.const_buffer.operator_plus_ [*operator+]]]
    [Create a new non-modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link networking_ts.reference.const_buffer `const_buffer`] class provides a safe representation of a buffer that cannot be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   std::experimental::net::const_buffer b1 = ...;
   std::size_t s1 = b1.size();
   const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 

[section:const_buffer const_buffer::const_buffer]


Construct an empty buffer. 


  ``[link networking_ts.reference.const_buffer.const_buffer.overload1 const_buffer]``();
  ``  [''''&raquo;''' [link networking_ts.reference.const_buffer.const_buffer.overload1 more...]]``


Construct a buffer to represent a given memory range. 


  ``[link networking_ts.reference.const_buffer.const_buffer.overload2 const_buffer]``(
      const void * data,
      std::size_t size);
  ``  [''''&raquo;''' [link networking_ts.reference.const_buffer.const_buffer.overload2 more...]]``


Construct a non-modifiable buffer from a modifiable one. 


  ``[link networking_ts.reference.const_buffer.const_buffer.overload3 const_buffer]``(
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link networking_ts.reference.const_buffer.const_buffer.overload3 more...]]``


[section:overload1 const_buffer::const_buffer (1 of 3 overloads)]


Construct an empty buffer. 


  const_buffer();



[endsect]



[section:overload2 const_buffer::const_buffer (2 of 3 overloads)]


Construct a buffer to represent a given memory range. 


  const_buffer(
      const void * data,
      std::size_t size);



[endsect]



[section:overload3 const_buffer::const_buffer (3 of 3 overloads)]


Construct a non-modifiable buffer from a modifiable one. 


  const_buffer(
      const mutable_buffer & b);



[endsect]


[endsect]


[section:data const_buffer::data]


Get a pointer to the beginning of the memory range. 


  const void * data() const;



[endsect]


[section:operator_plus_ const_buffer::operator+]


Create a new non-modifiable buffer that is offset from the start of another. 


  const_buffer ``[link networking_ts.reference.const_buffer.operator_plus_.overload1 operator+]``(
      const const_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link networking_ts.reference.const_buffer.operator_plus_.overload1 more...]]``

  const_buffer ``[link networking_ts.reference.const_buffer.operator_plus_.overload2 operator+]``(
      std::size_t n,
      const const_buffer & b);
  ``  [''''&raquo;''' [link networking_ts.reference.const_buffer.operator_plus_.overload2 more...]]``


[section:overload1 const_buffer::operator+ (1 of 2 overloads)]


Create a new non-modifiable buffer that is offset from the start of another. 


  const_buffer operator+(
      const const_buffer & b,
      std::size_t n);



[endsect]



[section:overload2 const_buffer::operator+ (2 of 2 overloads)]


Create a new non-modifiable buffer that is offset from the start of another. 


  const_buffer operator+(
      std::size_t n,
      const const_buffer & b);



[endsect]


[endsect]


[section:operator_plus__eq_ const_buffer::operator+=]


Move the start of the buffer by the specified number of bytes. 


  const_buffer & operator+=(
      std::size_t n);



[endsect]



[section:size const_buffer::size]


Get the size of the memory range. 


  std::size_t size() const;



[endsect]



[endsect]

[section:defer defer]


Submits a completion token or function object for execution. 

    
  template<
      typename CompletionToken>
  DEDUCED ``[link networking_ts.reference.defer.overload1 defer]``(
      CompletionToken && token);
  ``  [''''&raquo;''' [link networking_ts.reference.defer.overload1 more...]]``

  template<
      typename Executor,
      typename CompletionToken>
  DEDUCED ``[link networking_ts.reference.defer.overload2 defer]``(
      const Executor & ex,
      CompletionToken && token,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.defer.overload2 more...]]``

  template<
      typename ExecutionContext,
      typename CompletionToken>
  DEDUCED ``[link networking_ts.reference.defer.overload3 defer]``(
      ExecutionContext & ctx,
      CompletionToken && token,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.defer.overload3 more...]]``


[section:overload1 defer (1 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename CompletionToken>
  DEDUCED defer(
      CompletionToken && token);


This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from `defer()`.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex` by performing `get_associated_executor(handler)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Performs `ex.defer(std::move(handler), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload2 defer (2 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename Executor,
      typename CompletionToken>
  DEDUCED defer(
      const Executor & ex,
      CompletionToken && token,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);


This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from `defer()`.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex1` by performing `get_associated_executor(handler)`.


* Creates a work object `w` by performing `make_work(ex1)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Constructs a function object `f` with a function call operator that performs `ex1.dispatch(std::move(handler), alloc)` followed by `w.reset()`.


* Performs `Executor(ex).defer(std::move(f), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload3 defer (3 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename ExecutionContext,
      typename CompletionToken>
  DEDUCED defer(
      ExecutionContext & ctx,
      CompletionToken && token,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);



[heading Return Value]
      
`defer(ctx.get_executor(), forward<CompletionToken>(token))`. 




[endsect]


[endsect]

[section:dispatch dispatch]


Submits a completion token or function object for execution. 

    
  template<
      typename CompletionToken>
  DEDUCED ``[link networking_ts.reference.dispatch.overload1 dispatch]``(
      CompletionToken && token);
  ``  [''''&raquo;''' [link networking_ts.reference.dispatch.overload1 more...]]``

  template<
      typename Executor,
      typename CompletionToken>
  DEDUCED ``[link networking_ts.reference.dispatch.overload2 dispatch]``(
      const Executor & ex,
      CompletionToken && token,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.dispatch.overload2 more...]]``

  template<
      typename ExecutionContext,
      typename CompletionToken>
  DEDUCED ``[link networking_ts.reference.dispatch.overload3 dispatch]``(
      ExecutionContext & ctx,
      CompletionToken && token,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.dispatch.overload3 more...]]``


[section:overload1 dispatch (1 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename CompletionToken>
  DEDUCED dispatch(
      CompletionToken && token);


This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from `dispatch()`.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex` by performing `get_associated_executor(handler)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Performs `ex.dispatch(std::move(handler), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload2 dispatch (2 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename Executor,
      typename CompletionToken>
  DEDUCED dispatch(
      const Executor & ex,
      CompletionToken && token,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);


This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from `dispatch()`.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex1` by performing `get_associated_executor(handler)`.


* Creates a work object `w` by performing `make_work(ex1)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Constructs a function object `f` with a function call operator that performs `ex1.dispatch(std::move(handler), alloc)` followed by `w.reset()`.


* Performs `Executor(ex).dispatch(std::move(f), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload3 dispatch (3 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename ExecutionContext,
      typename CompletionToken>
  DEDUCED dispatch(
      ExecutionContext & ctx,
      CompletionToken && token,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);



[heading Return Value]
      
`dispatch(ctx.get_executor(), forward<CompletionToken>(token))`. 




[endsect]


[endsect]

[section:dynamic_buffer dynamic_buffer]


The std::experimental::net::dynamic\_buffer function is used to create a dynamically resized buffer from a `std::basic_string` or `std::vector`. 

      
  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  dynamic_string_buffer< Elem, Traits, Allocator > ``[link networking_ts.reference.dynamic_buffer.overload1 dynamic_buffer]``(
      std::basic_string< Elem, Traits, Allocator > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.dynamic_buffer.overload1 more...]]``

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  dynamic_string_buffer< Elem, Traits, Allocator > ``[link networking_ts.reference.dynamic_buffer.overload2 dynamic_buffer]``(
      std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size);
  ``  [''''&raquo;''' [link networking_ts.reference.dynamic_buffer.overload2 more...]]``

  template<
      typename Elem,
      typename Allocator>
  dynamic_vector_buffer< Elem, Allocator > ``[link networking_ts.reference.dynamic_buffer.overload3 dynamic_buffer]``(
      std::vector< Elem, Allocator > & data);
  ``  [''''&raquo;''' [link networking_ts.reference.dynamic_buffer.overload3 more...]]``

  template<
      typename Elem,
      typename Allocator>
  dynamic_vector_buffer< Elem, Allocator > ``[link networking_ts.reference.dynamic_buffer.overload4 dynamic_buffer]``(
      std::vector< Elem, Allocator > & data,
      std::size_t max_size);
  ``  [''''&raquo;''' [link networking_ts.reference.dynamic_buffer.overload4 more...]]``


[section:overload1 dynamic_buffer (1 of 4 overloads)]


Create a new dynamic buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  dynamic_string_buffer< Elem, Traits, Allocator > dynamic_buffer(
      std::basic_string< Elem, Traits, Allocator > & data);



[heading Return Value]
      
`dynamic_string_buffer<Elem, Traits, Allocator>(data)`. 




[endsect]



[section:overload2 dynamic_buffer (2 of 4 overloads)]


Create a new dynamic buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  dynamic_string_buffer< Elem, Traits, Allocator > dynamic_buffer(
      std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size);



[heading Return Value]
      
`dynamic_string_buffer<Elem, Traits, Allocator>(data, max_size)`. 




[endsect]



[section:overload3 dynamic_buffer (3 of 4 overloads)]


Create a new dynamic buffer that represents the given vector. 


  template<
      typename Elem,
      typename Allocator>
  dynamic_vector_buffer< Elem, Allocator > dynamic_buffer(
      std::vector< Elem, Allocator > & data);



[heading Return Value]
      
`dynamic_vector_buffer<Elem, Allocator>(data)`. 




[endsect]



[section:overload4 dynamic_buffer (4 of 4 overloads)]


Create a new dynamic buffer that represents the given vector. 


  template<
      typename Elem,
      typename Allocator>
  dynamic_vector_buffer< Elem, Allocator > dynamic_buffer(
      std::vector< Elem, Allocator > & data,
      std::size_t max_size);



[heading Return Value]
      
`dynamic_vector_buffer<Elem, Allocator>(data, max_size)`. 




[endsect]


[endsect]

[section:dynamic_string_buffer dynamic_string_buffer]


Adapt a basic\_string to the DynamicBuffer requirements. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  class dynamic_string_buffer


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.dynamic_string_buffer.const_buffers_type [*const_buffers_type]]]
    [The type used to represent the input sequence as a list of buffers. ]
  
  ]

  [

    [[link networking_ts.reference.dynamic_string_buffer.mutable_buffers_type [*mutable_buffers_type]]]
    [The type used to represent the output sequence as a list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.dynamic_string_buffer.capacity [*capacity]]]
    [Get the current capacity of the dynamic buffer. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_string_buffer.commit [*commit]]]
    [Move bytes from the output sequence to the input sequence. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_string_buffer.consume [*consume]]]
    [Remove characters from the input sequence. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_string_buffer.data [*data]]]
    [Get a list of buffers that represents the input sequence. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_string_buffer.dynamic_string_buffer [*dynamic_string_buffer]]]
    [Construct a dynamic buffer from a string. 

     Move construct a dynamic buffer. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_string_buffer.max_size [*max_size]]]
    [Get the maximum size of the dynamic buffer. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_string_buffer.prepare [*prepare]]]
    [Get a list of buffers that represents the output sequence, with the given size. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_string_buffer.size [*size]]]
    [Get the size of the input sequence. ]
  ]
  
]

Requires that `sizeof(Elem) == 1`. 


[section:capacity dynamic_string_buffer::capacity]


Get the current capacity of the dynamic buffer. 


  std::size_t capacity() const;



[heading Return Value]
      
The current total capacity of the buffer, i.e. for both the input sequence and output sequence. 




[endsect]



[section:commit dynamic_string_buffer::commit]


Move bytes from the output sequence to the input sequence. 


  void commit(
      std::size_t n);



[heading Parameters]
    

[variablelist
  
[[n][The number of bytes to append from the start of the output sequence to the end of the input sequence. The remainder of the output sequence is discarded.]]

]

Requires a preceding call `prepare(x)` where `x >= n`, and no intervening operations that modify the input or output sequence.


[heading Remarks]
      
If `n` is greater than the size of the output sequence, the entire output sequence is moved to the input sequence and no error is issued. 




[endsect]



[section:const_buffers_type dynamic_string_buffer::const_buffers_type]


The type used to represent the input sequence as a list of buffers. 


  typedef const_buffer const_buffers_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.const_buffer.const_buffer [*const_buffer]]]
    [Construct an empty buffer. 

     Construct a buffer to represent a given memory range. 

     Construct a non-modifiable buffer from a modifiable one. ]
  ]
  
  [
    [[link networking_ts.reference.const_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link networking_ts.reference.const_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link networking_ts.reference.const_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.const_buffer.operator_plus_ [*operator+]]]
    [Create a new non-modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link networking_ts.reference.const_buffer `const_buffer`] class provides a safe representation of a buffer that cannot be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   std::experimental::net::const_buffer b1 = ...;
   std::size_t s1 = b1.size();
   const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 



[endsect]



[section:consume dynamic_string_buffer::consume]


Remove characters from the input sequence. 


  void consume(
      std::size_t n);


Removes `n` characters from the beginning of the input sequence.


[heading Remarks]
      
If `n` is greater than the size of the input sequence, the entire input sequence is consumed and no error is issued. 




[endsect]



[section:data dynamic_string_buffer::data]


Get a list of buffers that represents the input sequence. 


  const_buffers_type data() const;



[heading Return Value]
      
An object of type `const_buffers_type` that satisfies ConstBufferSequence requirements, representing the basic\_string memory in input sequence.


[heading Remarks]
      
The returned object is invalidated by any `dynamic_string_buffer` or `basic_string` member function that modifies the input sequence or output sequence. 




[endsect]


[section:dynamic_string_buffer dynamic_string_buffer::dynamic_string_buffer]


Construct a dynamic buffer from a string. 


  explicit ``[link networking_ts.reference.dynamic_string_buffer.dynamic_string_buffer.overload1 dynamic_string_buffer]``(
      std::basic_string< Elem, Traits, Allocator > & s,
      std::size_t maximum_size = (std::numeric_limits< std::size_t >::max)());
  ``  [''''&raquo;''' [link networking_ts.reference.dynamic_string_buffer.dynamic_string_buffer.overload1 more...]]``


Move construct a dynamic buffer. 


  ``[link networking_ts.reference.dynamic_string_buffer.dynamic_string_buffer.overload2 dynamic_string_buffer]``(
      dynamic_string_buffer && other);
  ``  [''''&raquo;''' [link networking_ts.reference.dynamic_string_buffer.dynamic_string_buffer.overload2 more...]]``


[section:overload1 dynamic_string_buffer::dynamic_string_buffer (1 of 2 overloads)]


Construct a dynamic buffer from a string. 


  dynamic_string_buffer(
      std::basic_string< Elem, Traits, Allocator > & s,
      std::size_t maximum_size = (std::numeric_limits< std::size_t >::max)());



[heading Parameters]
    

[variablelist
  
[[s][The string to be used as backing storage for the dynamic buffer. Any existing data in the string is treated as the dynamic buffer's input sequence. The object stores a reference to the string and the user is responsible for ensuring that the string object remains valid until the [link networking_ts.reference.dynamic_string_buffer `dynamic_string_buffer`] object is destroyed.]]

[[maximum_size][Specifies a maximum size for the buffer, in bytes. ]]

]




[endsect]



[section:overload2 dynamic_string_buffer::dynamic_string_buffer (2 of 2 overloads)]


Move construct a dynamic buffer. 


  dynamic_string_buffer(
      dynamic_string_buffer && other);



[endsect]


[endsect]


[section:max_size dynamic_string_buffer::max_size]


Get the maximum size of the dynamic buffer. 


  std::size_t max_size() const;



[heading Return Value]
      
The allowed maximum of the sum of the sizes of the input sequence and output sequence. 




[endsect]



[section:mutable_buffers_type dynamic_string_buffer::mutable_buffers_type]


The type used to represent the output sequence as a list of buffers. 


  typedef mutable_buffer mutable_buffers_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.mutable_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.mutable_buffer [*mutable_buffer]]]
    [Construct an empty buffer. 

     Construct a buffer to represent a given memory range. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.mutable_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link networking_ts.reference.mutable_buffer `mutable_buffer`] class provides a safe representation of a buffer that can be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   std::experimental::net::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 



[endsect]



[section:prepare dynamic_string_buffer::prepare]


Get a list of buffers that represents the output sequence, with the given size. 


  mutable_buffers_type prepare(
      std::size_t n);


Ensures that the output sequence can accommodate `n` bytes, resizing the basic\_string object as necessary.


[heading Return Value]
      
An object of type `mutable_buffers_type` that satisfies MutableBufferSequence requirements, representing basic\_string memory at the start of the output sequence of size `n`.


[heading Exceptions]
    

[variablelist
  
[[std::length_error][If `size() + n > max_size()`.]]

]


[heading Remarks]
      
The returned object is invalidated by any `dynamic_string_buffer` or `basic_string` member function that modifies the input sequence or output sequence. 




[endsect]



[section:size dynamic_string_buffer::size]


Get the size of the input sequence. 


  std::size_t size() const;



[endsect]



[endsect]

[section:dynamic_vector_buffer dynamic_vector_buffer]


Adapt a vector to the DynamicBuffer requirements. 


  template<
      typename Elem,
      typename Allocator>
  class dynamic_vector_buffer


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.dynamic_vector_buffer.const_buffers_type [*const_buffers_type]]]
    [The type used to represent the input sequence as a list of buffers. ]
  
  ]

  [

    [[link networking_ts.reference.dynamic_vector_buffer.mutable_buffers_type [*mutable_buffers_type]]]
    [The type used to represent the output sequence as a list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.dynamic_vector_buffer.capacity [*capacity]]]
    [Get the current capacity of the dynamic buffer. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_vector_buffer.commit [*commit]]]
    [Move bytes from the output sequence to the input sequence. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_vector_buffer.consume [*consume]]]
    [Remove characters from the input sequence. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_vector_buffer.data [*data]]]
    [Get a list of buffers that represents the input sequence. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_vector_buffer.dynamic_vector_buffer [*dynamic_vector_buffer]]]
    [Construct a dynamic buffer from a string. 

     Move construct a dynamic buffer. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_vector_buffer.max_size [*max_size]]]
    [Get the maximum size of the dynamic buffer. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_vector_buffer.prepare [*prepare]]]
    [Get a list of buffers that represents the output sequence, with the given size. ]
  ]
  
  [
    [[link networking_ts.reference.dynamic_vector_buffer.size [*size]]]
    [Get the size of the input sequence. ]
  ]
  
]

Requires that `sizeof(Elem) == 1`. 


[section:capacity dynamic_vector_buffer::capacity]


Get the current capacity of the dynamic buffer. 


  std::size_t capacity() const;



[heading Return Value]
      
The current total capacity of the buffer, i.e. for both the input sequence and output sequence. 




[endsect]



[section:commit dynamic_vector_buffer::commit]


Move bytes from the output sequence to the input sequence. 


  void commit(
      std::size_t n);



[heading Parameters]
    

[variablelist
  
[[n][The number of bytes to append from the start of the output sequence to the end of the input sequence. The remainder of the output sequence is discarded.]]

]

Requires a preceding call `prepare(x)` where `x >= n`, and no intervening operations that modify the input or output sequence.


[heading Remarks]
      
If `n` is greater than the size of the output sequence, the entire output sequence is moved to the input sequence and no error is issued. 




[endsect]



[section:const_buffers_type dynamic_vector_buffer::const_buffers_type]


The type used to represent the input sequence as a list of buffers. 


  typedef const_buffer const_buffers_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.const_buffer.const_buffer [*const_buffer]]]
    [Construct an empty buffer. 

     Construct a buffer to represent a given memory range. 

     Construct a non-modifiable buffer from a modifiable one. ]
  ]
  
  [
    [[link networking_ts.reference.const_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link networking_ts.reference.const_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link networking_ts.reference.const_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.const_buffer.operator_plus_ [*operator+]]]
    [Create a new non-modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link networking_ts.reference.const_buffer `const_buffer`] class provides a safe representation of a buffer that cannot be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   std::experimental::net::const_buffer b1 = ...;
   std::size_t s1 = b1.size();
   const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 



[endsect]



[section:consume dynamic_vector_buffer::consume]


Remove characters from the input sequence. 


  void consume(
      std::size_t n);


Removes `n` characters from the beginning of the input sequence.


[heading Remarks]
      
If `n` is greater than the size of the input sequence, the entire input sequence is consumed and no error is issued. 




[endsect]



[section:data dynamic_vector_buffer::data]


Get a list of buffers that represents the input sequence. 


  const_buffers_type data() const;



[heading Return Value]
      
An object of type `const_buffers_type` that satisfies ConstBufferSequence requirements, representing the basic\_string memory in input sequence.


[heading Remarks]
      
The returned object is invalidated by any `dynamic_vector_buffer` or `basic_string` member function that modifies the input sequence or output sequence. 




[endsect]


[section:dynamic_vector_buffer dynamic_vector_buffer::dynamic_vector_buffer]


Construct a dynamic buffer from a string. 


  explicit ``[link networking_ts.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload1 dynamic_vector_buffer]``(
      std::vector< Elem, Allocator > & v,
      std::size_t maximum_size = (std::numeric_limits< std::size_t >::max)());
  ``  [''''&raquo;''' [link networking_ts.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload1 more...]]``


Move construct a dynamic buffer. 


  ``[link networking_ts.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload2 dynamic_vector_buffer]``(
      dynamic_vector_buffer && other);
  ``  [''''&raquo;''' [link networking_ts.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload2 more...]]``


[section:overload1 dynamic_vector_buffer::dynamic_vector_buffer (1 of 2 overloads)]


Construct a dynamic buffer from a string. 


  dynamic_vector_buffer(
      std::vector< Elem, Allocator > & v,
      std::size_t maximum_size = (std::numeric_limits< std::size_t >::max)());



[heading Parameters]
    

[variablelist
  
[[v][The vector to be used as backing storage for the dynamic buffer. Any existing data in the vector is treated as the dynamic buffer's input sequence. The object stores a reference to the vector and the user is responsible for ensuring that the vector object remains valid until the [link networking_ts.reference.dynamic_vector_buffer `dynamic_vector_buffer`] object is destroyed.]]

[[maximum_size][Specifies a maximum size for the buffer, in bytes. ]]

]




[endsect]



[section:overload2 dynamic_vector_buffer::dynamic_vector_buffer (2 of 2 overloads)]


Move construct a dynamic buffer. 


  dynamic_vector_buffer(
      dynamic_vector_buffer && other);



[endsect]


[endsect]


[section:max_size dynamic_vector_buffer::max_size]


Get the maximum size of the dynamic buffer. 


  std::size_t max_size() const;



[heading Return Value]
      
The allowed maximum of the sum of the sizes of the input sequence and output sequence. 




[endsect]



[section:mutable_buffers_type dynamic_vector_buffer::mutable_buffers_type]


The type used to represent the output sequence as a list of buffers. 


  typedef mutable_buffer mutable_buffers_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.mutable_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.mutable_buffer [*mutable_buffer]]]
    [Construct an empty buffer. 

     Construct a buffer to represent a given memory range. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.mutable_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link networking_ts.reference.mutable_buffer `mutable_buffer`] class provides a safe representation of a buffer that can be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   std::experimental::net::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 



[endsect]



[section:prepare dynamic_vector_buffer::prepare]


Get a list of buffers that represents the output sequence, with the given size. 


  mutable_buffers_type prepare(
      std::size_t n);


Ensures that the output sequence can accommodate `n` bytes, resizing the basic\_string object as necessary.


[heading Return Value]
      
An object of type `mutable_buffers_type` that satisfies MutableBufferSequence requirements, representing basic\_string memory at the start of the output sequence of size `n`.


[heading Exceptions]
    

[variablelist
  
[[std::length_error][If `size() + n > max_size()`.]]

]


[heading Remarks]
      
The returned object is invalidated by any `dynamic_vector_buffer` or `basic_string` member function that modifies the input sequence or output sequence. 




[endsect]



[section:size dynamic_vector_buffer::size]


Get the size of the input sequence. 


  std::size_t size() const;



[endsect]



[endsect]

[section:error__NET_TS_UNUSED_VARIABLE error::NET_TS_UNUSED_VARIABLE]


    
  const std::error_category &system_category ``[link networking_ts.reference.error__NET_TS_UNUSED_VARIABLE.overload1 NET_TS_UNUSED_VARIABLE]``();
  ``  [''''&raquo;''' [link networking_ts.reference.error__NET_TS_UNUSED_VARIABLE.overload1 more...]]``

  const std::error_category &netdb_category ``[link networking_ts.reference.error__NET_TS_UNUSED_VARIABLE.overload2 NET_TS_UNUSED_VARIABLE]``();
  ``  [''''&raquo;''' [link networking_ts.reference.error__NET_TS_UNUSED_VARIABLE.overload2 more...]]``

  const std::error_category &addrinfo_category ``[link networking_ts.reference.error__NET_TS_UNUSED_VARIABLE.overload3 NET_TS_UNUSED_VARIABLE]``();
  ``  [''''&raquo;''' [link networking_ts.reference.error__NET_TS_UNUSED_VARIABLE.overload3 more...]]``

  const std::error_category &misc_category ``[link networking_ts.reference.error__NET_TS_UNUSED_VARIABLE.overload4 NET_TS_UNUSED_VARIABLE]``();
  ``  [''''&raquo;''' [link networking_ts.reference.error__NET_TS_UNUSED_VARIABLE.overload4 more...]]``


[section:overload1 error::NET_TS_UNUSED_VARIABLE (1 of 4 overloads)]



  static const std::error_category &system_category NET_TS_UNUSED_VARIABLE = std::experimental::net::error::get_system_category();



[endsect]



[section:overload2 error::NET_TS_UNUSED_VARIABLE (2 of 4 overloads)]



  static const std::error_category &netdb_category NET_TS_UNUSED_VARIABLE = std::experimental::net::error::get_netdb_category();



[endsect]



[section:overload3 error::NET_TS_UNUSED_VARIABLE (3 of 4 overloads)]



  static const std::error_category &addrinfo_category NET_TS_UNUSED_VARIABLE = std::experimental::net::error::get_addrinfo_category();



[endsect]



[section:overload4 error::NET_TS_UNUSED_VARIABLE (4 of 4 overloads)]



  static const std::error_category &misc_category NET_TS_UNUSED_VARIABLE = std::experimental::net::error::get_misc_category();



[endsect]


[endsect]


[section:error__addrinfo_errors error::addrinfo_errors]



  enum addrinfo_errors


[heading Values]
[variablelist

  [
    [service_not_found]
    [The service is not supported for the given socket type. ]
  ]

  [
    [socket_type_not_supported]
    [The socket type is not supported. ]
  ]

]



[endsect]



[section:error__basic_errors error::basic_errors]



  enum basic_errors


[heading Values]
[variablelist

  [
    [access_denied]
    [Permission denied. ]
  ]

  [
    [address_family_not_supported]
    [Address family not supported by protocol. ]
  ]

  [
    [address_in_use]
    [Address already in use. ]
  ]

  [
    [already_connected]
    [Transport endpoint is already connected. ]
  ]

  [
    [already_started]
    [Operation already in progress. ]
  ]

  [
    [broken_pipe]
    [Broken pipe. ]
  ]

  [
    [connection_aborted]
    [A connection has been aborted. ]
  ]

  [
    [connection_refused]
    [Connection refused. ]
  ]

  [
    [connection_reset]
    [Connection reset by peer. ]
  ]

  [
    [bad_descriptor]
    [Bad file descriptor. ]
  ]

  [
    [fault]
    [Bad address. ]
  ]

  [
    [host_unreachable]
    [No route to host. ]
  ]

  [
    [in_progress]
    [Operation now in progress. ]
  ]

  [
    [interrupted]
    [Interrupted system call. ]
  ]

  [
    [invalid_argument]
    [Invalid argument. ]
  ]

  [
    [message_size]
    [Message too long. ]
  ]

  [
    [name_too_long]
    [The name was too long. ]
  ]

  [
    [network_down]
    [Network is down. ]
  ]

  [
    [network_reset]
    [Network dropped connection on reset. ]
  ]

  [
    [network_unreachable]
    [Network is unreachable. ]
  ]

  [
    [no_descriptors]
    [Too many open files. ]
  ]

  [
    [no_buffer_space]
    [No buffer space available. ]
  ]

  [
    [no_memory]
    [Cannot allocate memory. ]
  ]

  [
    [no_permission]
    [Operation not permitted. ]
  ]

  [
    [no_protocol_option]
    [Protocol not available. ]
  ]

  [
    [no_such_device]
    [No such device. ]
  ]

  [
    [not_connected]
    [Transport endpoint is not connected. ]
  ]

  [
    [not_socket]
    [Socket operation on non-socket. ]
  ]

  [
    [operation_aborted]
    [Operation cancelled. ]
  ]

  [
    [operation_not_supported]
    [Operation not supported. ]
  ]

  [
    [shut_down]
    [Cannot send after transport endpoint shutdown. ]
  ]

  [
    [timed_out]
    [Connection timed out. ]
  ]

  [
    [try_again]
    [Resource temporarily unavailable. ]
  ]

  [
    [would_block]
    [The socket is marked non-blocking and the requested operation would block. ]
  ]

]



[endsect]



[section:error__get_addrinfo_category error::get_addrinfo_category]



  const std::error_category & get_addrinfo_category();



[endsect]



[section:error__get_misc_category error::get_misc_category]



  const std::error_category & get_misc_category();



[endsect]



[section:error__get_netdb_category error::get_netdb_category]



  const std::error_category & get_netdb_category();



[endsect]



[section:error__get_system_category error::get_system_category]



  const std::error_category & get_system_category();



[endsect]


[section:error__make_error_code error::make_error_code]


    
  std::error_code ``[link networking_ts.reference.error__make_error_code.overload1 make_error_code]``(
      basic_errors e);
  ``  [''''&raquo;''' [link networking_ts.reference.error__make_error_code.overload1 more...]]``

  std::error_code ``[link networking_ts.reference.error__make_error_code.overload2 make_error_code]``(
      netdb_errors e);
  ``  [''''&raquo;''' [link networking_ts.reference.error__make_error_code.overload2 more...]]``

  std::error_code ``[link networking_ts.reference.error__make_error_code.overload3 make_error_code]``(
      addrinfo_errors e);
  ``  [''''&raquo;''' [link networking_ts.reference.error__make_error_code.overload3 more...]]``

  std::error_code ``[link networking_ts.reference.error__make_error_code.overload4 make_error_code]``(
      misc_errors e);
  ``  [''''&raquo;''' [link networking_ts.reference.error__make_error_code.overload4 more...]]``


[section:overload1 error::make_error_code (1 of 4 overloads)]



  std::error_code make_error_code(
      basic_errors e);



[endsect]



[section:overload2 error::make_error_code (2 of 4 overloads)]



  std::error_code make_error_code(
      netdb_errors e);



[endsect]



[section:overload3 error::make_error_code (3 of 4 overloads)]



  std::error_code make_error_code(
      addrinfo_errors e);



[endsect]



[section:overload4 error::make_error_code (4 of 4 overloads)]



  std::error_code make_error_code(
      misc_errors e);



[endsect]


[endsect]


[section:error__misc_errors error::misc_errors]



  enum misc_errors


[heading Values]
[variablelist

  [
    [already_open]
    [Already open. ]
  ]

  [
    [eof]
    [End of file or stream. ]
  ]

  [
    [not_found]
    [Element not found. ]
  ]

  [
    [fd_set_failure]
    [The descriptor cannot fit into the select system call's fd_set. ]
  ]

]



[endsect]



[section:error__netdb_errors error::netdb_errors]



  enum netdb_errors


[heading Values]
[variablelist

  [
    [host_not_found]
    [Host not found (authoritative). ]
  ]

  [
    [host_not_found_try_again]
    [Host not found (non-authoritative). ]
  ]

  [
    [no_data]
    [The query is valid but does not have associated address data. ]
  ]

  [
    [no_recovery]
    [A non-recoverable error occurred. ]
  ]

]



[endsect]


[section:execution_context execution_context]


A context for function object execution. 


  class execution_context :
    noncopyable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.execution_context.fork_event [*fork_event]]]
    [Fork-related event notifications. ]
  
  ]

  [

    [[link networking_ts.reference.execution_context__id [*id]]]
    [Class used to uniquely identify a service. ]
  
  ]

  [

    [[link networking_ts.reference.execution_context__service [*service]]]
    [Base class for all io_context services. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.execution_context.notify_fork [*notify_fork]]]
    [Notify the execution_context of a fork-related event. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.execution_context.destroy [*destroy]]]
    [Destroys all services in the context. ]
  ]
  
  [
    [[link networking_ts.reference.execution_context.execution_context [*execution_context]]]
    [Constructor. ]
  ]
  
  [
    [[link networking_ts.reference.execution_context.shutdown [*shutdown]]]
    [Shuts down all services in the context. ]
  ]
  
  [
    [[link networking_ts.reference.execution_context._execution_context [*~execution_context]]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.execution_context.add_service [*add_service]]]
    [(Deprecated: Use make_service().) Add a service object to the execution_context. ]
  ]
  
  [
    [[link networking_ts.reference.execution_context.has_service [*has_service]]]
    [Determine if an execution_context contains a specified service type. ]
  ]
  
  [
    [[link networking_ts.reference.execution_context.make_service [*make_service]]]
    [Creates a service object and adds it to the execution_context. ]
  ]
  
  [
    [[link networking_ts.reference.execution_context.use_service [*use_service]]]
    [Obtain the service object corresponding to the given type. ]
  ]
  
]

An execution context represents a place where function objects will be executed. An `io_context` is an example of an execution context.


[heading The execution_context class and services]
  


Class [link networking_ts.reference.execution_context `execution_context`] implements an extensible, type-safe, polymorphic set of services, indexed by service type.

Services exist to manage the resources that are shared across an execution context. For example, timers may be implemented in terms of a single timer queue, and this queue would be stored in a service.

Access to the services of an [link networking_ts.reference.execution_context `execution_context`] is via three function templates, `use_service()`, `add_service()` and `has_service()`.

In a call to `use_service<Service>()`, the type argument chooses a service, making available all members of the named type. If `Service` is not present in an [link networking_ts.reference.execution_context `execution_context`], an object of type `Service` is created and added to the [link networking_ts.reference.execution_context `execution_context`]. A C++ program can check if an [link networking_ts.reference.execution_context `execution_context`] implements a particular service with the function template `has_service<Service>()`.

Service objects may be explicitly added to an [link networking_ts.reference.execution_context `execution_context`] using the function template `add_service<Service>()`. If the `Service` is already present, the [link networking_ts.reference.service_already_exists `service_already_exists`] exception is thrown. If the owner of the service is not the same object as the [link networking_ts.reference.execution_context `execution_context`] parameter, the [link networking_ts.reference.invalid_service_owner `invalid_service_owner`] exception is thrown.

Once a service reference is obtained from an [link networking_ts.reference.execution_context `execution_context`] object by calling `use_service()`, that reference remains usable as long as the owning [link networking_ts.reference.execution_context `execution_context`] object exists.

All service implementations have [link networking_ts.reference.execution_context__service `execution_context::service`] as a public base class. Custom services may be implemented by deriving from this class and then added to an [link networking_ts.reference.execution_context `execution_context`] using the facilities described above.


[heading The execution_context as a base class]
  


Class [link networking_ts.reference.execution_context `execution_context`] may be used only as a base class for concrete execution context types. The `io_context` is an example of such a derived type.

On destruction, a class that is derived from [link networking_ts.reference.execution_context `execution_context`] must perform `execution_context::shutdown()` followed by `execution_context::destroy()`.

This destruction sequence permits programs to simplify their resource management by using `shared_ptr<>`. Where an object's lifetime is tied to the lifetime of a connection (or some other sequence of asynchronous operations), a `shared_ptr` to the object would be bound into the handlers for all asynchronous operations associated with it. This works as follows:


* When a single connection ends, all associated asynchronous operations complete. The corresponding handler objects are destroyed, and all `shared_ptr` references to the objects are destroyed.


* To shut down the whole program, the [link networking_ts.reference.io_context `io_context`] function stop() is called to terminate any run() calls as soon as possible. The [link networking_ts.reference.io_context `io_context`] destructor calls `shutdown()` and `destroy()` to destroy all pending handlers, causing all `shared_ptr` references to all connection objects to be destroyed. 




[section:add_service execution_context::add_service]


(Deprecated: Use `make_service()`.) Add a service object to the [link networking_ts.reference.execution_context `execution_context`]. 


  template<
      typename Service>
  friend void add_service(
      execution_context & e,
      Service * svc);


This function is used to add a service to the [link networking_ts.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

[[svc][The service object. On success, ownership of the service object is transferred to the [link networking_ts.reference.execution_context `execution_context`]. When the [link networking_ts.reference.execution_context `execution_context`] object is destroyed, it will destroy the service object by performing:
``
   delete static_cast<execution_context::service*>(svc) 
``
]]

]


[heading Exceptions]
    

[variablelist
  
[[std::experimental::net::service_already_exists][Thrown if a service of the given type is already present in the [link networking_ts.reference.execution_context `execution_context`].]]

[[std::experimental::net::invalid_service_owner][Thrown if the service's owning [link networking_ts.reference.execution_context `execution_context`] is not the [link networking_ts.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]

]




[endsect]



[section:destroy execution_context::destroy]


Destroys all services in the context. 


  void destroy();


This function is implemented as follows:


* For each service object `svc` in the [link networking_ts.reference.execution_context `execution_context`] set, in reverse order * of the beginning of service object lifetime, performs `delete static_cast<execution_context::service*>(svc)`. 




[endsect]



[section:execution_context execution_context::execution_context]


Constructor. 


  execution_context();



[endsect]



[section:fork_event execution_context::fork_event]


Fork-related event notifications. 


  enum fork_event


[heading Values]
[variablelist

  [
    [fork_prepare]
    [Notify the context that the process is about to fork. ]
  ]

  [
    [fork_parent]
    [Notify the context that the process has forked and is the parent. ]
  ]

  [
    [fork_child]
    [Notify the context that the process has forked and is the child. ]
  ]

]



[endsect]



[section:has_service execution_context::has_service]


Determine if an [link networking_ts.reference.execution_context `execution_context`] contains a specified service type. 


  template<
      typename Service>
  friend bool has_service(
      execution_context & e);


This function is used to determine whether the [link networking_ts.reference.execution_context `execution_context`] contains a service object corresponding to the given service type.


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
A boolean indicating whether the [link networking_ts.reference.execution_context `execution_context`] contains the service. 




[endsect]



[section:make_service execution_context::make_service]


Creates a service object and adds it to the [link networking_ts.reference.execution_context `execution_context`]. 


  template<
      typename Service,
      typename... Args>
  friend Service & make_service(
      execution_context & e,
      Args &&... args);


This function is used to add a service to the [link networking_ts.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

[[args][Zero or more arguments to be passed to the service constructor.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::experimental::net::service_already_exists][Thrown if a service of the given type is already present in the [link networking_ts.reference.execution_context `execution_context`]. ]]

]




[endsect]



[section:notify_fork execution_context::notify_fork]


Notify the [link networking_ts.reference.execution_context `execution_context`] of a fork-related event. 


  void notify_fork(
      fork_event event);


This function is used to inform the [link networking_ts.reference.execution_context `execution_context`] that the process is about to fork, or has just forked. This allows the [link networking_ts.reference.execution_context `execution_context`], and the services it contains, to perform any necessary housekeeping to ensure correct operation following a fork.

This function must not be called while any other [link networking_ts.reference.execution_context `execution_context`] function, or any function associated with the execution\_context's derived class, is being called in another thread. It is, however, safe to call this function from within a completion handler, provided no other thread is accessing the [link networking_ts.reference.execution_context `execution_context`] or its derived class.


[heading Parameters]
    

[variablelist
  
[[event][A fork-related event.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the notification fails the [link networking_ts.reference.execution_context `execution_context`] object should no longer be used and should be destroyed.]]

]


[heading Example]
  
The following code illustrates how to incorporate the `notify_fork()` function: 

   my_execution_context.notify_fork(execution_context::fork_prepare);
   if (fork() == 0)
   {
     // This is the child process.
     my_execution_context.notify_fork(execution_context::fork_child);
   }
   else
   {
     // This is the parent process.
     my_execution_context.notify_fork(execution_context::fork_parent);
   } 





[heading Remarks]
      
For each service object `svc` in the [link networking_ts.reference.execution_context `execution_context`] set, performs `svc->notify_fork();`. When processing the fork\_prepare event, services are visited in reverse order of the beginning of service object lifetime. Otherwise, services are visited in order of the beginning of service object lifetime. 




[endsect]



[section:shutdown execution_context::shutdown]


Shuts down all services in the context. 


  void shutdown();


This function is implemented as follows:


* For each service object `svc` in the [link networking_ts.reference.execution_context `execution_context`] set, in reverse order of the beginning of service object lifetime, performs `svc->shutdown()`. 




[endsect]


[section:use_service execution_context::use_service]


Obtain the service object corresponding to the given type. 


  template<
      typename Service>
  friend Service & ``[link networking_ts.reference.execution_context.use_service.overload1 use_service]``(
      execution_context & e);
  ``  [''''&raquo;''' [link networking_ts.reference.execution_context.use_service.overload1 more...]]``

  template<
      typename Service>
  friend Service & ``[link networking_ts.reference.execution_context.use_service.overload2 use_service]``(
      io_context & ioc);
  ``  [''''&raquo;''' [link networking_ts.reference.execution_context.use_service.overload2 more...]]``


[section:overload1 execution_context::use_service (1 of 2 overloads)]


Obtain the service object corresponding to the given type. 


  template<
      typename Service>
  friend Service & use_service(
      execution_context & e);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link networking_ts.reference.execution_context `execution_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. 




[endsect]



[section:overload2 execution_context::use_service (2 of 2 overloads)]


Obtain the service object corresponding to the given type. 


  template<
      typename Service>
  friend Service & use_service(
      io_context & ioc);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link networking_ts.reference.io_context `io_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[ioc][The [link networking_ts.reference.io_context `io_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller.


[heading Remarks]
      
This overload is preserved for backwards compatibility with services that inherit from [link networking_ts.reference.io_context__service `io_context::service`]. 




[endsect]


[endsect]


[section:_execution_context execution_context::~execution_context]


Destructor. 


  ~execution_context();



[endsect]



[endsect]

[section:execution_context__id execution_context::id]


Class used to uniquely identify a service. 


  class id :
    noncopyable


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.execution_context__id.id [*id]]]
    [Constructor. ]
  ]
  
]


[section:id execution_context::id::id]


Constructor. 


  id();



[endsect]



[endsect]

[section:execution_context__service execution_context::service]


Base class for all [link networking_ts.reference.io_context `io_context`] services. 


  class service :
    noncopyable


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.execution_context__service.context [*context]]]
    [Get the context object that owns the service. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.execution_context__service.service [*service]]]
    [Constructor. ]
  ]
  
  [
    [[link networking_ts.reference.execution_context__service._service [*~service]]]
    [Destructor. ]
  ]
  
]


[section:context execution_context::service::context]


Get the context object that owns the service. 


  execution_context & context();



[endsect]



[section:service execution_context::service::service]


Constructor. 


  service(
      execution_context & owner);



[heading Parameters]
    

[variablelist
  
[[owner][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service. ]]

]




[endsect]



[section:_service execution_context::service::~service]


Destructor. 


  virtual ~service();



[endsect]



[endsect]

[section:executor executor]


Polymorphic wrapper for executors. 


  class executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.executor__unspecified_bool_type_t [*unspecified_bool_type_t]]]
    []
  
  ]

  [

    [[link networking_ts.reference.executor.unspecified_bool_type [*unspecified_bool_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.executor.defer [*defer]]]
    [Request the executor to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.executor.dispatch [*dispatch]]]
    [Request the executor to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.executor.executor [*executor]]]
    [Default constructor. 

     Construct from nullptr. 

     Copy constructor. 

     Move constructor. 

     Construct a polymorphic wrapper for the specified executor. 

     Allocator-aware constructor to create a polymorphic wrapper for the specified executor. ]
  ]
  
  [
    [[link networking_ts.reference.executor.on_work_finished [*on_work_finished]]]
    [Inform the executor that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.executor.on_work_started [*on_work_started]]]
    [Inform the executor that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.executor.operator_unspecified_bool_type [*operator unspecified_bool_type]]]
    [Operator to test if the executor contains a valid target. ]
  ]
  
  [
    [[link networking_ts.reference.executor.operator_eq_ [*operator=]]]
    [Assignment operator. 

     

     Assignment operator for nullptr_t. 

     Assignment operator to create a polymorphic wrapper for the specified executor. ]
  ]
  
  [
    [[link networking_ts.reference.executor.post [*post]]]
    [Request the executor to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.executor.target [*target]]]
    [Obtain a pointer to the target executor object. ]
  ]
  
  [
    [[link networking_ts.reference.executor.target_type [*target_type]]]
    [Obtain type information for the target executor object. ]
  ]
  
  [
    [[link networking_ts.reference.executor.unspecified_bool_true [*unspecified_bool_true]]]
    []
  ]
  
  [
    [[link networking_ts.reference.executor._executor [*~executor]]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.executor.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.executor.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]


[section:context executor::context]


Obtain the underlying execution context. 


  execution_context & context() const;



[endsect]



[section:defer executor::defer]


Request the executor to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void defer(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object is executed according to the rules of the target executor object.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:dispatch executor::dispatch]


Request the executor to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void dispatch(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object is executed according to the rules of the target executor object.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]


[section:executor executor::executor]


Default constructor. 


  ``[link networking_ts.reference.executor.executor.overload1 executor]``();
  ``  [''''&raquo;''' [link networking_ts.reference.executor.executor.overload1 more...]]``


Construct from nullptr. 


  ``[link networking_ts.reference.executor.executor.overload2 executor]``(
      nullptr_t );
  ``  [''''&raquo;''' [link networking_ts.reference.executor.executor.overload2 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.executor.executor.overload3 executor]``(
      const executor & other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor.executor.overload3 more...]]``


Move constructor. 


  ``[link networking_ts.reference.executor.executor.overload4 executor]``(
      executor && other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor.executor.overload4 more...]]``


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename Executor>
  ``[link networking_ts.reference.executor.executor.overload5 executor]``(
      Executor e);
  ``  [''''&raquo;''' [link networking_ts.reference.executor.executor.overload5 more...]]``


Allocator-aware constructor to create a polymorphic wrapper for the specified executor. 


  template<
      typename Executor,
      typename Allocator>
  ``[link networking_ts.reference.executor.executor.overload6 executor]``(
      allocator_arg_t ,
      const Allocator & a,
      Executor e);
  ``  [''''&raquo;''' [link networking_ts.reference.executor.executor.overload6 more...]]``


[section:overload1 executor::executor (1 of 6 overloads)]


Default constructor. 


  executor();



[endsect]



[section:overload2 executor::executor (2 of 6 overloads)]


Construct from nullptr. 


  executor(
      nullptr_t );



[endsect]



[section:overload3 executor::executor (3 of 6 overloads)]


Copy constructor. 


  executor(
      const executor & other);



[endsect]



[section:overload4 executor::executor (4 of 6 overloads)]


Move constructor. 


  executor(
      executor && other);



[endsect]



[section:overload5 executor::executor (5 of 6 overloads)]


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename Executor>
  executor(
      Executor e);



[endsect]



[section:overload6 executor::executor (6 of 6 overloads)]


Allocator-aware constructor to create a polymorphic wrapper for the specified executor. 


  template<
      typename Executor,
      typename Allocator>
  executor(
      allocator_arg_t ,
      const Allocator & a,
      Executor e);



[endsect]


[endsect]


[section:on_work_finished executor::on_work_finished]


Inform the executor that some work is no longer outstanding. 


  void on_work_finished() const;



[endsect]



[section:on_work_started executor::on_work_started]


Inform the executor that it has some outstanding work to do. 


  void on_work_started() const;



[endsect]



[section:operator_unspecified_bool_type executor::operator unspecified_bool_type]


Operator to test if the executor contains a valid target. 


  operator unspecified_bool_type() const;



[endsect]



[section:operator_not__eq_ executor::operator!=]


Compare two executors for inequality. 


  friend bool operator!=(
      const executor & a,
      const executor & b);



[endsect]


[section:operator_eq_ executor::operator=]


Assignment operator. 


  executor & ``[link networking_ts.reference.executor.operator_eq_.overload1 operator=]``(
      const executor & other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor.operator_eq_.overload1 more...]]``



  executor & ``[link networking_ts.reference.executor.operator_eq_.overload2 operator=]``(
      executor && other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor.operator_eq_.overload2 more...]]``


Assignment operator for nullptr\_t. 


  executor & ``[link networking_ts.reference.executor.operator_eq_.overload3 operator=]``(
      nullptr_t );
  ``  [''''&raquo;''' [link networking_ts.reference.executor.operator_eq_.overload3 more...]]``


Assignment operator to create a polymorphic wrapper for the specified executor. 


  template<
      typename Executor>
  executor & ``[link networking_ts.reference.executor.operator_eq_.overload4 operator=]``(
      Executor && e);
  ``  [''''&raquo;''' [link networking_ts.reference.executor.operator_eq_.overload4 more...]]``


[section:overload1 executor::operator= (1 of 4 overloads)]


Assignment operator. 


  executor & operator=(
      const executor & other);



[endsect]



[section:overload2 executor::operator= (2 of 4 overloads)]



  executor & operator=(
      executor && other);



[endsect]



[section:overload3 executor::operator= (3 of 4 overloads)]


Assignment operator for nullptr\_t. 


  executor & operator=(
      nullptr_t );



[endsect]



[section:overload4 executor::operator= (4 of 4 overloads)]


Assignment operator to create a polymorphic wrapper for the specified executor. 


  template<
      typename Executor>
  executor & operator=(
      Executor && e);



[endsect]


[endsect]


[section:operator_eq__eq_ executor::operator==]


Compare two executors for equality. 


  friend bool operator==(
      const executor & a,
      const executor & b);



[endsect]



[section:post executor::post]


Request the executor to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void post(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object is executed according to the rules of the target executor object.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]


[section:target executor::target]


Obtain a pointer to the target executor object. 


  template<
      typename Executor>
  Executor * ``[link networking_ts.reference.executor.target.overload1 target]``();
  ``  [''''&raquo;''' [link networking_ts.reference.executor.target.overload1 more...]]``

  template<
      typename Executor>
  const Executor * ``[link networking_ts.reference.executor.target.overload2 target]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.executor.target.overload2 more...]]``


[section:overload1 executor::target (1 of 2 overloads)]


Obtain a pointer to the target executor object. 


  template<
      typename Executor>
  Executor * target();



[heading Return Value]
      
If `target_type() == typeid(T)`, a pointer to the stored executor target; otherwise, a null pointer. 




[endsect]



[section:overload2 executor::target (2 of 2 overloads)]


Obtain a pointer to the target executor object. 


  template<
      typename Executor>
  const Executor * target() const;



[heading Return Value]
      
If `target_type() == typeid(T)`, a pointer to the stored executor target; otherwise, a null pointer. 




[endsect]


[endsect]


[section:target_type executor::target_type]


Obtain type information for the target executor object. 


  const std::type_info & target_type() const;



[heading Return Value]
      
If `*this` has a target type of type `T`, `typeid(T)`; otherwise, `typeid(void)`. 




[endsect]



[section:unspecified_bool_true executor::unspecified_bool_true]



  static void unspecified_bool_true(
      unspecified_bool_type_t );



[endsect]



[section:unspecified_bool_type executor::unspecified_bool_type]



  typedef void(*) unspecified_bool_type;




[endsect]



[section:_executor executor::~executor]


Destructor. 


  ~executor();



[endsect]



[endsect]

[section:executor__unspecified_bool_type_t executor::unspecified_bool_type_t]



  struct unspecified_bool_type_t



[endsect]


[section:executor_arg executor_arg]


A special value, similar to std::nothrow, used to disambiguate constructors that accept executor arguments. 


  constexpr executor_arg_t executor_arg;


See std::experimental::net::executor\_arg\_t and std::experimental::net::uses\_executor for more information. 


[endsect]


[section:executor_arg_t executor_arg_t]


A special type, similar to std::nothrow\_t, used to disambiguate constructors that accept executor arguments. 


  struct executor_arg_t


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.executor_arg_t.executor_arg_t [*executor_arg_t]]]
    [Constructor. ]
  ]
  
]

The [link networking_ts.reference.executor_arg_t `executor_arg_t`] struct is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, some types have constructors with [link networking_ts.reference.executor_arg_t `executor_arg_t`] as the first argument, immediately followed by an argument of a type that satisfies the Executor type requirements. 


[section:executor_arg_t executor_arg_t::executor_arg_t]


Constructor. 


  constexpr executor_arg_t();



[endsect]



[endsect]

[section:executor_binder executor_binder]


A call wrapper type to bind an executor of type `Executor` to an object of type `T`. 


  template<
      typename T,
      typename Executor>
  class executor_binder


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.executor_binder.argument_type [*argument_type]]]
    [The type of the function's argument. ]
  
  ]

  [

    [[link networking_ts.reference.executor_binder.executor_type [*executor_type]]]
    [The type of the associated executor. ]
  
  ]

  [

    [[link networking_ts.reference.executor_binder.first_argument_type [*first_argument_type]]]
    [The type of the function's first argument. ]
  
  ]

  [

    [[link networking_ts.reference.executor_binder.result_type [*result_type]]]
    [The return type if a function. ]
  
  ]

  [

    [[link networking_ts.reference.executor_binder.second_argument_type [*second_argument_type]]]
    [The type of the function's second argument. ]
  
  ]

  [

    [[link networking_ts.reference.executor_binder.target_type [*target_type]]]
    [The type of the target object. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.executor_binder.executor_binder [*executor_binder]]]
    [Construct an executor wrapper for the specified object. 

     Copy constructor. 

     Construct a copy, but specify a different executor. 

     Construct a copy of a different executor wrapper type. 

     Construct a copy of a different executor wrapper type, but specify a different executor. 

     Move constructor. 

     Move construct the target object, but specify a different executor. 

     Move construct from a different executor wrapper type. 

     Move construct from a different executor wrapper type, but specify a different executor. ]
  ]
  
  [
    [[link networking_ts.reference.executor_binder.get [*get]]]
    [Obtain a reference to the target object. ]
  ]
  
  [
    [[link networking_ts.reference.executor_binder.get_executor [*get_executor]]]
    [Obtain the associated executor. ]
  ]
  
  [
    [[link networking_ts.reference.executor_binder.operator_lb__rb_ [*operator()]]]
    []
  ]
  
  [
    [[link networking_ts.reference.executor_binder._executor_binder [*~executor_binder]]]
    [Destructor. ]
  ]
  
]


[section:argument_type executor_binder::argument_type]


The type of the function's argument. 


  typedef see_below argument_type;



The type of `argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting a single argument, `argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `argument_type`, then `argument_type` is a synonym for `T::argument_type`;


* otherwise `argument_type` is not defined. 




[endsect]


[section:executor_binder executor_binder::executor_binder]


Construct an executor wrapper for the specified object. 


  template<
      typename U>
  ``[link networking_ts.reference.executor_binder.executor_binder.overload1 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      U && u);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.executor_binder.overload1 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.executor_binder.executor_binder.overload2 executor_binder]``(
      const executor_binder & other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.executor_binder.overload2 more...]]``


Construct a copy, but specify a different executor. 


  ``[link networking_ts.reference.executor_binder.executor_binder.overload3 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      const executor_binder & other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.executor_binder.overload3 more...]]``


Construct a copy of a different executor wrapper type. 


  template<
      typename U,
      typename OtherExecutor>
  ``[link networking_ts.reference.executor_binder.executor_binder.overload4 executor_binder]``(
      const executor_binder< U, OtherExecutor > & other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.executor_binder.overload4 more...]]``


Construct a copy of a different executor wrapper type, but specify a different executor. 


  template<
      typename U,
      typename OtherExecutor>
  ``[link networking_ts.reference.executor_binder.executor_binder.overload5 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      const executor_binder< U, OtherExecutor > & other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.executor_binder.overload5 more...]]``


Move constructor. 


  ``[link networking_ts.reference.executor_binder.executor_binder.overload6 executor_binder]``(
      executor_binder && other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.executor_binder.overload6 more...]]``


Move construct the target object, but specify a different executor. 


  ``[link networking_ts.reference.executor_binder.executor_binder.overload7 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      executor_binder && other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.executor_binder.overload7 more...]]``


Move construct from a different executor wrapper type. 


  template<
      typename U,
      typename OtherExecutor>
  ``[link networking_ts.reference.executor_binder.executor_binder.overload8 executor_binder]``(
      executor_binder< U, OtherExecutor > && other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.executor_binder.overload8 more...]]``


Move construct from a different executor wrapper type, but specify a different executor. 


  template<
      typename U,
      typename OtherExecutor>
  ``[link networking_ts.reference.executor_binder.executor_binder.overload9 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      executor_binder< U, OtherExecutor > && other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.executor_binder.overload9 more...]]``


[section:overload1 executor_binder::executor_binder (1 of 9 overloads)]


Construct an executor wrapper for the specified object. 


  template<
      typename U>
  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      U && u);


This constructor is only valid if the type `T` is constructible from type `U`. 


[endsect]



[section:overload2 executor_binder::executor_binder (2 of 9 overloads)]


Copy constructor. 


  executor_binder(
      const executor_binder & other);



[endsect]



[section:overload3 executor_binder::executor_binder (3 of 9 overloads)]


Construct a copy, but specify a different executor. 


  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      const executor_binder & other);



[endsect]



[section:overload4 executor_binder::executor_binder (4 of 9 overloads)]


Construct a copy of a different executor wrapper type. 


  template<
      typename U,
      typename OtherExecutor>
  executor_binder(
      const executor_binder< U, OtherExecutor > & other);


This constructor is only valid if the `Executor` type is constructible from type `OtherExecutor`, and the type `T` is constructible from type `U`. 


[endsect]



[section:overload5 executor_binder::executor_binder (5 of 9 overloads)]


Construct a copy of a different executor wrapper type, but specify a different executor. 


  template<
      typename U,
      typename OtherExecutor>
  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      const executor_binder< U, OtherExecutor > & other);


This constructor is only valid if the type `T` is constructible from type `U`. 


[endsect]



[section:overload6 executor_binder::executor_binder (6 of 9 overloads)]


Move constructor. 


  executor_binder(
      executor_binder && other);



[endsect]



[section:overload7 executor_binder::executor_binder (7 of 9 overloads)]


Move construct the target object, but specify a different executor. 


  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      executor_binder && other);



[endsect]



[section:overload8 executor_binder::executor_binder (8 of 9 overloads)]


Move construct from a different executor wrapper type. 


  template<
      typename U,
      typename OtherExecutor>
  executor_binder(
      executor_binder< U, OtherExecutor > && other);



[endsect]



[section:overload9 executor_binder::executor_binder (9 of 9 overloads)]


Move construct from a different executor wrapper type, but specify a different executor. 


  template<
      typename U,
      typename OtherExecutor>
  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      executor_binder< U, OtherExecutor > && other);



[endsect]


[endsect]


[section:executor_type executor_binder::executor_type]


The type of the associated executor. 


  typedef Executor executor_type;




[endsect]



[section:first_argument_type executor_binder::first_argument_type]


The type of the function's first argument. 


  typedef see_below first_argument_type;



The type of `first_argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting two arguments, `first_argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `first_argument_type`, then `first_argument_type` is a synonym for `T::first_argument_type`;


* otherwise `first_argument_type` is not defined. 




[endsect]


[section:get executor_binder::get]


Obtain a reference to the target object. 


  target_type & ``[link networking_ts.reference.executor_binder.get.overload1 get]``();
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.get.overload1 more...]]``

  const target_type & ``[link networking_ts.reference.executor_binder.get.overload2 get]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.get.overload2 more...]]``


[section:overload1 executor_binder::get (1 of 2 overloads)]


Obtain a reference to the target object. 


  target_type & get();



[endsect]



[section:overload2 executor_binder::get (2 of 2 overloads)]


Obtain a reference to the target object. 


  const target_type & get() const;



[endsect]


[endsect]


[section:get_executor executor_binder::get_executor]


Obtain the associated executor. 


  executor_type get_executor() const;



[endsect]


[section:operator_lb__rb_ executor_binder::operator()]



  template<
      typename... Args>
  auto ``[link networking_ts.reference.executor_binder.operator_lb__rb_.overload1 operator()]``(
      Args && ...);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.operator_lb__rb_.overload1 more...]]``

  template<
      typename... Args>
  auto ``[link networking_ts.reference.executor_binder.operator_lb__rb_.overload2 operator()]``(
      Args && ...) const;
  ``  [''''&raquo;''' [link networking_ts.reference.executor_binder.operator_lb__rb_.overload2 more...]]``


[section:overload1 executor_binder::operator() (1 of 2 overloads)]



  template<
      typename... Args>
  auto operator()(
      Args && ...);



[endsect]



[section:overload2 executor_binder::operator() (2 of 2 overloads)]



  template<
      typename... Args>
  auto operator()(
      Args && ...) const;



[endsect]


[endsect]


[section:result_type executor_binder::result_type]


The return type if a function. 


  typedef see_below result_type;



The type of `result_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to function type, `result_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `result_type`, then `result_type` is a synonym for `T::result_type`;


* otherwise `result_type` is not defined. 




[endsect]



[section:second_argument_type executor_binder::second_argument_type]


The type of the function's second argument. 


  typedef see_below second_argument_type;



The type of `second_argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting two arguments, `second_argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `first_argument_type`, then `second_argument_type` is a synonym for `T::second_argument_type`;


* otherwise `second_argument_type` is not defined. 




[endsect]



[section:target_type executor_binder::target_type]


The type of the target object. 


  typedef T target_type;




[endsect]



[section:_executor_binder executor_binder::~executor_binder]


Destructor. 


  ~executor_binder();



[endsect]



[endsect]

[section:executor_work_guard executor_work_guard]


An object of type `executor_work_guard` controls ownership of executor work within a scope. 


  template<
      typename Executor>
  class executor_work_guard


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.executor_work_guard.executor_type [*executor_type]]]
    [The underlying executor type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.executor_work_guard.executor_work_guard [*executor_work_guard]]]
    [Constructs a executor_work_guard object for the specified executor. 

     Copy constructor. 

     Move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.executor_work_guard.get_executor [*get_executor]]]
    [Obtain the associated executor. ]
  ]
  
  [
    [[link networking_ts.reference.executor_work_guard.owns_work [*owns_work]]]
    [Whether the executor_work_guard object owns some outstanding work. ]
  ]
  
  [
    [[link networking_ts.reference.executor_work_guard.reset [*reset]]]
    [Indicate that the work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.executor_work_guard._executor_work_guard [*~executor_work_guard]]]
    [Destructor. ]
  ]
  
]


[section:executor_type executor_work_guard::executor_type]


The underlying executor type. 


  typedef Executor executor_type;




[endsect]


[section:executor_work_guard executor_work_guard::executor_work_guard]


Constructs a `executor_work_guard` object for the specified executor. 


  explicit ``[link networking_ts.reference.executor_work_guard.executor_work_guard.overload1 executor_work_guard]``(
      const executor_type & e);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_work_guard.executor_work_guard.overload1 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.executor_work_guard.executor_work_guard.overload2 executor_work_guard]``(
      const executor_work_guard & other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_work_guard.executor_work_guard.overload2 more...]]``


Move constructor. 


  ``[link networking_ts.reference.executor_work_guard.executor_work_guard.overload3 executor_work_guard]``(
      executor_work_guard && other);
  ``  [''''&raquo;''' [link networking_ts.reference.executor_work_guard.executor_work_guard.overload3 more...]]``


[section:overload1 executor_work_guard::executor_work_guard (1 of 3 overloads)]


Constructs a `executor_work_guard` object for the specified executor. 


  executor_work_guard(
      const executor_type & e);


Stores a copy of `e` and calls `on_work_started()` on it. 


[endsect]



[section:overload2 executor_work_guard::executor_work_guard (2 of 3 overloads)]


Copy constructor. 


  executor_work_guard(
      const executor_work_guard & other);



[endsect]



[section:overload3 executor_work_guard::executor_work_guard (3 of 3 overloads)]


Move constructor. 


  executor_work_guard(
      executor_work_guard && other);



[endsect]


[endsect]


[section:get_executor executor_work_guard::get_executor]


Obtain the associated executor. 


  executor_type get_executor() const;



[endsect]



[section:owns_work executor_work_guard::owns_work]


Whether the [link networking_ts.reference.executor_work_guard `executor_work_guard`] object owns some outstanding work. 


  bool owns_work() const;



[endsect]



[section:reset executor_work_guard::reset]


Indicate that the work is no longer outstanding. 


  void reset();



[endsect]



[section:_executor_work_guard executor_work_guard::~executor_work_guard]


Destructor. 


  ~executor_work_guard();


Unless the object has already been reset, or is in a moved-from state, calls `on_work_finished()` on the stored executor. 


[endsect]



[endsect]

[section:get_associated_allocator get_associated_allocator]


Helper function to obtain an object's associated allocator. 

    
  template<
      typename T>
  associated_allocator< T >::type ``[link networking_ts.reference.get_associated_allocator.overload1 get_associated_allocator]``(
      const T & t);
  ``  [''''&raquo;''' [link networking_ts.reference.get_associated_allocator.overload1 more...]]``

  template<
      typename T,
      typename Allocator>
  associated_allocator< T, Allocator >::type ``[link networking_ts.reference.get_associated_allocator.overload2 get_associated_allocator]``(
      const T & t,
      const Allocator & a);
  ``  [''''&raquo;''' [link networking_ts.reference.get_associated_allocator.overload2 more...]]``


[section:overload1 get_associated_allocator (1 of 2 overloads)]


Helper function to obtain an object's associated allocator. 


  template<
      typename T>
  associated_allocator< T >::type get_associated_allocator(
      const T & t);



[heading Return Value]
      
`associated_allocator<T>::get(t)` 




[endsect]



[section:overload2 get_associated_allocator (2 of 2 overloads)]


Helper function to obtain an object's associated allocator. 


  template<
      typename T,
      typename Allocator>
  associated_allocator< T, Allocator >::type get_associated_allocator(
      const T & t,
      const Allocator & a);



[heading Return Value]
      
`associated_allocator<T, Allocator>::get(t, a)` 




[endsect]


[endsect]

[section:get_associated_executor get_associated_executor]


Helper function to obtain an object's associated executor. 

    
  template<
      typename T>
  associated_executor< T >::type ``[link networking_ts.reference.get_associated_executor.overload1 get_associated_executor]``(
      const T & t);
  ``  [''''&raquo;''' [link networking_ts.reference.get_associated_executor.overload1 more...]]``

  template<
      typename T,
      typename Executor>
  associated_executor< T, Executor >::type ``[link networking_ts.reference.get_associated_executor.overload2 get_associated_executor]``(
      const T & t,
      const Executor & ex,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.get_associated_executor.overload2 more...]]``

  template<
      typename T,
      typename ExecutionContext>
  associated_executor< T, typename ExecutionContext::executor_type >::type ``[link networking_ts.reference.get_associated_executor.overload3 get_associated_executor]``(
      const T & t,
      ExecutionContext & ctx,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.get_associated_executor.overload3 more...]]``


[section:overload1 get_associated_executor (1 of 3 overloads)]


Helper function to obtain an object's associated executor. 


  template<
      typename T>
  associated_executor< T >::type get_associated_executor(
      const T & t);



[heading Return Value]
      
`associated_executor<T>::get(t)` 




[endsect]



[section:overload2 get_associated_executor (2 of 3 overloads)]


Helper function to obtain an object's associated executor. 


  template<
      typename T,
      typename Executor>
  associated_executor< T, Executor >::type get_associated_executor(
      const T & t,
      const Executor & ex,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);



[heading Return Value]
      
`associated_executor<T, Executor>::get(t, ex)` 




[endsect]



[section:overload3 get_associated_executor (3 of 3 overloads)]


Helper function to obtain an object's associated executor. 


  template<
      typename T,
      typename ExecutionContext>
  associated_executor< T, typename ExecutionContext::executor_type >::type get_associated_executor(
      const T & t,
      ExecutionContext & ctx,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);



[heading Return Value]
      
`associated_executor<T, typename ExecutionContext::executor_type>get(t, ctx.get_executor())` 




[endsect]


[endsect]

[section:handler_type handler_type]


(Deprecated: Use two-parameter version of [link networking_ts.reference.async_result `async_result`].) Default handler type traits provided for all completion token types. 


  template<
      typename CompletionToken,
      typename Signature,
      typename  = void>
  struct handler_type


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.handler_type.type [*type]]]
    [The handler type for the specific signature. ]
  
  ]

]

The [link networking_ts.reference.handler_type `handler_type`] traits class is used for determining the concrete handler type to be used for an asynchronous operation. It allows the handler type to be determined at the point where the specific completion handler signature is known.

This template may be specialised for user-defined completion token types. 


[section:type handler_type::type]


The handler type for the specific signature. 


  typedef conditional< is_same< CompletionToken, typename decay< CompletionToken >::type >::value, decay< CompletionToken >, handler_type< typename decay< CompletionToken >::type, Signature > >::type::type type;




[endsect]



[endsect]


[section:high_resolution_timer high_resolution_timer]


Typedef for a timer based on the high resolution clock. 


  typedef basic_waitable_timer< chrono::high_resolution_clock > high_resolution_timer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_waitable_timer.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.duration [*duration]]]
    [The duration type of the clock. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.time_point [*time_point]]]
    [The time point type of the clock. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.traits_type [*traits_type]]]
    [The wait traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_waitable_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.basic_waitable_timer [*basic_waitable_timer]]]
    [Constructor. 

     Constructor to set a particular expiry time as an absolute time. 

     Constructor to set a particular expiry time relative to now. 

     Move-construct a basic_waitable_timer from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expires_after [*expires_after]]]
    [Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expires_at [*expires_at]]]
    [Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expiry [*expiry]]]
    [Get the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_waitable_timer from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer._basic_waitable_timer [*~basic_waitable_timer]]]
    [Destroys the timer. ]
  ]
  
]

The [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the std::experimental::net::steady\_timer, std::experimental::net::system\_timer or std::experimental::net::high\_resolution\_timer typedefs.


[heading Remarks]
      
This waitable timer functionality is for use with the C++11 standard library's `<chrono>` facility, or with the Boost.Chrono library.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait (C++11): 

   // Construct a timer without setting an expiry time.
   std::experimental::net::steady_timer timer(io_context);

   // Set an expiry time relative to now.
   timer.expires_after(std::chrono::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait (C++11): 

   void handler(const std::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   std::experimental::net::steady_timer timer(io_context,
       std::chrono::steady_clock::now() + std::chrono::seconds(60));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active waitable timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_after(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const std::error_code& e)
   {
     if (e != std::experimental::net::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The std::experimental::net::basic\_waitable\_timer::expires\_after() function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the std::error\_code passed to it contains the value std::experimental::net::error::operation\_aborted. 




This typedef uses the C++11 `<chrono>` standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] template directly: 

   typedef basic_waitable_timer<boost::chrono::high_resolution_clock> timer;





[endsect]


[section:invalid_service_owner invalid_service_owner]


Exception thrown when trying to add a service object to an [link networking_ts.reference.execution_context `execution_context`] where the service has a different owner. 


  class invalid_service_owner


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.invalid_service_owner.invalid_service_owner [*invalid_service_owner]]]
    []
  ]
  
]


[section:invalid_service_owner invalid_service_owner::invalid_service_owner]



  invalid_service_owner();



[endsect]



[endsect]

[section:io_context io_context]


Provides core I/O functionality. 


  class io_context :
    public execution_context


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.io_context.count_type [*count_type]]]
    [The type used to count the number of handlers executed by the context. ]
  
  ]

  [

    [[link networking_ts.reference.io_context.fork_event [*fork_event]]]
    [Fork-related event notifications. ]
  
  ]

  [

    [[link networking_ts.reference.io_context__executor_type [*executor_type]]]
    [Executor used to submit functions to an io_context. ]
  
  ]

  [

    [[link networking_ts.reference.io_context__service [*service]]]
    [Base class for all io_context services. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context.get_executor [*get_executor]]]
    [Obtains the executor associated with the io_context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.io_context [*io_context]]]
    [Constructor. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.notify_fork [*notify_fork]]]
    [Notify the execution_context of a fork-related event. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.poll [*poll]]]
    [Run the io_context object's event processing loop to execute ready handlers. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.poll_one [*poll_one]]]
    [Run the io_context object's event processing loop to execute one ready handler. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.restart [*restart]]]
    [Restart the io_context in preparation for a subsequent run() invocation. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.run [*run]]]
    [Run the io_context object's event processing loop. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.run_for [*run_for]]]
    [Run the io_context object's event processing loop for a specified duration. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.run_one [*run_one]]]
    [Run the io_context object's event processing loop to execute at most one handler. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.run_one_for [*run_one_for]]]
    [Run the io_context object's event processing loop for a specified duration to execute at most one handler. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.run_one_until [*run_one_until]]]
    [Run the io_context object's event processing loop until a specified time to execute at most one handler. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.run_until [*run_until]]]
    [Run the io_context object's event processing loop until a specified time. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.stop [*stop]]]
    [Stop the io_context object's event processing loop. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.stopped [*stopped]]]
    [Determine whether the io_context object has been stopped. ]
  ]
  
  [
    [[link networking_ts.reference.io_context._io_context [*~io_context]]]
    [Destructor. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context.destroy [*destroy]]]
    [Destroys all services in the context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.shutdown [*shutdown]]]
    [Shuts down all services in the context. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context.add_service [*add_service]]]
    [(Deprecated: Use make_service().) Add a service object to the execution_context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.has_service [*has_service]]]
    [Determine if an execution_context contains a specified service type. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.make_service [*make_service]]]
    [Creates a service object and adds it to the execution_context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context.use_service [*use_service]]]
    [

     Obtain the service object corresponding to the given type. ]
  ]
  
]

The [link networking_ts.reference.io_context `io_context`] class provides the core I/O functionality for users of the asynchronous I/O objects, including:


* std::experimental::net::ip::tcp::socket 

* std::experimental::net::ip::tcp::acceptor 

* std::experimental::net::ip::udp::socket 

* std::experimental::net::deadline\_timer.

The [link networking_ts.reference.io_context `io_context`] class also includes facilities intended for developers of custom asynchronous services.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Safe, with the specific exceptions of the `restart()` and `notify_fork()` functions. Calling `restart()` while there are unfinished `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` calls results in undefined behaviour. The `notify_fork()` function should not be called while any [link networking_ts.reference.io_context `io_context`] function, or any function on an I/O object that is associated with the [link networking_ts.reference.io_context `io_context`], is being called in another thread.



[heading Synchronous and asynchronous operations]
  


Synchronous operations on I/O objects implicitly run the [link networking_ts.reference.io_context `io_context`] object for an individual operation. The [link networking_ts.reference.io_context `io_context`] functions `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` must be called for the [link networking_ts.reference.io_context `io_context`] to perform asynchronous operations on behalf of a C++ program. Notification that an asynchronous operation has completed is delivered by invocation of the associated handler. Handlers are invoked only by a thread that is currently calling any overload of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` for the [link networking_ts.reference.io_context `io_context`].


[heading Effect of exceptions thrown from handlers]
  


If an exception is thrown from a handler, the exception is allowed to propagate through the throwing thread's invocation of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()`. No other threads that are calling any of these functions are affected. It is then the responsibility of the application to catch the exception.

After the exception has been caught, the `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` call may be restarted [*without] the need for an intervening call to `restart()`. This allows the thread to rejoin the [link networking_ts.reference.io_context `io_context`] object's thread pool without impacting any other threads in the pool.

For example:



   std::experimental::net::io_context io_context;
   ...
   for (;;)
   {
     try
     {
       io_context.run();
       break; // run() exited normally
     }
     catch (my_exception& e)
     {
       // Deal with exception as appropriate.
     }
   }





[heading Stopping the io_context from running out of work]
  


Some applications may need to prevent an [link networking_ts.reference.io_context `io_context`] object's `run()` call from returning when there is no more work to do. For example, the [link networking_ts.reference.io_context `io_context`] may be being run in a background thread that is launched prior to the application's asynchronous operations. The `run()` call may be kept running by creating an object of type std::experimental::net::executor\_work\_guard<io\_context::executor\_type>:



   std::experimental::net::io_context io_context;
   std::experimental::net::executor_work_guard<std::experimental::net::io_context::executor_type>
     = std::experimental::net::make_work_guard(io_context);
   ... 




To effect a shutdown, the application will then need to call the [link networking_ts.reference.io_context `io_context`] object's `stop()` member function. This will cause the [link networking_ts.reference.io_context `io_context`] `run()` call to return as soon as possible, abandoning unfinished operations and without permitting ready handlers to be dispatched.

Alternatively, if the application requires that all operations and handlers be allowed to finish normally, the work object may be explicitly reset.



   std::experimental::net::io_context io_context;
   std::experimental::net::executor_work_guard<std::experimental::net::io_context::executor_type>
     = std::experimental::net::make_work_guard(io_context);
   ...
   work.reset(); // Allow run() to exit. 





[section:add_service io_context::add_service]


['Inherited from execution_context.]


(Deprecated: Use `make_service()`.) Add a service object to the [link networking_ts.reference.execution_context `execution_context`]. 


  template<
      typename Service>
  friend void add_service(
      execution_context & e,
      Service * svc);


This function is used to add a service to the [link networking_ts.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

[[svc][The service object. On success, ownership of the service object is transferred to the [link networking_ts.reference.execution_context `execution_context`]. When the [link networking_ts.reference.execution_context `execution_context`] object is destroyed, it will destroy the service object by performing:
``
   delete static_cast<execution_context::service*>(svc) 
``
]]

]


[heading Exceptions]
    

[variablelist
  
[[std::experimental::net::service_already_exists][Thrown if a service of the given type is already present in the [link networking_ts.reference.execution_context `execution_context`].]]

[[std::experimental::net::invalid_service_owner][Thrown if the service's owning [link networking_ts.reference.execution_context `execution_context`] is not the [link networking_ts.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]

]




[endsect]



[section:count_type io_context::count_type]


The type used to count the number of handlers executed by the context. 


  typedef std::size_t count_type;




[endsect]



[section:destroy io_context::destroy]


['Inherited from execution_context.]


Destroys all services in the context. 


  void destroy();


This function is implemented as follows:


* For each service object `svc` in the [link networking_ts.reference.execution_context `execution_context`] set, in reverse order * of the beginning of service object lifetime, performs `delete static_cast<execution_context::service*>(svc)`. 




[endsect]



[section:fork_event io_context::fork_event]


['Inherited from execution_context.]


Fork-related event notifications. 


  enum fork_event


[heading Values]
[variablelist

  [
    [fork_prepare]
    [Notify the context that the process is about to fork. ]
  ]

  [
    [fork_parent]
    [Notify the context that the process has forked and is the parent. ]
  ]

  [
    [fork_child]
    [Notify the context that the process has forked and is the child. ]
  ]

]



[endsect]



[section:get_executor io_context::get_executor]


Obtains the executor associated with the [link networking_ts.reference.io_context `io_context`]. 


  executor_type get_executor();



[endsect]



[section:has_service io_context::has_service]


['Inherited from execution_context.]


Determine if an [link networking_ts.reference.execution_context `execution_context`] contains a specified service type. 


  template<
      typename Service>
  friend bool has_service(
      execution_context & e);


This function is used to determine whether the [link networking_ts.reference.execution_context `execution_context`] contains a service object corresponding to the given service type.


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
A boolean indicating whether the [link networking_ts.reference.execution_context `execution_context`] contains the service. 




[endsect]


[section:io_context io_context::io_context]


Constructor. 


  ``[link networking_ts.reference.io_context.io_context.overload1 io_context]``();
  ``  [''''&raquo;''' [link networking_ts.reference.io_context.io_context.overload1 more...]]``

  explicit ``[link networking_ts.reference.io_context.io_context.overload2 io_context]``(
      int concurrency_hint);
  ``  [''''&raquo;''' [link networking_ts.reference.io_context.io_context.overload2 more...]]``


[section:overload1 io_context::io_context (1 of 2 overloads)]


Constructor. 


  io_context();



[endsect]



[section:overload2 io_context::io_context (2 of 2 overloads)]


Constructor. 


  io_context(
      int concurrency_hint);


Construct with a hint about the required level of concurrency.


[heading Parameters]
    

[variablelist
  
[[concurrency_hint][A suggestion to the implementation on how many threads it should allow to run simultaneously. ]]

]




[endsect]


[endsect]


[section:make_service io_context::make_service]


['Inherited from execution_context.]


Creates a service object and adds it to the [link networking_ts.reference.execution_context `execution_context`]. 


  template<
      typename Service,
      typename... Args>
  friend Service & make_service(
      execution_context & e,
      Args &&... args);


This function is used to add a service to the [link networking_ts.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

[[args][Zero or more arguments to be passed to the service constructor.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::experimental::net::service_already_exists][Thrown if a service of the given type is already present in the [link networking_ts.reference.execution_context `execution_context`]. ]]

]




[endsect]



[section:notify_fork io_context::notify_fork]


['Inherited from execution_context.]


Notify the [link networking_ts.reference.execution_context `execution_context`] of a fork-related event. 


  void notify_fork(
      fork_event event);


This function is used to inform the [link networking_ts.reference.execution_context `execution_context`] that the process is about to fork, or has just forked. This allows the [link networking_ts.reference.execution_context `execution_context`], and the services it contains, to perform any necessary housekeeping to ensure correct operation following a fork.

This function must not be called while any other [link networking_ts.reference.execution_context `execution_context`] function, or any function associated with the execution\_context's derived class, is being called in another thread. It is, however, safe to call this function from within a completion handler, provided no other thread is accessing the [link networking_ts.reference.execution_context `execution_context`] or its derived class.


[heading Parameters]
    

[variablelist
  
[[event][A fork-related event.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the notification fails the [link networking_ts.reference.execution_context `execution_context`] object should no longer be used and should be destroyed.]]

]


[heading Example]
  
The following code illustrates how to incorporate the `notify_fork()` function: 

   my_execution_context.notify_fork(execution_context::fork_prepare);
   if (fork() == 0)
   {
     // This is the child process.
     my_execution_context.notify_fork(execution_context::fork_child);
   }
   else
   {
     // This is the parent process.
     my_execution_context.notify_fork(execution_context::fork_parent);
   } 





[heading Remarks]
      
For each service object `svc` in the [link networking_ts.reference.execution_context `execution_context`] set, performs `svc->notify_fork();`. When processing the fork\_prepare event, services are visited in reverse order of the beginning of service object lifetime. Otherwise, services are visited in order of the beginning of service object lifetime. 




[endsect]



[section:poll io_context::poll]


Run the [link networking_ts.reference.io_context `io_context`] object's event processing loop to execute ready handlers. 


  count_type poll();


The `poll()` function runs handlers that are ready to run, without blocking, until the [link networking_ts.reference.io_context `io_context`] has been stopped or there are no more ready handlers.


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:poll_one io_context::poll_one]


Run the [link networking_ts.reference.io_context `io_context`] object's event processing loop to execute one ready handler. 


  count_type poll_one();


The `poll_one()` function runs at most one handler that is ready to run, without blocking.


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:restart io_context::restart]


Restart the [link networking_ts.reference.io_context `io_context`] in preparation for a subsequent `run()` invocation. 


  void restart();


This function must be called prior to any second or later set of invocations of the `run()`, `run_one()`, `poll()` or `poll_one()` functions when a previous invocation of these functions returned due to the [link networking_ts.reference.io_context `io_context`] being stopped or running out of work. After a call to `restart()`, the [link networking_ts.reference.io_context `io_context`] object's `stopped()` function will return `false`.

This function must not be called while there are any unfinished calls to the `run()`, `run_one()`, `poll()` or `poll_one()` functions. 


[endsect]



[section:run io_context::run]


Run the [link networking_ts.reference.io_context `io_context`] object's event processing loop. 


  count_type run();


The `run()` function blocks until all work has finished and there are no more handlers to be dispatched, or until the [link networking_ts.reference.io_context `io_context`] has been stopped.

Multiple threads may call the `run()` function to set up a pool of threads from which the [link networking_ts.reference.io_context `io_context`] may execute handlers. All threads that are waiting in the pool are equivalent and the [link networking_ts.reference.io_context `io_context`] may choose any one of them to invoke a handler.

A normal exit from the `run()` function implies that the [link networking_ts.reference.io_context `io_context`] object is stopped (the `stopped()` function returns `true`). Subsequent calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately unless there is a prior call to `restart()`.


[heading Return Value]
      
The number of handlers that were executed.


[heading Remarks]
      
Calling the `run()` function from a thread that is currently calling one of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` on the same [link networking_ts.reference.io_context `io_context`] object may introduce the potential for deadlock. It is the caller's reponsibility to avoid this.

The `poll()` function may also be used to dispatch ready handlers, but without blocking. 


[endsect]



[section:run_for io_context::run_for]


Run the [link networking_ts.reference.io_context `io_context`] object's event processing loop for a specified duration. 


  template<
      typename Rep,
      typename Period>
  std::size_t run_for(
      const chrono::duration< Rep, Period > & rel_time);


The `run_for()` function blocks until all work has finished and there are no more handlers to be dispatched, until the [link networking_ts.reference.io_context `io_context`] has been stopped, or until the specified duration has elapsed.


[heading Parameters]
    

[variablelist
  
[[rel_time][The duration for which the call may block.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:run_one io_context::run_one]


Run the [link networking_ts.reference.io_context `io_context`] object's event processing loop to execute at most one handler. 


  count_type run_one();


The `run_one()` function blocks until one handler has been dispatched, or until the [link networking_ts.reference.io_context `io_context`] has been stopped.


[heading Return Value]
      
The number of handlers that were executed. A zero return value implies that the [link networking_ts.reference.io_context `io_context`] object is stopped (the `stopped()` function returns `true`). Subsequent calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately unless there is a prior call to `restart()`.


[heading Remarks]
      
Calling the `run_one()` function from a thread that is currently calling one of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` on the same [link networking_ts.reference.io_context `io_context`] object may introduce the potential for deadlock. It is the caller's reponsibility to avoid this. 




[endsect]



[section:run_one_for io_context::run_one_for]


Run the [link networking_ts.reference.io_context `io_context`] object's event processing loop for a specified duration to execute at most one handler. 


  template<
      typename Rep,
      typename Period>
  std::size_t run_one_for(
      const chrono::duration< Rep, Period > & rel_time);


The `run_one_for()` function blocks until one handler has been dispatched, until the [link networking_ts.reference.io_context `io_context`] has been stopped, or until the specified duration has elapsed.


[heading Parameters]
    

[variablelist
  
[[rel_time][The duration for which the call may block.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:run_one_until io_context::run_one_until]


Run the [link networking_ts.reference.io_context `io_context`] object's event processing loop until a specified time to execute at most one handler. 


  template<
      typename Clock,
      typename Duration>
  std::size_t run_one_until(
      const chrono::time_point< Clock, Duration > & abs_time);


The `run_one_until()` function blocks until one handler has been dispatched, until the [link networking_ts.reference.io_context `io_context`] has been stopped, or until the specified time has been reached.


[heading Parameters]
    

[variablelist
  
[[abs_time][The time point until which the call may block.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:run_until io_context::run_until]


Run the [link networking_ts.reference.io_context `io_context`] object's event processing loop until a specified time. 


  template<
      typename Clock,
      typename Duration>
  std::size_t run_until(
      const chrono::time_point< Clock, Duration > & abs_time);


The `run_until()` function blocks until all work has finished and there are no more handlers to be dispatched, until the [link networking_ts.reference.io_context `io_context`] has been stopped, or until the specified time has been reached.


[heading Parameters]
    

[variablelist
  
[[abs_time][The time point until which the call may block.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:shutdown io_context::shutdown]


['Inherited from execution_context.]


Shuts down all services in the context. 


  void shutdown();


This function is implemented as follows:


* For each service object `svc` in the [link networking_ts.reference.execution_context `execution_context`] set, in reverse order of the beginning of service object lifetime, performs `svc->shutdown()`. 




[endsect]



[section:stop io_context::stop]


Stop the [link networking_ts.reference.io_context `io_context`] object's event processing loop. 


  void stop();


This function does not block, but instead simply signals the [link networking_ts.reference.io_context `io_context`] to stop. All invocations of its `run()` or `run_one()` member functions should return as soon as possible. Subsequent calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately until `restart()` is called. 


[endsect]



[section:stopped io_context::stopped]


Determine whether the [link networking_ts.reference.io_context `io_context`] object has been stopped. 


  bool stopped() const;


This function is used to determine whether an [link networking_ts.reference.io_context `io_context`] object has been stopped, either through an explicit call to `stop()`, or due to running out of work. When an [link networking_ts.reference.io_context `io_context`] object is stopped, calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately without invoking any handlers.


[heading Return Value]
      
`true` if the [link networking_ts.reference.io_context `io_context`] object is stopped, otherwise `false`. 




[endsect]


[section:use_service io_context::use_service]



  template<
      typename Service>
  friend Service & ``[link networking_ts.reference.io_context.use_service.overload1 use_service]``(
      io_context & ioc);
  ``  [''''&raquo;''' [link networking_ts.reference.io_context.use_service.overload1 more...]]``


Obtain the service object corresponding to the given type. 


  template<
      typename Service>
  friend Service & ``[link networking_ts.reference.io_context.use_service.overload2 use_service]``(
      execution_context & e);
  ``  [''''&raquo;''' [link networking_ts.reference.io_context.use_service.overload2 more...]]``


[section:overload1 io_context::use_service (1 of 2 overloads)]



  template<
      typename Service>
  friend Service & use_service(
      io_context & ioc);



[endsect]



[section:overload2 io_context::use_service (2 of 2 overloads)]


['Inherited from execution_context.]


Obtain the service object corresponding to the given type. 


  template<
      typename Service>
  friend Service & use_service(
      execution_context & e);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link networking_ts.reference.execution_context `execution_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. 




[endsect]


[endsect]


[section:_io_context io_context::~io_context]


Destructor. 


  ~io_context();


On destruction, the [link networking_ts.reference.io_context `io_context`] performs the following sequence of operations:


* For each service object `svc` in the [link networking_ts.reference.io_context `io_context`] set, in reverse order of the beginning of service object lifetime, performs `svc->shutdown()`.


* Uninvoked handler objects that were scheduled for deferred invocation on the [link networking_ts.reference.io_context `io_context`], or any associated strand, are destroyed.


* For each service object `svc` in the [link networking_ts.reference.io_context `io_context`] set, in reverse order of the beginning of service object lifetime, performs `delete static_cast<io_context::service*>(svc)`.


[heading Remarks]
      
The destruction sequence described above permits programs to simplify their resource management by using `shared_ptr<>`. Where an object's lifetime is tied to the lifetime of a connection (or some other sequence of asynchronous operations), a `shared_ptr` to the object would be bound into the handlers for all asynchronous operations associated with it. This works as follows:


* When a single connection ends, all associated asynchronous operations complete. The corresponding handler objects are destroyed, and all `shared_ptr` references to the objects are destroyed.


* To shut down the whole program, the [link networking_ts.reference.io_context `io_context`] function `stop()` is called to terminate any `run()` calls as soon as possible. The [link networking_ts.reference.io_context `io_context`] destructor defined above destroys all handlers, causing all `shared_ptr` references to all connection objects to be destroyed. 




[endsect]



[endsect]

[section:io_context__executor_type io_context::executor_type]


Executor used to submit functions to an [link networking_ts.reference.io_context `io_context`]. 


  class executor_type


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.defer [*defer]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.dispatch [*dispatch]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_finished [*on_work_finished]]]
    [Inform the io_context that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_started [*on_work_started]]]
    [Inform the io_context that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.post [*post]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the io_context is running in the current thread. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]


[section:context io_context::executor_type::context]


Obtain the underlying execution context. 


  io_context & context() const;



[endsect]



[section:defer io_context::executor_type::defer]


Request the [link networking_ts.reference.io_context `io_context`] to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void defer(
      Function && f,
      const Allocator & a) const;


This function is used to ask the [link networking_ts.reference.io_context `io_context`] to execute the given function object. The function object will never be executed inside `defer()`. Instead, it will be scheduled to run on the [link networking_ts.reference.io_context `io_context`].

If the current thread belongs to the [link networking_ts.reference.io_context `io_context`], `defer()` will delay scheduling the function object until the current thread returns control to the pool.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:dispatch io_context::executor_type::dispatch]


Request the [link networking_ts.reference.io_context `io_context`] to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void dispatch(
      Function && f,
      const Allocator & a) const;


This function is used to ask the [link networking_ts.reference.io_context `io_context`] to execute the given function object. If the current thread is running the [link networking_ts.reference.io_context `io_context`], `dispatch()` executes the function before returning. Otherwise, the function will be scheduled to run on the [link networking_ts.reference.io_context `io_context`].


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:on_work_finished io_context::executor_type::on_work_finished]


Inform the [link networking_ts.reference.io_context `io_context`] that some work is no longer outstanding. 


  void on_work_finished() const;


This function is used to inform the [link networking_ts.reference.io_context `io_context`] that some work has finished. Once the count of unfinished work reaches zero, the [link networking_ts.reference.io_context `io_context`] is stopped and the `run()` and `run_one()` functions may exit. 


[endsect]



[section:on_work_started io_context::executor_type::on_work_started]


Inform the [link networking_ts.reference.io_context `io_context`] that it has some outstanding work to do. 


  void on_work_started() const;


This function is used to inform the [link networking_ts.reference.io_context `io_context`] that some work has begun. This ensures that the io\_context's `run()` and `run_one()` functions do not exit while the work is underway. 


[endsect]



[section:operator_not__eq_ io_context::executor_type::operator!=]


Compare two executors for inequality. 


  friend bool operator!=(
      const executor_type & a,
      const executor_type & b);


Two executors are equal if they refer to the same underlying [link networking_ts.reference.io_context `io_context`]. 


[endsect]



[section:operator_eq__eq_ io_context::executor_type::operator==]


Compare two executors for equality. 


  friend bool operator==(
      const executor_type & a,
      const executor_type & b);


Two executors are equal if they refer to the same underlying [link networking_ts.reference.io_context `io_context`]. 


[endsect]



[section:post io_context::executor_type::post]


Request the [link networking_ts.reference.io_context `io_context`] to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void post(
      Function && f,
      const Allocator & a) const;


This function is used to ask the [link networking_ts.reference.io_context `io_context`] to execute the given function object. The function object will never be executed inside `post()`. Instead, it will be scheduled to run on the [link networking_ts.reference.io_context `io_context`].


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:running_in_this_thread io_context::executor_type::running_in_this_thread]


Determine whether the [link networking_ts.reference.io_context `io_context`] is running in the current thread. 


  bool running_in_this_thread() const;



[heading Return Value]
      
`true` if the current thread is running the [link networking_ts.reference.io_context `io_context`]. Otherwise returns `false`. 




[endsect]



[endsect]

[section:io_context__service io_context::service]


Base class for all [link networking_ts.reference.io_context `io_context`] services. 


  class service


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__service.get_io_context [*get_io_context]]]
    [Get the io_context object that owns the service. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__service.service [*service]]]
    [Constructor. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__service._service [*~service]]]
    [Destructor. ]
  ]
  
]


[section:get_io_context io_context::service::get_io_context]


Get the [link networking_ts.reference.io_context `io_context`] object that owns the service. 


  std::experimental::net::io_context & get_io_context();



[endsect]



[section:service io_context::service::service]


Constructor. 


  service(
      std::experimental::net::io_context & owner);



[heading Parameters]
    

[variablelist
  
[[owner][The [link networking_ts.reference.io_context `io_context`] object that owns the service. ]]

]




[endsect]



[section:_service io_context::service::~service]


Destructor. 


  virtual ~service();



[endsect]



[endsect]

[section:ip__address ip::address]


Implements version-independent IP addresses. 


  class address


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address.address [*address]]]
    [Default constructor. 

     Construct an address from an IPv4 address. 

     Construct an address from an IPv6 address. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.is_v4 [*is_v4]]]
    [Get whether the address is an IP version 4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.is_v6 [*is_v6]]]
    [Get whether the address is an IP version 6 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.operator_eq_ [*operator=]]]
    [Assign from another address. 

     Assign from an IPv4 address. 

     Assign from an IPv6 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.to_string [*to_string]]]
    [Get the address as a string. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.to_v4 [*to_v4]]]
    [Get the address as an IP version 4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.to_v6 [*to_v6]]]
    [Get the address as an IP version 6 address. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address.make_address [*make_address]]]
    [Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. ]
  ]
  
]

The std::experimental::net::ip::address class provides the ability to use either IP version 4 or version 6 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:address ip::address::address]


Default constructor. 


  ``[link networking_ts.reference.ip__address.address.overload1 address]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.address.overload1 more...]]``


Construct an address from an IPv4 address. 


  ``[link networking_ts.reference.ip__address.address.overload2 address]``(
      const std::experimental::net::ip::address_v4 & ipv4_address);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.address.overload2 more...]]``


Construct an address from an IPv6 address. 


  ``[link networking_ts.reference.ip__address.address.overload3 address]``(
      const std::experimental::net::ip::address_v6 & ipv6_address);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.address.overload3 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__address.address.overload4 address]``(
      const address & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.address.overload4 more...]]``


[section:overload1 ip::address::address (1 of 4 overloads)]


Default constructor. 


  address();



[endsect]



[section:overload2 ip::address::address (2 of 4 overloads)]


Construct an address from an IPv4 address. 


  address(
      const std::experimental::net::ip::address_v4 & ipv4_address);



[endsect]



[section:overload3 ip::address::address (3 of 4 overloads)]


Construct an address from an IPv6 address. 


  address(
      const std::experimental::net::ip::address_v6 & ipv6_address);



[endsect]



[section:overload4 ip::address::address (4 of 4 overloads)]


Copy constructor. 


  address(
      const address & other);



[endsect]


[endsect]


[section:is_loopback ip::address::is_loopback]


Determine whether the address is a loopback address. 


  bool is_loopback() const;



[endsect]



[section:is_multicast ip::address::is_multicast]


Determine whether the address is a multicast address. 


  bool is_multicast() const;



[endsect]



[section:is_unspecified ip::address::is_unspecified]


Determine whether the address is unspecified. 


  bool is_unspecified() const;



[endsect]



[section:is_v4 ip::address::is_v4]


Get whether the address is an IP version 4 address. 


  bool is_v4() const;



[endsect]



[section:is_v6 ip::address::is_v6]


Get whether the address is an IP version 6 address. 


  bool is_v6() const;



[endsect]


[section:make_address ip::address::make_address]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address ``[link networking_ts.reference.ip__address.make_address.overload1 make_address]``(
      const char * str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.make_address.overload1 more...]]``

  address ``[link networking_ts.reference.ip__address.make_address.overload2 make_address]``(
      const char * str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.make_address.overload2 more...]]``

  address ``[link networking_ts.reference.ip__address.make_address.overload3 make_address]``(
      const std::string & str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.make_address.overload3 more...]]``

  address ``[link networking_ts.reference.ip__address.make_address.overload4 make_address]``(
      const std::string & str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.make_address.overload4 more...]]``

  address ``[link networking_ts.reference.ip__address.make_address.overload5 make_address]``(
      string_view str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.make_address.overload5 more...]]``

  address ``[link networking_ts.reference.ip__address.make_address.overload6 make_address]``(
      string_view str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.make_address.overload6 more...]]``


[section:overload1 ip::address::make_address (1 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      const char * str);



[endsect]



[section:overload2 ip::address::make_address (2 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      const char * str,
      std::error_code & ec);



[endsect]



[section:overload3 ip::address::make_address (3 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      const std::string & str);



[endsect]



[section:overload4 ip::address::make_address (4 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      const std::string & str,
      std::error_code & ec);



[endsect]



[section:overload5 ip::address::make_address (5 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      string_view str);



[endsect]



[section:overload6 ip::address::make_address (6 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      string_view str,
      std::error_code & ec);



[endsect]


[endsect]


[section:operator_not__eq_ ip::address::operator!=]


Compare two addresses for inequality. 


  friend bool operator!=(
      const address & a1,
      const address & a2);



[endsect]



[section:operator_lt_ ip::address::operator<]


Compare addresses for ordering. 


  friend bool operator<(
      const address & a1,
      const address & a2);



[endsect]



[section:operator_lt__eq_ ip::address::operator<=]


Compare addresses for ordering. 


  friend bool operator<=(
      const address & a1,
      const address & a2);



[endsect]


[section:operator_eq_ ip::address::operator=]


Assign from another address. 


  address & ``[link networking_ts.reference.ip__address.operator_eq_.overload1 operator=]``(
      const address & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.operator_eq_.overload1 more...]]``


Assign from an IPv4 address. 


  address & ``[link networking_ts.reference.ip__address.operator_eq_.overload2 operator=]``(
      const std::experimental::net::ip::address_v4 & ipv4_address);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.operator_eq_.overload2 more...]]``


Assign from an IPv6 address. 


  address & ``[link networking_ts.reference.ip__address.operator_eq_.overload3 operator=]``(
      const std::experimental::net::ip::address_v6 & ipv6_address);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address.operator_eq_.overload3 more...]]``


[section:overload1 ip::address::operator= (1 of 3 overloads)]


Assign from another address. 


  address & operator=(
      const address & other);



[endsect]



[section:overload2 ip::address::operator= (2 of 3 overloads)]


Assign from an IPv4 address. 


  address & operator=(
      const std::experimental::net::ip::address_v4 & ipv4_address);



[endsect]



[section:overload3 ip::address::operator= (3 of 3 overloads)]


Assign from an IPv6 address. 


  address & operator=(
      const std::experimental::net::ip::address_v6 & ipv6_address);



[endsect]


[endsect]


[section:operator_eq__eq_ ip::address::operator==]


Compare two addresses for equality. 


  friend bool operator==(
      const address & a1,
      const address & a2);



[endsect]



[section:operator_gt_ ip::address::operator>]


Compare addresses for ordering. 


  friend bool operator>(
      const address & a1,
      const address & a2);



[endsect]



[section:operator_gt__eq_ ip::address::operator>=]


Compare addresses for ordering. 


  friend bool operator>=(
      const address & a1,
      const address & a2);



[endsect]



[section:to_string ip::address::to_string]


Get the address as a string. 


  std::string to_string() const;



[endsect]



[section:to_v4 ip::address::to_v4]


Get the address as an IP version 4 address. 


  std::experimental::net::ip::address_v4 to_v4() const;



[endsect]



[section:to_v6 ip::address::to_v6]


Get the address as an IP version 6 address. 


  std::experimental::net::ip::address_v6 to_v6() const;



[endsect]



[endsect]

[section:ip__address_v4 ip::address_v4]


Implements IP version 4 style addresses. 


  class address_v4


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v4.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

  [

    [[link networking_ts.reference.ip__address_v4.uint_type [*uint_type]]]
    [The type used to represent an address as an unsigned integer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.address_v4 [*address_v4]]]
    [Default constructor. 

     Construct an address from raw bytes. 

     Construct an address from an unsigned integer in host byte order. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.broadcast [*broadcast]]]
    [Obtain an address object that represents the broadcast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_string [*to_string]]]
    [Get the address as a string in dotted decimal format. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_uint [*to_uint]]]
    [Get the address as an unsigned integer in host byte order. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.make_address_v4 [*make_address_v4]]]
    [Create an IPv4 address from raw bytes in network order. 

     Create an IPv4 address from an unsigned integer in host byte order. 

     Create an IPv4 address from an IP address string in dotted decimal form. 

     Create an IPv4 address from a IPv4-mapped IPv6 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from an address and prefix length. 

     Create an IPv4 network from an address and netmask. ]
  ]
  
]

The std::experimental::net::ip::address\_v4 class provides the ability to use and manipulate IP version 4 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:address_v4 ip::address_v4::address_v4]


Default constructor. 


  ``[link networking_ts.reference.ip__address_v4.address_v4.overload1 address_v4]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.address_v4.overload1 more...]]``


Construct an address from raw bytes. 


  explicit ``[link networking_ts.reference.ip__address_v4.address_v4.overload2 address_v4]``(
      const bytes_type & bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.address_v4.overload2 more...]]``


Construct an address from an unsigned integer in host byte order. 


  explicit ``[link networking_ts.reference.ip__address_v4.address_v4.overload3 address_v4]``(
      uint_type addr);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.address_v4.overload3 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__address_v4.address_v4.overload4 address_v4]``(
      const address_v4 & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.address_v4.overload4 more...]]``


[section:overload1 ip::address_v4::address_v4 (1 of 4 overloads)]


Default constructor. 


  address_v4();



[endsect]



[section:overload2 ip::address_v4::address_v4 (2 of 4 overloads)]


Construct an address from raw bytes. 


  address_v4(
      const bytes_type & bytes);



[endsect]



[section:overload3 ip::address_v4::address_v4 (3 of 4 overloads)]


Construct an address from an unsigned integer in host byte order. 


  address_v4(
      uint_type addr);



[endsect]



[section:overload4 ip::address_v4::address_v4 (4 of 4 overloads)]


Copy constructor. 


  address_v4(
      const address_v4 & other);



[endsect]


[endsect]


[section:any ip::address_v4::any]


Obtain an address object that represents any address. 


  static address_v4 any();



[endsect]



[section:broadcast ip::address_v4::broadcast]


Obtain an address object that represents the broadcast address. 


  static address_v4 broadcast();



[endsect]



[section:bytes_type ip::address_v4::bytes_type]


The type used to represent an address as an array of bytes. 


  typedef array< unsigned char, 4 > bytes_type;




[heading Remarks]
      
This type is defined in terms of the C++0x template `std::array` when it is available. Otherwise, it uses `boost:array`. 




[endsect]



[section:is_loopback ip::address_v4::is_loopback]


Determine whether the address is a loopback address. 


  bool is_loopback() const;



[endsect]



[section:is_multicast ip::address_v4::is_multicast]


Determine whether the address is a multicast address. 


  bool is_multicast() const;



[endsect]



[section:is_unspecified ip::address_v4::is_unspecified]


Determine whether the address is unspecified. 


  bool is_unspecified() const;



[endsect]



[section:loopback ip::address_v4::loopback]


Obtain an address object that represents the loopback address. 


  static address_v4 loopback();



[endsect]


[section:make_address_v4 ip::address_v4::make_address_v4]


Create an IPv4 address from raw bytes in network order. 


  address_v4 ``[link networking_ts.reference.ip__address_v4.make_address_v4.overload1 make_address_v4]``(
      const address_v4::bytes_type & bytes);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_address_v4.overload1 more...]]``


Create an IPv4 address from an unsigned integer in host byte order. 


  address_v4 ``[link networking_ts.reference.ip__address_v4.make_address_v4.overload2 make_address_v4]``(
      address_v4::uint_type addr);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_address_v4.overload2 more...]]``


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 ``[link networking_ts.reference.ip__address_v4.make_address_v4.overload3 make_address_v4]``(
      const char * str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_address_v4.overload3 more...]]``

  address_v4 ``[link networking_ts.reference.ip__address_v4.make_address_v4.overload4 make_address_v4]``(
      const char * str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_address_v4.overload4 more...]]``

  address_v4 ``[link networking_ts.reference.ip__address_v4.make_address_v4.overload5 make_address_v4]``(
      const std::string & str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_address_v4.overload5 more...]]``

  address_v4 ``[link networking_ts.reference.ip__address_v4.make_address_v4.overload6 make_address_v4]``(
      const std::string & str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_address_v4.overload6 more...]]``

  address_v4 ``[link networking_ts.reference.ip__address_v4.make_address_v4.overload7 make_address_v4]``(
      string_view str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_address_v4.overload7 more...]]``

  address_v4 ``[link networking_ts.reference.ip__address_v4.make_address_v4.overload8 make_address_v4]``(
      string_view str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_address_v4.overload8 more...]]``


Create an IPv4 address from a IPv4-mapped IPv6 address. 


  address_v4 ``[link networking_ts.reference.ip__address_v4.make_address_v4.overload9 make_address_v4]``(
      v4_mapped_t ,
      const address_v6 & v6_addr);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_address_v4.overload9 more...]]``


[section:overload1 ip::address_v4::make_address_v4 (1 of 9 overloads)]


Create an IPv4 address from raw bytes in network order. 


  address_v4 make_address_v4(
      const address_v4::bytes_type & bytes);



[endsect]



[section:overload2 ip::address_v4::make_address_v4 (2 of 9 overloads)]


Create an IPv4 address from an unsigned integer in host byte order. 


  address_v4 make_address_v4(
      address_v4::uint_type addr);



[endsect]



[section:overload3 ip::address_v4::make_address_v4 (3 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      const char * str);



[endsect]



[section:overload4 ip::address_v4::make_address_v4 (4 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      const char * str,
      std::error_code & ec);



[endsect]



[section:overload5 ip::address_v4::make_address_v4 (5 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      const std::string & str);



[endsect]



[section:overload6 ip::address_v4::make_address_v4 (6 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      const std::string & str,
      std::error_code & ec);



[endsect]



[section:overload7 ip::address_v4::make_address_v4 (7 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      string_view str);



[endsect]



[section:overload8 ip::address_v4::make_address_v4 (8 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      string_view str,
      std::error_code & ec);



[endsect]



[section:overload9 ip::address_v4::make_address_v4 (9 of 9 overloads)]


Create an IPv4 address from a IPv4-mapped IPv6 address. 


  address_v4 make_address_v4(
      v4_mapped_t ,
      const address_v6 & v6_addr);



[endsect]


[endsect]

[section:make_network_v4 ip::address_v4::make_network_v4]


Create an IPv4 network from an address and prefix length. 


  network_v4 ``[link networking_ts.reference.ip__address_v4.make_network_v4.overload1 make_network_v4]``(
      const address_v4 & addr,
      unsigned short prefix_len);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_network_v4.overload1 more...]]``


Create an IPv4 network from an address and netmask. 


  network_v4 ``[link networking_ts.reference.ip__address_v4.make_network_v4.overload2 make_network_v4]``(
      const address_v4 & addr,
      const address_v4 & mask);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v4.make_network_v4.overload2 more...]]``


[section:overload1 ip::address_v4::make_network_v4 (1 of 2 overloads)]


Create an IPv4 network from an address and prefix length. 


  network_v4 make_network_v4(
      const address_v4 & addr,
      unsigned short prefix_len);



[endsect]



[section:overload2 ip::address_v4::make_network_v4 (2 of 2 overloads)]


Create an IPv4 network from an address and netmask. 


  network_v4 make_network_v4(
      const address_v4 & addr,
      const address_v4 & mask);



[endsect]


[endsect]


[section:operator_not__eq_ ip::address_v4::operator!=]


Compare two addresses for inequality. 


  friend bool operator!=(
      const address_v4 & a1,
      const address_v4 & a2);



[endsect]



[section:operator_lt_ ip::address_v4::operator<]


Compare addresses for ordering. 


  friend bool operator<(
      const address_v4 & a1,
      const address_v4 & a2);



[endsect]



[section:operator_lt__eq_ ip::address_v4::operator<=]


Compare addresses for ordering. 


  friend bool operator<=(
      const address_v4 & a1,
      const address_v4 & a2);



[endsect]



[section:operator_eq_ ip::address_v4::operator=]


Assign from another address. 


  address_v4 & operator=(
      const address_v4 & other);



[endsect]



[section:operator_eq__eq_ ip::address_v4::operator==]


Compare two addresses for equality. 


  friend bool operator==(
      const address_v4 & a1,
      const address_v4 & a2);



[endsect]



[section:operator_gt_ ip::address_v4::operator>]


Compare addresses for ordering. 


  friend bool operator>(
      const address_v4 & a1,
      const address_v4 & a2);



[endsect]



[section:operator_gt__eq_ ip::address_v4::operator>=]


Compare addresses for ordering. 


  friend bool operator>=(
      const address_v4 & a1,
      const address_v4 & a2);



[endsect]



[section:to_bytes ip::address_v4::to_bytes]


Get the address in bytes, in network byte order. 


  bytes_type to_bytes() const;



[endsect]



[section:to_string ip::address_v4::to_string]


Get the address as a string in dotted decimal format. 


  std::string to_string() const;



[endsect]



[section:to_uint ip::address_v4::to_uint]


Get the address as an unsigned integer in host byte order. 


  uint_type to_uint() const;



[endsect]



[section:uint_type ip::address_v4::uint_type]


The type used to represent an address as an unsigned integer. 


  typedef uint_least32_t uint_type;




[endsect]



[endsect]


[section:ip__address_v4_iterator ip::address_v4_iterator]


An input iterator that can be used for traversing IPv4 addresses. 


  typedef basic_address_iterator< address_v4 > address_v4_iterator;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v4.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

  [

    [[link networking_ts.reference.ip__address_v4.uint_type [*uint_type]]]
    [The type used to represent an address as an unsigned integer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.address_v4 [*address_v4]]]
    [Default constructor. 

     Construct an address from raw bytes. 

     Construct an address from an unsigned integer in host byte order. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.broadcast [*broadcast]]]
    [Obtain an address object that represents the broadcast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_string [*to_string]]]
    [Get the address as a string in dotted decimal format. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_uint [*to_uint]]]
    [Get the address as an unsigned integer in host byte order. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.make_address_v4 [*make_address_v4]]]
    [Create an IPv4 address from raw bytes in network order. 

     Create an IPv4 address from an unsigned integer in host byte order. 

     Create an IPv4 address from an IP address string in dotted decimal form. 

     Create an IPv4 address from a IPv4-mapped IPv6 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from an address and prefix length. 

     Create an IPv4 network from an address and netmask. ]
  ]
  
]

The std::experimental::net::ip::address\_v4 class provides the ability to use and manipulate IP version 4 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:ip__address_v4_range ip::address_v4_range]


Represents a range of IPv4 addresses. 


  typedef basic_address_range< address_v4 > address_v4_range;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v4.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

  [

    [[link networking_ts.reference.ip__address_v4.uint_type [*uint_type]]]
    [The type used to represent an address as an unsigned integer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.address_v4 [*address_v4]]]
    [Default constructor. 

     Construct an address from raw bytes. 

     Construct an address from an unsigned integer in host byte order. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.broadcast [*broadcast]]]
    [Obtain an address object that represents the broadcast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_string [*to_string]]]
    [Get the address as a string in dotted decimal format. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_uint [*to_uint]]]
    [Get the address as an unsigned integer in host byte order. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.make_address_v4 [*make_address_v4]]]
    [Create an IPv4 address from raw bytes in network order. 

     Create an IPv4 address from an unsigned integer in host byte order. 

     Create an IPv4 address from an IP address string in dotted decimal form. 

     Create an IPv4 address from a IPv4-mapped IPv6 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from an address and prefix length. 

     Create an IPv4 network from an address and netmask. ]
  ]
  
]

The std::experimental::net::ip::address\_v4 class provides the ability to use and manipulate IP version 4 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]


[section:ip__address_v6 ip::address_v6]


Implements IP version 6 style addresses. 


  class address_v6


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v6.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.address_v6 [*address_v6]]]
    [Default constructor. 

     Construct an address from raw bytes and scope ID. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_link_local [*is_link_local]]]
    [Determine whether the address is link local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_global [*is_multicast_global]]]
    [Determine whether the address is a global multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_link_local [*is_multicast_link_local]]]
    [Determine whether the address is a link-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_node_local [*is_multicast_node_local]]]
    [Determine whether the address is a node-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_org_local [*is_multicast_org_local]]]
    [Determine whether the address is a org-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_site_local [*is_multicast_site_local]]]
    [Determine whether the address is a site-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_site_local [*is_site_local]]]
    [Determine whether the address is site local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_v4_mapped [*is_v4_mapped]]]
    [Determine whether the address is a mapped IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.scope_id [*scope_id]]]
    [The scope ID of the address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_string [*to_string]]]
    [Get the address as a string. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.make_address_v6 [*make_address_v6]]]
    [Create an IPv6 address from raw bytes and scope ID. 

     Create an IPv6 address from an IP address string. 

     Createan IPv6 address from an IP address string. 

     Create an IPv4-mapped IPv6 address from an IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from an address and prefix length. ]
  ]
  
]

The std::experimental::net::ip::address\_v6 class provides the ability to use and manipulate IP version 6 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:address_v6 ip::address_v6::address_v6]


Default constructor. 


  ``[link networking_ts.reference.ip__address_v6.address_v6.overload1 address_v6]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.address_v6.overload1 more...]]``


Construct an address from raw bytes and scope ID. 


  explicit ``[link networking_ts.reference.ip__address_v6.address_v6.overload2 address_v6]``(
      const bytes_type & bytes,
      unsigned long scope_id = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.address_v6.overload2 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__address_v6.address_v6.overload3 address_v6]``(
      const address_v6 & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.address_v6.overload3 more...]]``


[section:overload1 ip::address_v6::address_v6 (1 of 3 overloads)]


Default constructor. 


  address_v6();



[endsect]



[section:overload2 ip::address_v6::address_v6 (2 of 3 overloads)]


Construct an address from raw bytes and scope ID. 


  address_v6(
      const bytes_type & bytes,
      unsigned long scope_id = 0);



[endsect]



[section:overload3 ip::address_v6::address_v6 (3 of 3 overloads)]


Copy constructor. 


  address_v6(
      const address_v6 & other);



[endsect]


[endsect]


[section:any ip::address_v6::any]


Obtain an address object that represents any address. 


  static address_v6 any();



[endsect]



[section:bytes_type ip::address_v6::bytes_type]


The type used to represent an address as an array of bytes. 


  typedef array< unsigned char, 16 > bytes_type;




[heading Remarks]
      
This type is defined in terms of the C++0x template `std::array` when it is available. Otherwise, it uses `boost:array`. 




[endsect]



[section:is_link_local ip::address_v6::is_link_local]


Determine whether the address is link local. 


  bool is_link_local() const;



[endsect]



[section:is_loopback ip::address_v6::is_loopback]


Determine whether the address is a loopback address. 


  bool is_loopback() const;



[endsect]



[section:is_multicast ip::address_v6::is_multicast]


Determine whether the address is a multicast address. 


  bool is_multicast() const;



[endsect]



[section:is_multicast_global ip::address_v6::is_multicast_global]


Determine whether the address is a global multicast address. 


  bool is_multicast_global() const;



[endsect]



[section:is_multicast_link_local ip::address_v6::is_multicast_link_local]


Determine whether the address is a link-local multicast address. 


  bool is_multicast_link_local() const;



[endsect]



[section:is_multicast_node_local ip::address_v6::is_multicast_node_local]


Determine whether the address is a node-local multicast address. 


  bool is_multicast_node_local() const;



[endsect]



[section:is_multicast_org_local ip::address_v6::is_multicast_org_local]


Determine whether the address is a org-local multicast address. 


  bool is_multicast_org_local() const;



[endsect]



[section:is_multicast_site_local ip::address_v6::is_multicast_site_local]


Determine whether the address is a site-local multicast address. 


  bool is_multicast_site_local() const;



[endsect]



[section:is_site_local ip::address_v6::is_site_local]


Determine whether the address is site local. 


  bool is_site_local() const;



[endsect]



[section:is_unspecified ip::address_v6::is_unspecified]


Determine whether the address is unspecified. 


  bool is_unspecified() const;



[endsect]



[section:is_v4_mapped ip::address_v6::is_v4_mapped]


Determine whether the address is a mapped IPv4 address. 


  bool is_v4_mapped() const;



[endsect]



[section:loopback ip::address_v6::loopback]


Obtain an address object that represents the loopback address. 


  static address_v6 loopback();



[endsect]


[section:make_address_v6 ip::address_v6::make_address_v6]


Create an IPv6 address from raw bytes and scope ID. 


  address_v6 ``[link networking_ts.reference.ip__address_v6.make_address_v6.overload1 make_address_v6]``(
      const address_v6::bytes_type & bytes,
      unsigned long scope_id = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.make_address_v6.overload1 more...]]``


Create an IPv6 address from an IP address string. 


  address_v6 ``[link networking_ts.reference.ip__address_v6.make_address_v6.overload2 make_address_v6]``(
      const char * str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.make_address_v6.overload2 more...]]``

  address_v6 ``[link networking_ts.reference.ip__address_v6.make_address_v6.overload3 make_address_v6]``(
      const char * str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.make_address_v6.overload3 more...]]``


Createan IPv6 address from an IP address string. 


  address_v6 ``[link networking_ts.reference.ip__address_v6.make_address_v6.overload4 make_address_v6]``(
      const std::string & str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.make_address_v6.overload4 more...]]``

  address_v6 ``[link networking_ts.reference.ip__address_v6.make_address_v6.overload5 make_address_v6]``(
      const std::string & str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.make_address_v6.overload5 more...]]``

  address_v6 ``[link networking_ts.reference.ip__address_v6.make_address_v6.overload6 make_address_v6]``(
      string_view str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.make_address_v6.overload6 more...]]``

  address_v6 ``[link networking_ts.reference.ip__address_v6.make_address_v6.overload7 make_address_v6]``(
      string_view str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.make_address_v6.overload7 more...]]``


Create an IPv4-mapped IPv6 address from an IPv4 address. 


  address_v6 ``[link networking_ts.reference.ip__address_v6.make_address_v6.overload8 make_address_v6]``(
      v4_mapped_t ,
      const address_v4 & v4_addr);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.make_address_v6.overload8 more...]]``


[section:overload1 ip::address_v6::make_address_v6 (1 of 8 overloads)]


Create an IPv6 address from raw bytes and scope ID. 


  address_v6 make_address_v6(
      const address_v6::bytes_type & bytes,
      unsigned long scope_id = 0);



[endsect]



[section:overload2 ip::address_v6::make_address_v6 (2 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      const char * str);



[endsect]



[section:overload3 ip::address_v6::make_address_v6 (3 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      const char * str,
      std::error_code & ec);



[endsect]



[section:overload4 ip::address_v6::make_address_v6 (4 of 8 overloads)]


Createan IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      const std::string & str);



[endsect]



[section:overload5 ip::address_v6::make_address_v6 (5 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      const std::string & str,
      std::error_code & ec);



[endsect]



[section:overload6 ip::address_v6::make_address_v6 (6 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      string_view str);



[endsect]



[section:overload7 ip::address_v6::make_address_v6 (7 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      string_view str,
      std::error_code & ec);



[endsect]



[section:overload8 ip::address_v6::make_address_v6 (8 of 8 overloads)]


Create an IPv4-mapped IPv6 address from an IPv4 address. 


  address_v6 make_address_v6(
      v4_mapped_t ,
      const address_v4 & v4_addr);



[endsect]


[endsect]


[section:make_network_v6 ip::address_v6::make_network_v6]


Create an IPv6 network from an address and prefix length. 


  network_v6 make_network_v6(
      const address_v6 & addr,
      unsigned short prefix_len);



[endsect]



[section:operator_not__eq_ ip::address_v6::operator!=]


Compare two addresses for inequality. 


  friend bool operator!=(
      const address_v6 & a1,
      const address_v6 & a2);



[endsect]



[section:operator_lt_ ip::address_v6::operator<]


Compare addresses for ordering. 


  friend bool operator<(
      const address_v6 & a1,
      const address_v6 & a2);



[endsect]



[section:operator_lt__eq_ ip::address_v6::operator<=]


Compare addresses for ordering. 


  friend bool operator<=(
      const address_v6 & a1,
      const address_v6 & a2);



[endsect]



[section:operator_eq_ ip::address_v6::operator=]


Assign from another address. 


  address_v6 & operator=(
      const address_v6 & other);



[endsect]



[section:operator_eq__eq_ ip::address_v6::operator==]


Compare two addresses for equality. 


  friend bool operator==(
      const address_v6 & a1,
      const address_v6 & a2);



[endsect]



[section:operator_gt_ ip::address_v6::operator>]


Compare addresses for ordering. 


  friend bool operator>(
      const address_v6 & a1,
      const address_v6 & a2);



[endsect]



[section:operator_gt__eq_ ip::address_v6::operator>=]


Compare addresses for ordering. 


  friend bool operator>=(
      const address_v6 & a1,
      const address_v6 & a2);



[endsect]


[section:scope_id ip::address_v6::scope_id]


The scope ID of the address. 


  unsigned long ``[link networking_ts.reference.ip__address_v6.scope_id.overload1 scope_id]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.scope_id.overload1 more...]]``

  void ``[link networking_ts.reference.ip__address_v6.scope_id.overload2 scope_id]``(
      unsigned long id);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__address_v6.scope_id.overload2 more...]]``


[section:overload1 ip::address_v6::scope_id (1 of 2 overloads)]


The scope ID of the address. 


  unsigned long scope_id() const;


Returns the scope ID associated with the IPv6 address. 


[endsect]



[section:overload2 ip::address_v6::scope_id (2 of 2 overloads)]


The scope ID of the address. 


  void scope_id(
      unsigned long id);


Modifies the scope ID associated with the IPv6 address. 


[endsect]


[endsect]


[section:to_bytes ip::address_v6::to_bytes]


Get the address in bytes, in network byte order. 


  bytes_type to_bytes() const;



[endsect]



[section:to_string ip::address_v6::to_string]


Get the address as a string. 


  std::string to_string() const;



[endsect]



[endsect]


[section:ip__address_v6_iterator ip::address_v6_iterator]


An input iterator that can be used for traversing IPv6 addresses. 


  typedef basic_address_iterator< address_v6 > address_v6_iterator;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v6.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.address_v6 [*address_v6]]]
    [Default constructor. 

     Construct an address from raw bytes and scope ID. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_link_local [*is_link_local]]]
    [Determine whether the address is link local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_global [*is_multicast_global]]]
    [Determine whether the address is a global multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_link_local [*is_multicast_link_local]]]
    [Determine whether the address is a link-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_node_local [*is_multicast_node_local]]]
    [Determine whether the address is a node-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_org_local [*is_multicast_org_local]]]
    [Determine whether the address is a org-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_site_local [*is_multicast_site_local]]]
    [Determine whether the address is a site-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_site_local [*is_site_local]]]
    [Determine whether the address is site local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_v4_mapped [*is_v4_mapped]]]
    [Determine whether the address is a mapped IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.scope_id [*scope_id]]]
    [The scope ID of the address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_string [*to_string]]]
    [Get the address as a string. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.make_address_v6 [*make_address_v6]]]
    [Create an IPv6 address from raw bytes and scope ID. 

     Create an IPv6 address from an IP address string. 

     Createan IPv6 address from an IP address string. 

     Create an IPv4-mapped IPv6 address from an IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from an address and prefix length. ]
  ]
  
]

The std::experimental::net::ip::address\_v6 class provides the ability to use and manipulate IP version 6 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:ip__address_v6_range ip::address_v6_range]


Represents a range of IPv6 addresses. 


  typedef basic_address_range< address_v6 > address_v6_range;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v6.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.address_v6 [*address_v6]]]
    [Default constructor. 

     Construct an address from raw bytes and scope ID. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_link_local [*is_link_local]]]
    [Determine whether the address is link local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_global [*is_multicast_global]]]
    [Determine whether the address is a global multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_link_local [*is_multicast_link_local]]]
    [Determine whether the address is a link-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_node_local [*is_multicast_node_local]]]
    [Determine whether the address is a node-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_org_local [*is_multicast_org_local]]]
    [Determine whether the address is a org-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_site_local [*is_multicast_site_local]]]
    [Determine whether the address is a site-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_site_local [*is_site_local]]]
    [Determine whether the address is site local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_v4_mapped [*is_v4_mapped]]]
    [Determine whether the address is a mapped IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.scope_id [*scope_id]]]
    [The scope ID of the address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_string [*to_string]]]
    [Get the address as a string. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.make_address_v6 [*make_address_v6]]]
    [Create an IPv6 address from raw bytes and scope ID. 

     Create an IPv6 address from an IP address string. 

     Createan IPv6 address from an IP address string. 

     Create an IPv4-mapped IPv6 address from an IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from an address and prefix length. ]
  ]
  
]

The std::experimental::net::ip::address\_v6 class provides the ability to use and manipulate IP version 6 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]


[section:ip__bad_address_cast ip::bad_address_cast]


Thrown to indicate a failed address conversion. 


  class bad_address_cast


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__bad_address_cast.bad_address_cast [*bad_address_cast]]]
    [Default constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__bad_address_cast.what [*what]]]
    [Get the message associated with the exception. ]
  ]
  
  [
    [[link networking_ts.reference.ip__bad_address_cast._bad_address_cast [*~bad_address_cast]]]
    [Destructor. ]
  ]
  
]


[section:bad_address_cast ip::bad_address_cast::bad_address_cast]


Default constructor. 


  bad_address_cast();



[endsect]



[section:what ip::bad_address_cast::what]


Get the message associated with the exception. 


  virtual const char * what() const;



[endsect]



[section:_bad_address_cast ip::bad_address_cast::~bad_address_cast]


Destructor. 


  virtual ~bad_address_cast();



[endsect]



[endsect]

[section:ip__basic_address_iterator_lt__address_v4__gt_ ip::basic_address_iterator< address_v4 >]


An input iterator that can be used for traversing IPv4 addresses. 


  template<>
  class basic_address_iterator< address_v4 >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.difference_type [*difference_type]]]
    [Distance between two iterators. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.iterator_category [*iterator_category]]]
    [Denotes that the iterator satisfies the input iterator requirements. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.pointer [*pointer]]]
    [The type of a pointer to an element pointed to by the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.reference [*reference]]]
    [The type of a reference to an element pointed to by the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.value_type [*value_type]]]
    [The type of the elements pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator [*basic_address_iterator]]]
    [Construct an iterator that points to the specified address. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator__star_ [*operator *]]]
    [Dereference the iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_ [*operator++]]]
    [Pre-increment operator. 

     Post-increment operator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_ [*operator--]]]
    [Pre-decrement operator. 

     Post-decrement operator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_arrow_ [*operator->]]]
    [Dereference the iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_eq_ [*operator=]]]
    [Assignment operator. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
]

In addition to satisfying the input iterator requirements, this iterator also supports decrement.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:basic_address_iterator ip::basic_address_iterator< address_v4 >::basic_address_iterator]


Construct an iterator that points to the specified address. 


  ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator.overload1 basic_address_iterator]``(
      const address_v4 & addr);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator.overload1 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator.overload2 basic_address_iterator]``(
      const basic_address_iterator & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v4 >::basic_address_iterator (1 of 2 overloads)]


Construct an iterator that points to the specified address. 


  basic_address_iterator(
      const address_v4 & addr);



[endsect]



[section:overload2 ip::basic_address_iterator< address_v4 >::basic_address_iterator (2 of 2 overloads)]


Copy constructor. 


  basic_address_iterator(
      const basic_address_iterator & other);



[endsect]


[endsect]


[section:difference_type ip::basic_address_iterator< address_v4 >::difference_type]


Distance between two iterators. 


  typedef std::ptrdiff_t difference_type;




[endsect]



[section:iterator_category ip::basic_address_iterator< address_v4 >::iterator_category]


Denotes that the iterator satisfies the input iterator requirements. 


  typedef std::input_iterator_tag iterator_category;




[endsect]



[section:operator__star_ ip::basic_address_iterator< address_v4 >::operator *]


Dereference the iterator. 


  const address_v4 & operator *() const;



[endsect]



[section:operator_not__eq_ ip::basic_address_iterator< address_v4 >::operator!=]


Compare two addresses for inequality. 


  friend bool operator!=(
      const basic_address_iterator & a,
      const basic_address_iterator & b);



[endsect]


[section:operator_plus__plus_ ip::basic_address_iterator< address_v4 >::operator++]


Pre-increment operator. 


  basic_address_iterator & ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_.overload1 operator++]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_.overload1 more...]]``


Post-increment operator. 


  basic_address_iterator ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_.overload2 operator++]``(
      int );
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v4 >::operator++ (1 of 2 overloads)]


Pre-increment operator. 


  basic_address_iterator & operator++();



[endsect]



[section:overload2 ip::basic_address_iterator< address_v4 >::operator++ (2 of 2 overloads)]


Post-increment operator. 


  basic_address_iterator operator++(
      int );



[endsect]


[endsect]

[section:operator_minus__minus_ ip::basic_address_iterator< address_v4 >::operator--]


Pre-decrement operator. 


  basic_address_iterator & ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_.overload1 operator--]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_.overload1 more...]]``


Post-decrement operator. 


  basic_address_iterator ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_.overload2 operator--]``(
      int );
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v4 >::operator-- (1 of 2 overloads)]


Pre-decrement operator. 


  basic_address_iterator & operator--();



[endsect]



[section:overload2 ip::basic_address_iterator< address_v4 >::operator-- (2 of 2 overloads)]


Post-decrement operator. 


  basic_address_iterator operator--(
      int );



[endsect]


[endsect]


[section:operator_arrow_ ip::basic_address_iterator< address_v4 >::operator->]


Dereference the iterator. 


  const address_v4 * operator->() const;



[endsect]



[section:operator_eq_ ip::basic_address_iterator< address_v4 >::operator=]


Assignment operator. 


  basic_address_iterator & operator=(
      const basic_address_iterator & other);



[endsect]



[section:operator_eq__eq_ ip::basic_address_iterator< address_v4 >::operator==]


Compare two addresses for equality. 


  friend bool operator==(
      const basic_address_iterator & a,
      const basic_address_iterator & b);



[endsect]



[section:pointer ip::basic_address_iterator< address_v4 >::pointer]


The type of a pointer to an element pointed to by the iterator. 


  typedef const address_v4 * pointer;




[endsect]



[section:reference ip::basic_address_iterator< address_v4 >::reference]


The type of a reference to an element pointed to by the iterator. 


  typedef const address_v4 & reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v4.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

  [

    [[link networking_ts.reference.ip__address_v4.uint_type [*uint_type]]]
    [The type used to represent an address as an unsigned integer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.address_v4 [*address_v4]]]
    [Default constructor. 

     Construct an address from raw bytes. 

     Construct an address from an unsigned integer in host byte order. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.broadcast [*broadcast]]]
    [Obtain an address object that represents the broadcast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_string [*to_string]]]
    [Get the address as a string in dotted decimal format. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_uint [*to_uint]]]
    [Get the address as an unsigned integer in host byte order. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.make_address_v4 [*make_address_v4]]]
    [Create an IPv4 address from raw bytes in network order. 

     Create an IPv4 address from an unsigned integer in host byte order. 

     Create an IPv4 address from an IP address string in dotted decimal form. 

     Create an IPv4 address from a IPv4-mapped IPv6 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from an address and prefix length. 

     Create an IPv4 network from an address and netmask. ]
  ]
  
]

The std::experimental::net::ip::address\_v4 class provides the ability to use and manipulate IP version 4 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:value_type ip::basic_address_iterator< address_v4 >::value_type]


The type of the elements pointed to by the iterator. 


  typedef address_v4 value_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v4.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

  [

    [[link networking_ts.reference.ip__address_v4.uint_type [*uint_type]]]
    [The type used to represent an address as an unsigned integer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.address_v4 [*address_v4]]]
    [Default constructor. 

     Construct an address from raw bytes. 

     Construct an address from an unsigned integer in host byte order. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.broadcast [*broadcast]]]
    [Obtain an address object that represents the broadcast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_string [*to_string]]]
    [Get the address as a string in dotted decimal format. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_uint [*to_uint]]]
    [Get the address as an unsigned integer in host byte order. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.make_address_v4 [*make_address_v4]]]
    [Create an IPv4 address from raw bytes in network order. 

     Create an IPv4 address from an unsigned integer in host byte order. 

     Create an IPv4 address from an IP address string in dotted decimal form. 

     Create an IPv4 address from a IPv4-mapped IPv6 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from an address and prefix length. 

     Create an IPv4 network from an address and netmask. ]
  ]
  
]

The std::experimental::net::ip::address\_v4 class provides the ability to use and manipulate IP version 4 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[endsect]

[section:ip__basic_address_iterator_lt__address_v6__gt_ ip::basic_address_iterator< address_v6 >]


An input iterator that can be used for traversing IPv6 addresses. 


  template<>
  class basic_address_iterator< address_v6 >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.difference_type [*difference_type]]]
    [Distance between two iterators. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.iterator_category [*iterator_category]]]
    [Denotes that the iterator satisfies the input iterator requirements. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.pointer [*pointer]]]
    [The type of a pointer to an element pointed to by the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.reference [*reference]]]
    [The type of a reference to an element pointed to by the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.value_type [*value_type]]]
    [The type of the elements pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator [*basic_address_iterator]]]
    [Construct an iterator that points to the specified address. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator__star_ [*operator *]]]
    [Dereference the iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_ [*operator++]]]
    [Pre-increment operator. 

     Post-increment operator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_ [*operator--]]]
    [Pre-decrement operator. 

     Post-decrement operator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_arrow_ [*operator->]]]
    [Dereference the iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_eq_ [*operator=]]]
    [Assignment operator. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
]

In addition to satisfying the input iterator requirements, this iterator also supports decrement.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:basic_address_iterator ip::basic_address_iterator< address_v6 >::basic_address_iterator]


Construct an iterator that points to the specified address. 


  ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator.overload1 basic_address_iterator]``(
      const address_v6 & addr);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator.overload1 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator.overload2 basic_address_iterator]``(
      const basic_address_iterator & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v6 >::basic_address_iterator (1 of 2 overloads)]


Construct an iterator that points to the specified address. 


  basic_address_iterator(
      const address_v6 & addr);



[endsect]



[section:overload2 ip::basic_address_iterator< address_v6 >::basic_address_iterator (2 of 2 overloads)]


Copy constructor. 


  basic_address_iterator(
      const basic_address_iterator & other);



[endsect]


[endsect]


[section:difference_type ip::basic_address_iterator< address_v6 >::difference_type]


Distance between two iterators. 


  typedef std::ptrdiff_t difference_type;




[endsect]



[section:iterator_category ip::basic_address_iterator< address_v6 >::iterator_category]


Denotes that the iterator satisfies the input iterator requirements. 


  typedef std::input_iterator_tag iterator_category;




[endsect]



[section:operator__star_ ip::basic_address_iterator< address_v6 >::operator *]


Dereference the iterator. 


  const address_v6 & operator *() const;



[endsect]



[section:operator_not__eq_ ip::basic_address_iterator< address_v6 >::operator!=]


Compare two addresses for inequality. 


  friend bool operator!=(
      const basic_address_iterator & a,
      const basic_address_iterator & b);



[endsect]


[section:operator_plus__plus_ ip::basic_address_iterator< address_v6 >::operator++]


Pre-increment operator. 


  basic_address_iterator & ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_.overload1 operator++]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_.overload1 more...]]``


Post-increment operator. 


  basic_address_iterator ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_.overload2 operator++]``(
      int );
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v6 >::operator++ (1 of 2 overloads)]


Pre-increment operator. 


  basic_address_iterator & operator++();



[endsect]



[section:overload2 ip::basic_address_iterator< address_v6 >::operator++ (2 of 2 overloads)]


Post-increment operator. 


  basic_address_iterator operator++(
      int );



[endsect]


[endsect]

[section:operator_minus__minus_ ip::basic_address_iterator< address_v6 >::operator--]


Pre-decrement operator. 


  basic_address_iterator & ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_.overload1 operator--]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_.overload1 more...]]``


Post-decrement operator. 


  basic_address_iterator ``[link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_.overload2 operator--]``(
      int );
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v6 >::operator-- (1 of 2 overloads)]


Pre-decrement operator. 


  basic_address_iterator & operator--();



[endsect]



[section:overload2 ip::basic_address_iterator< address_v6 >::operator-- (2 of 2 overloads)]


Post-decrement operator. 


  basic_address_iterator operator--(
      int );



[endsect]


[endsect]


[section:operator_arrow_ ip::basic_address_iterator< address_v6 >::operator->]


Dereference the iterator. 


  const address_v6 * operator->() const;



[endsect]



[section:operator_eq_ ip::basic_address_iterator< address_v6 >::operator=]


Assignment operator. 


  basic_address_iterator & operator=(
      const basic_address_iterator & other);



[endsect]



[section:operator_eq__eq_ ip::basic_address_iterator< address_v6 >::operator==]


Compare two addresses for equality. 


  friend bool operator==(
      const basic_address_iterator & a,
      const basic_address_iterator & b);



[endsect]



[section:pointer ip::basic_address_iterator< address_v6 >::pointer]


The type of a pointer to an element pointed to by the iterator. 


  typedef const address_v6 * pointer;




[endsect]



[section:reference ip::basic_address_iterator< address_v6 >::reference]


The type of a reference to an element pointed to by the iterator. 


  typedef const address_v6 & reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v6.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.address_v6 [*address_v6]]]
    [Default constructor. 

     Construct an address from raw bytes and scope ID. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_link_local [*is_link_local]]]
    [Determine whether the address is link local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_global [*is_multicast_global]]]
    [Determine whether the address is a global multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_link_local [*is_multicast_link_local]]]
    [Determine whether the address is a link-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_node_local [*is_multicast_node_local]]]
    [Determine whether the address is a node-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_org_local [*is_multicast_org_local]]]
    [Determine whether the address is a org-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_site_local [*is_multicast_site_local]]]
    [Determine whether the address is a site-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_site_local [*is_site_local]]]
    [Determine whether the address is site local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_v4_mapped [*is_v4_mapped]]]
    [Determine whether the address is a mapped IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.scope_id [*scope_id]]]
    [The scope ID of the address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_string [*to_string]]]
    [Get the address as a string. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.make_address_v6 [*make_address_v6]]]
    [Create an IPv6 address from raw bytes and scope ID. 

     Create an IPv6 address from an IP address string. 

     Createan IPv6 address from an IP address string. 

     Create an IPv4-mapped IPv6 address from an IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from an address and prefix length. ]
  ]
  
]

The std::experimental::net::ip::address\_v6 class provides the ability to use and manipulate IP version 6 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:value_type ip::basic_address_iterator< address_v6 >::value_type]


The type of the elements pointed to by the iterator. 


  typedef address_v6 value_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v6.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.address_v6 [*address_v6]]]
    [Default constructor. 

     Construct an address from raw bytes and scope ID. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_link_local [*is_link_local]]]
    [Determine whether the address is link local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_global [*is_multicast_global]]]
    [Determine whether the address is a global multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_link_local [*is_multicast_link_local]]]
    [Determine whether the address is a link-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_node_local [*is_multicast_node_local]]]
    [Determine whether the address is a node-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_org_local [*is_multicast_org_local]]]
    [Determine whether the address is a org-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_site_local [*is_multicast_site_local]]]
    [Determine whether the address is a site-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_site_local [*is_site_local]]]
    [Determine whether the address is site local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_v4_mapped [*is_v4_mapped]]]
    [Determine whether the address is a mapped IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.scope_id [*scope_id]]]
    [The scope ID of the address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_string [*to_string]]]
    [Get the address as a string. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.make_address_v6 [*make_address_v6]]]
    [Create an IPv6 address from raw bytes and scope ID. 

     Create an IPv6 address from an IP address string. 

     Createan IPv6 address from an IP address string. 

     Create an IPv4-mapped IPv6 address from an IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from an address and prefix length. ]
  ]
  
]

The std::experimental::net::ip::address\_v6 class provides the ability to use and manipulate IP version 6 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[endsect]

[section:ip__basic_address_range_lt__address_v4__gt_ ip::basic_address_range< address_v4 >]


Represents a range of IPv4 addresses. 


  template<>
  class basic_address_range< address_v4 >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.iterator [*iterator]]]
    [The type of an iterator that points into the range. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range [*basic_address_range]]]
    [Construct an empty range. 

     Construct an range that represents the given range of addresses. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.begin [*begin]]]
    [Obtain an iterator that points to the start of the range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.empty [*empty]]]
    [Determine whether the range is empty. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.end [*end]]]
    [Obtain an iterator that points to the end of the range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.find [*find]]]
    [Find an address in the range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.operator_eq_ [*operator=]]]
    [Assignment operator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.size [*size]]]
    [Return the size of the range. ]
  ]
  
]


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:basic_address_range ip::basic_address_range< address_v4 >::basic_address_range]


Construct an empty range. 


  ``[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload1 basic_address_range]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload1 more...]]``


Construct an range that represents the given range of addresses. 


  explicit ``[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload2 basic_address_range]``(
      const iterator & first,
      const iterator & last);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload2 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload3 basic_address_range]``(
      const basic_address_range & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload3 more...]]``


[section:overload1 ip::basic_address_range< address_v4 >::basic_address_range (1 of 3 overloads)]


Construct an empty range. 


  basic_address_range();



[endsect]



[section:overload2 ip::basic_address_range< address_v4 >::basic_address_range (2 of 3 overloads)]


Construct an range that represents the given range of addresses. 


  basic_address_range(
      const iterator & first,
      const iterator & last);



[endsect]



[section:overload3 ip::basic_address_range< address_v4 >::basic_address_range (3 of 3 overloads)]


Copy constructor. 


  basic_address_range(
      const basic_address_range & other);



[endsect]


[endsect]


[section:begin ip::basic_address_range< address_v4 >::begin]


Obtain an iterator that points to the start of the range. 


  iterator begin() const;



[endsect]



[section:empty ip::basic_address_range< address_v4 >::empty]


Determine whether the range is empty. 


  bool empty() const;



[endsect]



[section:end ip::basic_address_range< address_v4 >::end]


Obtain an iterator that points to the end of the range. 


  iterator end() const;



[endsect]



[section:find ip::basic_address_range< address_v4 >::find]


Find an address in the range. 


  iterator find(
      const address_v4 & addr) const;



[endsect]



[section:iterator ip::basic_address_range< address_v4 >::iterator]


The type of an iterator that points into the range. 


  typedef basic_address_iterator< address_v4 > iterator;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v4.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

  [

    [[link networking_ts.reference.ip__address_v4.uint_type [*uint_type]]]
    [The type used to represent an address as an unsigned integer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.address_v4 [*address_v4]]]
    [Default constructor. 

     Construct an address from raw bytes. 

     Construct an address from an unsigned integer in host byte order. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.broadcast [*broadcast]]]
    [Obtain an address object that represents the broadcast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_string [*to_string]]]
    [Get the address as a string in dotted decimal format. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.to_uint [*to_uint]]]
    [Get the address as an unsigned integer in host byte order. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v4.make_address_v4 [*make_address_v4]]]
    [Create an IPv4 address from raw bytes in network order. 

     Create an IPv4 address from an unsigned integer in host byte order. 

     Create an IPv4 address from an IP address string in dotted decimal form. 

     Create an IPv4 address from a IPv4-mapped IPv6 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from an address and prefix length. 

     Create an IPv4 network from an address and netmask. ]
  ]
  
]

The std::experimental::net::ip::address\_v4 class provides the ability to use and manipulate IP version 4 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:operator_eq_ ip::basic_address_range< address_v4 >::operator=]


Assignment operator. 


  basic_address_range & operator=(
      const basic_address_range & other);



[endsect]



[section:size ip::basic_address_range< address_v4 >::size]


Return the size of the range. 


  std::size_t size() const;



[endsect]



[endsect]

[section:ip__basic_address_range_lt__address_v6__gt_ ip::basic_address_range< address_v6 >]


Represents a range of IPv6 addresses. 


  template<>
  class basic_address_range< address_v6 >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.iterator [*iterator]]]
    [The type of an iterator that points into the range. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range [*basic_address_range]]]
    [Construct an empty range. 

     Construct an range that represents the given range of addresses. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.begin [*begin]]]
    [Obtain an iterator that points to the start of the range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.empty [*empty]]]
    [Determine whether the range is empty. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.end [*end]]]
    [Obtain an iterator that points to the end of the range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.find [*find]]]
    [Find an address in the range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.operator_eq_ [*operator=]]]
    [Assignment operator. ]
  ]
  
]


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:basic_address_range ip::basic_address_range< address_v6 >::basic_address_range]


Construct an empty range. 


  ``[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload1 basic_address_range]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload1 more...]]``


Construct an range that represents the given range of addresses. 


  explicit ``[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload2 basic_address_range]``(
      const iterator & first,
      const iterator & last);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload2 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload3 basic_address_range]``(
      const basic_address_range & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload3 more...]]``


[section:overload1 ip::basic_address_range< address_v6 >::basic_address_range (1 of 3 overloads)]


Construct an empty range. 


  basic_address_range();



[endsect]



[section:overload2 ip::basic_address_range< address_v6 >::basic_address_range (2 of 3 overloads)]


Construct an range that represents the given range of addresses. 


  basic_address_range(
      const iterator & first,
      const iterator & last);



[endsect]



[section:overload3 ip::basic_address_range< address_v6 >::basic_address_range (3 of 3 overloads)]


Copy constructor. 


  basic_address_range(
      const basic_address_range & other);



[endsect]


[endsect]


[section:begin ip::basic_address_range< address_v6 >::begin]


Obtain an iterator that points to the start of the range. 


  iterator begin() const;



[endsect]



[section:empty ip::basic_address_range< address_v6 >::empty]


Determine whether the range is empty. 


  bool empty() const;



[endsect]



[section:end ip::basic_address_range< address_v6 >::end]


Obtain an iterator that points to the end of the range. 


  iterator end() const;



[endsect]



[section:find ip::basic_address_range< address_v6 >::find]


Find an address in the range. 


  iterator find(
      const address_v6 & addr) const;



[endsect]



[section:iterator ip::basic_address_range< address_v6 >::iterator]


The type of an iterator that points into the range. 


  typedef basic_address_iterator< address_v6 > iterator;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__address_v6.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.address_v6 [*address_v6]]]
    [Default constructor. 

     Construct an address from raw bytes and scope ID. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.any [*any]]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_link_local [*is_link_local]]]
    [Determine whether the address is link local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_global [*is_multicast_global]]]
    [Determine whether the address is a global multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_link_local [*is_multicast_link_local]]]
    [Determine whether the address is a link-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_node_local [*is_multicast_node_local]]]
    [Determine whether the address is a node-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_org_local [*is_multicast_org_local]]]
    [Determine whether the address is a org-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_multicast_site_local [*is_multicast_site_local]]]
    [Determine whether the address is a site-local multicast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_site_local [*is_site_local]]]
    [Determine whether the address is site local. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.is_v4_mapped [*is_v4_mapped]]]
    [Determine whether the address is a mapped IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.loopback [*loopback]]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.scope_id [*scope_id]]]
    [The scope ID of the address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.to_string [*to_string]]]
    [Get the address as a string. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__address_v6.make_address_v6 [*make_address_v6]]]
    [Create an IPv6 address from raw bytes and scope ID. 

     Create an IPv6 address from an IP address string. 

     Createan IPv6 address from an IP address string. 

     Create an IPv4-mapped IPv6 address from an IPv4 address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__address_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from an address and prefix length. ]
  ]
  
]

The std::experimental::net::ip::address\_v6 class provides the ability to use and manipulate IP version 6 addresses.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:operator_eq_ ip::basic_address_range< address_v6 >::operator=]


Assignment operator. 


  basic_address_range & operator=(
      const basic_address_range & other);



[endsect]



[endsect]

[section:ip__basic_endpoint ip::basic_endpoint]


Describes an endpoint for a version-independent IP socket. 


  template<
      typename InternetProtocol>
  class basic_endpoint


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_endpoint.address [*address]]]
    [Get the IP address associated with the endpoint. 

     Set the IP address associated with the endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.basic_endpoint [*basic_endpoint]]]
    [Default constructor. 

     Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR_ANY or in6addr_any). This constructor would typically be used for accepting new connections. 

     Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 

     Copy constructor. 

     Move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. 

     Move-assign from another endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.port [*port]]]
    [Get the port associated with the endpoint. The port number is always in the host's byte order. 

     Set the port associated with the endpoint. The port number is always in the host's byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

The std::experimental::net::ip::basic\_endpoint class template describes an endpoint that may be associated with a particular socket.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.




[section:address ip::basic_endpoint::address]


Get the IP address associated with the endpoint. 


  std::experimental::net::ip::address ``[link networking_ts.reference.ip__basic_endpoint.address.overload1 address]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.address.overload1 more...]]``


Set the IP address associated with the endpoint. 


  void ``[link networking_ts.reference.ip__basic_endpoint.address.overload2 address]``(
      const std::experimental::net::ip::address & addr);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.address.overload2 more...]]``


[section:overload1 ip::basic_endpoint::address (1 of 2 overloads)]


Get the IP address associated with the endpoint. 


  std::experimental::net::ip::address address() const;



[endsect]



[section:overload2 ip::basic_endpoint::address (2 of 2 overloads)]


Set the IP address associated with the endpoint. 


  void address(
      const std::experimental::net::ip::address & addr);



[endsect]


[endsect]

[section:basic_endpoint ip::basic_endpoint::basic_endpoint]


Default constructor. 


  ``[link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload1 basic_endpoint]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload1 more...]]``


Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR\_ANY or in6addr\_any). This constructor would typically be used for accepting new connections. 


  ``[link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload2 basic_endpoint]``(
      const InternetProtocol & internet_protocol,
      unsigned short port_num);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload2 more...]]``


Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 


  ``[link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload3 basic_endpoint]``(
      const std::experimental::net::ip::address & addr,
      unsigned short port_num);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload3 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload4 basic_endpoint]``(
      const basic_endpoint & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload4 more...]]``


Move constructor. 


  ``[link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload5 basic_endpoint]``(
      basic_endpoint && other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.basic_endpoint.overload5 more...]]``


[section:overload1 ip::basic_endpoint::basic_endpoint (1 of 5 overloads)]


Default constructor. 


  basic_endpoint();



[endsect]



[section:overload2 ip::basic_endpoint::basic_endpoint (2 of 5 overloads)]


Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR\_ANY or in6addr\_any). This constructor would typically be used for accepting new connections. 


  basic_endpoint(
      const InternetProtocol & internet_protocol,
      unsigned short port_num);



[heading Examples]
  
To initialise an IPv4 TCP endpoint for port 1234, use: 

   std::experimental::net::ip::tcp::endpoint ep(std::experimental::net::ip::tcp::v4(), 1234);




To specify an IPv6 UDP endpoint for port 9876, use: 

   std::experimental::net::ip::udp::endpoint ep(std::experimental::net::ip::udp::v6(), 9876);





[endsect]



[section:overload3 ip::basic_endpoint::basic_endpoint (3 of 5 overloads)]


Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 


  basic_endpoint(
      const std::experimental::net::ip::address & addr,
      unsigned short port_num);



[endsect]



[section:overload4 ip::basic_endpoint::basic_endpoint (4 of 5 overloads)]


Copy constructor. 


  basic_endpoint(
      const basic_endpoint & other);



[endsect]



[section:overload5 ip::basic_endpoint::basic_endpoint (5 of 5 overloads)]


Move constructor. 


  basic_endpoint(
      basic_endpoint && other);



[endsect]


[endsect]


[section:capacity ip::basic_endpoint::capacity]


Get the capacity of the endpoint in the native type. 


  std::size_t capacity() const;



[endsect]


[section:data ip::basic_endpoint::data]


Get the underlying endpoint in the native type. 


  data_type * ``[link networking_ts.reference.ip__basic_endpoint.data.overload1 data]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.data.overload1 more...]]``

  const data_type * ``[link networking_ts.reference.ip__basic_endpoint.data.overload2 data]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.data.overload2 more...]]``


[section:overload1 ip::basic_endpoint::data (1 of 2 overloads)]


Get the underlying endpoint in the native type. 


  data_type * data();



[endsect]



[section:overload2 ip::basic_endpoint::data (2 of 2 overloads)]


Get the underlying endpoint in the native type. 


  const data_type * data() const;



[endsect]


[endsect]


[section:data_type ip::basic_endpoint::data_type]


The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. 


  typedef implementation_defined data_type;




[endsect]



[section:operator_not__eq_ ip::basic_endpoint::operator!=]


Compare two endpoints for inequality. 


  friend bool operator!=(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);



[endsect]



[section:operator_lt_ ip::basic_endpoint::operator<]


Compare endpoints for ordering. 


  friend bool operator<(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);



[endsect]



[section:operator_lt__eq_ ip::basic_endpoint::operator<=]


Compare endpoints for ordering. 


  friend bool operator<=(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);



[endsect]


[section:operator_eq_ ip::basic_endpoint::operator=]


Assign from another endpoint. 


  basic_endpoint & ``[link networking_ts.reference.ip__basic_endpoint.operator_eq_.overload1 operator=]``(
      const basic_endpoint & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.operator_eq_.overload1 more...]]``


Move-assign from another endpoint. 


  basic_endpoint & ``[link networking_ts.reference.ip__basic_endpoint.operator_eq_.overload2 operator=]``(
      basic_endpoint && other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.operator_eq_.overload2 more...]]``


[section:overload1 ip::basic_endpoint::operator= (1 of 2 overloads)]


Assign from another endpoint. 


  basic_endpoint & operator=(
      const basic_endpoint & other);



[endsect]



[section:overload2 ip::basic_endpoint::operator= (2 of 2 overloads)]


Move-assign from another endpoint. 


  basic_endpoint & operator=(
      basic_endpoint && other);



[endsect]


[endsect]


[section:operator_eq__eq_ ip::basic_endpoint::operator==]


Compare two endpoints for equality. 


  friend bool operator==(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);



[endsect]



[section:operator_gt_ ip::basic_endpoint::operator>]


Compare endpoints for ordering. 


  friend bool operator>(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);



[endsect]



[section:operator_gt__eq_ ip::basic_endpoint::operator>=]


Compare endpoints for ordering. 


  friend bool operator>=(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);



[endsect]


[section:port ip::basic_endpoint::port]


Get the port associated with the endpoint. The port number is always in the host's byte order. 


  unsigned short ``[link networking_ts.reference.ip__basic_endpoint.port.overload1 port]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.port.overload1 more...]]``


Set the port associated with the endpoint. The port number is always in the host's byte order. 


  void ``[link networking_ts.reference.ip__basic_endpoint.port.overload2 port]``(
      unsigned short port_num);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_endpoint.port.overload2 more...]]``


[section:overload1 ip::basic_endpoint::port (1 of 2 overloads)]


Get the port associated with the endpoint. The port number is always in the host's byte order. 


  unsigned short port() const;



[endsect]



[section:overload2 ip::basic_endpoint::port (2 of 2 overloads)]


Set the port associated with the endpoint. The port number is always in the host's byte order. 


  void port(
      unsigned short port_num);



[endsect]


[endsect]


[section:protocol ip::basic_endpoint::protocol]


The protocol associated with the endpoint. 


  protocol_type protocol() const;



[endsect]



[section:protocol_type ip::basic_endpoint::protocol_type]


The protocol type associated with the endpoint. 


  typedef InternetProtocol protocol_type;




[endsect]



[section:resize ip::basic_endpoint::resize]


Set the underlying size of the endpoint in the native type. 


  void resize(
      std::size_t new_size);



[endsect]



[section:size ip::basic_endpoint::size]


Get the underlying size of the endpoint in the native type. 


  std::size_t size() const;



[endsect]



[endsect]

[section:ip__basic_resolver ip::basic_resolver]


Provides endpoint resolution functionality. 


  template<
      typename InternetProtocol>
  class basic_resolver :
    public ip::resolver_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.results_type [*results_type]]]
    [The results type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver.async_resolve [*async_resolve]]]
    [Asynchronously perform forward resolution of a query to a list of entries. 

     Asynchronously perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.basic_resolver [*basic_resolver]]]
    [Constructor. 

     Move-construct a basic_resolver from another. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the resolver. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.operator_eq_ [*operator=]]]
    [Move-assign a basic_resolver from another. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.resolve [*resolve]]]
    [Perform forward resolution of a query to a list of entries. 

     Perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver._basic_resolver [*~basic_resolver]]]
    [Destroys the resolver. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver.address_configured [*address_configured]]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.all_matching [*all_matching]]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.canonical_name [*canonical_name]]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.numeric_host [*numeric_host]]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.numeric_service [*numeric_service]]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.passive [*passive]]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.v4_mapped [*v4_mapped]]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`] class template provides the ability to resolve a query to a list of endpoints.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 




[section:address_configured ip::basic_resolver::address_configured]


['Inherited from ip::resolver_base.]


Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. 


  static const flags address_configured = implementation_defined;



[endsect]



[section:all_matching ip::basic_resolver::all_matching]


['Inherited from ip::resolver_base.]


If used with v4\_mapped, return all matching IPv6 and IPv4 addresses. 


  static const flags all_matching = implementation_defined;



[endsect]


[section:async_resolve ip::basic_resolver::async_resolve]


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ResolveHandler>
  DEDUCED ``[link networking_ts.reference.ip__basic_resolver.async_resolve.overload1 async_resolve]``(
      string_view host,
      string_view service,
      ResolveHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.async_resolve.overload1 more...]]``

  template<
      typename ResolveHandler>
  DEDUCED ``[link networking_ts.reference.ip__basic_resolver.async_resolve.overload2 async_resolve]``(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      ResolveHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.async_resolve.overload2 more...]]``

  template<
      typename ResolveHandler>
  DEDUCED ``[link networking_ts.reference.ip__basic_resolver.async_resolve.overload3 async_resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      ResolveHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.async_resolve.overload3 more...]]``

  template<
      typename ResolveHandler>
  DEDUCED ``[link networking_ts.reference.ip__basic_resolver.async_resolve.overload4 async_resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      ResolveHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.async_resolve.overload4 more...]]``


Asynchronously perform reverse resolution of an endpoint to a list of entries. 


  template<
      typename ResolveHandler>
  DEDUCED ``[link networking_ts.reference.ip__basic_resolver.async_resolve.overload5 async_resolve]``(
      const endpoint_type & e,
      ResolveHandler && handler);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.async_resolve.overload5 more...]]``


[section:overload1 ip::basic_resolver::async_resolve (1 of 5 overloads)]


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ResolveHandler>
  DEDUCED async_resolve(
      string_view host,
      string_view service,
      ResolveHandler && handler);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload2 ip::basic_resolver::async_resolve (2 of 5 overloads)]


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ResolveHandler>
  DEDUCED async_resolve(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      ResolveHandler && handler);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload3 ip::basic_resolver::async_resolve (3 of 5 overloads)]


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ResolveHandler>
  DEDUCED async_resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      ResolveHandler && handler);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload4 ip::basic_resolver::async_resolve (4 of 5 overloads)]


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ResolveHandler>
  DEDUCED async_resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      ResolveHandler && handler);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload5 ip::basic_resolver::async_resolve (5 of 5 overloads)]


Asynchronously perform reverse resolution of an endpoint to a list of entries. 


  template<
      typename ResolveHandler>
  DEDUCED async_resolve(
      const endpoint_type & e,
      ResolveHandler && handler);


This function is used to asynchronously resolve an endpoint into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[e][An endpoint object that determines what endpoints will be returned.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const std::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `std::experimental::net::io_context::post()`.]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler. 


[endsect]


[endsect]

[section:basic_resolver ip::basic_resolver::basic_resolver]


Constructor. 


  explicit ``[link networking_ts.reference.ip__basic_resolver.basic_resolver.overload1 basic_resolver]``(
      std::experimental::net::io_context & io_context);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.basic_resolver.overload1 more...]]``


Move-construct a [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`] from another. 


  ``[link networking_ts.reference.ip__basic_resolver.basic_resolver.overload2 basic_resolver]``(
      basic_resolver && other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.basic_resolver.overload2 more...]]``


[section:overload1 ip::basic_resolver::basic_resolver (1 of 2 overloads)]


Constructor. 


  basic_resolver(
      std::experimental::net::io_context & io_context);


This constructor creates a [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`].


[heading Parameters]
    

[variablelist
  
[[io_context][The [link networking_ts.reference.io_context `io_context`] object that the resolver will use to dispatch handlers for any asynchronous operations performed on the resolver. ]]

]




[endsect]



[section:overload2 ip::basic_resolver::basic_resolver (2 of 2 overloads)]


Move-construct a [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`] from another. 


  basic_resolver(
      basic_resolver && other);


This constructor moves a resolver from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_resolver(io_context&) constructor`. 




[endsect]


[endsect]


[section:cancel ip::basic_resolver::cancel]


Cancel any asynchronous operations that are waiting on the resolver. 


  void cancel();


This function forces the completion of any pending asynchronous operations on the host resolver. The handler for each cancelled operation will be invoked with the std::experimental::net::error::operation\_aborted error code. 


[endsect]



[section:canonical_name ip::basic_resolver::canonical_name]


['Inherited from ip::resolver_base.]


Determine the canonical name of the host specified in the query. 


  static const flags canonical_name = implementation_defined;



[endsect]



[section:endpoint_type ip::basic_resolver::endpoint_type]


The endpoint type. 


  typedef InternetProtocol::endpoint endpoint_type;




[endsect]



[section:executor_type ip::basic_resolver::executor_type]


The type of the executor associated with the object. 


  typedef io_context::executor_type executor_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.defer [*defer]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.dispatch [*dispatch]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_finished [*on_work_finished]]]
    [Inform the io_context that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.on_work_started [*on_work_started]]]
    [Inform the io_context that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.post [*post]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the io_context is running in the current thread. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.io_context__executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.io_context__executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]



[endsect]



[section:flags ip::basic_resolver::flags]


['Inherited from ip::resolver_base.]


A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;




[endsect]



[section:get_executor ip::basic_resolver::get_executor]


Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:numeric_host ip::basic_resolver::numeric_host]


['Inherited from ip::resolver_base.]


Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. 


  static const flags numeric_host = implementation_defined;



[endsect]



[section:numeric_service ip::basic_resolver::numeric_service]


['Inherited from ip::resolver_base.]


Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. 


  static const flags numeric_service = implementation_defined;



[endsect]



[section:operator_eq_ ip::basic_resolver::operator=]


Move-assign a [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`] from another. 


  basic_resolver & operator=(
      basic_resolver && other);


This assignment operator moves a resolver from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_resolver(io_context&) constructor`. 




[endsect]



[section:passive ip::basic_resolver::passive]


['Inherited from ip::resolver_base.]


Indicate that returned endpoint is intended for use as a locally bound socket endpoint. 


  static const flags passive = implementation_defined;



[endsect]



[section:protocol_type ip::basic_resolver::protocol_type]


The protocol type. 


  typedef InternetProtocol protocol_type;




[endsect]


[section:resolve ip::basic_resolver::resolve]


Perform forward resolution of a query to a list of entries. 


  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload1 resolve]``(
      string_view host,
      string_view service);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload1 more...]]``

  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload2 resolve]``(
      string_view host,
      string_view service,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload2 more...]]``

  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload3 resolve]``(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload3 more...]]``

  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload4 resolve]``(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload4 more...]]``

  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload5 resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload5 more...]]``

  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload6 resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload6 more...]]``

  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload7 resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload7 more...]]``

  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload8 resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload8 more...]]``


Perform reverse resolution of an endpoint to a list of entries. 


  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload9 resolve]``(
      const endpoint_type & e);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload9 more...]]``

  results_type ``[link networking_ts.reference.ip__basic_resolver.resolve.overload10 resolve]``(
      const endpoint_type & e,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver.resolve.overload10 more...]]``


[section:overload1 ip::basic_resolver::resolve (1 of 10 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      string_view host,
      string_view service);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload2 ip::basic_resolver::resolve (2 of 10 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      string_view host,
      string_view service,
      std::error_code & ec);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload3 ip::basic_resolver::resolve (3 of 10 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload4 ip::basic_resolver::resolve (4 of 10 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      std::error_code & ec);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload5 ip::basic_resolver::resolve (5 of 10 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload6 ip::basic_resolver::resolve (6 of 10 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      std::error_code & ec);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload7 ip::basic_resolver::resolve (7 of 10 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload8 ip::basic_resolver::resolve (8 of 10 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      std::error_code & ec);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload9 ip::basic_resolver::resolve (9 of 10 overloads)]


Perform reverse resolution of an endpoint to a list of entries. 


  results_type resolve(
      const endpoint_type & e);


This function is used to resolve an endpoint into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[e][An endpoint object that determines what endpoints will be returned.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload10 ip::basic_resolver::resolve (10 of 10 overloads)]


Perform reverse resolution of an endpoint to a list of entries. 


  results_type resolve(
      const endpoint_type & e,
      std::error_code & ec);


This function is used to resolve an endpoint into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[e][An endpoint object that determines what endpoints will be returned.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range. 




[endsect]


[endsect]


[section:results_type ip::basic_resolver::results_type]


The results type. 


  typedef basic_resolver_results< InternetProtocol > results_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.const_iterator [*const_iterator]]]
    [The type of an iterator into the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.const_reference [*const_reference]]]
    [The type of a const reference to a value in the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.difference_type [*difference_type]]]
    [Type used to represent the distance between two iterators in the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the results. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.iterator [*iterator]]]
    [The type of an iterator into the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.protocol_type [*protocol_type]]]
    [The protocol type associated with the results. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.reference [*reference]]]
    [The type of a non-const reference to a value in the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.size_type [*size_type]]]
    [Type used to represent a count of the elements in the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.value_type [*value_type]]]
    [The type of a value in the results range. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_results.basic_resolver_results [*basic_resolver_results]]]
    [Default constructor creates an empty range. 

     Copy constructor. 

     Move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.begin [*begin]]]
    [Obtain a begin iterator for the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.cbegin [*cbegin]]]
    [Obtain a begin iterator for the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.cend [*cend]]]
    [Obtain an end iterator for the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.empty [*empty]]]
    [Determine whether the results range is empty. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.end [*end]]]
    [Obtain an end iterator for the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.max_size [*max_size]]]
    [Get the maximum number of entries permitted in a results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.operator_eq_ [*operator=]]]
    [Assignment operator. 

     Move-assignment operator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.size [*size]]]
    [Get the number of entries in the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.swap [*swap]]]
    [Swap the results range with another. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_results.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_results class template is used to define a range over the results returned by a resolver.

The iterator's value\_type, obtained when a results iterator is dereferenced, is:

   const basic_resolver_entry<InternetProtocol> 





[heading Remarks]
      
For backward compatibility, [link networking_ts.reference.ip__basic_resolver_results `ip::basic_resolver_results`] is derived from [link networking_ts.reference.ip__basic_resolver_iterator `ip::basic_resolver_iterator`]. This derivation is deprecated.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:v4_mapped ip::basic_resolver::v4_mapped]


['Inherited from ip::resolver_base.]


If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. 


  static const flags v4_mapped = implementation_defined;



[endsect]



[section:_basic_resolver ip::basic_resolver::~basic_resolver]


Destroys the resolver. 


  ~basic_resolver();


This function destroys the resolver, cancelling any outstanding asynchronous wait operations associated with the resolver as if by calling `cancel`. 


[endsect]



[endsect]

[section:ip__basic_resolver_entry ip::basic_resolver_entry]


An entry produced by a resolver. 


  template<
      typename InternetProtocol>
  class basic_resolver_entry


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]]]
    [Default constructor. 

     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_entry class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:basic_resolver_entry ip::basic_resolver_entry::basic_resolver_entry]


Default constructor. 


  ``[link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry.overload1 basic_resolver_entry]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry.overload1 more...]]``


Construct with specified endpoint, host name and service name. 


  ``[link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry.overload2 basic_resolver_entry]``(
      const endpoint_type & ep,
      string_view host,
      string_view service);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry.overload2 more...]]``


[section:overload1 ip::basic_resolver_entry::basic_resolver_entry (1 of 2 overloads)]


Default constructor. 


  basic_resolver_entry();



[endsect]



[section:overload2 ip::basic_resolver_entry::basic_resolver_entry (2 of 2 overloads)]


Construct with specified endpoint, host name and service name. 


  basic_resolver_entry(
      const endpoint_type & ep,
      string_view host,
      string_view service);



[endsect]


[endsect]


[section:endpoint ip::basic_resolver_entry::endpoint]


Get the endpoint associated with the entry. 


  endpoint_type endpoint() const;



[endsect]



[section:endpoint_type ip::basic_resolver_entry::endpoint_type]


The endpoint type associated with the endpoint entry. 


  typedef InternetProtocol::endpoint endpoint_type;




[endsect]


[section:host_name ip::basic_resolver_entry::host_name]


Get the host name associated with the entry. 


  std::string ``[link networking_ts.reference.ip__basic_resolver_entry.host_name.overload1 host_name]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_entry.host_name.overload1 more...]]``

  template<
      class Allocator>
  std::basic_string< char, std::char_traits< char >, Allocator > ``[link networking_ts.reference.ip__basic_resolver_entry.host_name.overload2 host_name]``(
      const Allocator & alloc = Allocator()) const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_entry.host_name.overload2 more...]]``


[section:overload1 ip::basic_resolver_entry::host_name (1 of 2 overloads)]


Get the host name associated with the entry. 


  std::string host_name() const;



[endsect]



[section:overload2 ip::basic_resolver_entry::host_name (2 of 2 overloads)]


Get the host name associated with the entry. 


  template<
      class Allocator>
  std::basic_string< char, std::char_traits< char >, Allocator > host_name(
      const Allocator & alloc = Allocator()) const;



[endsect]


[endsect]


[section:operator_endpoint_type ip::basic_resolver_entry::operator endpoint_type]


Convert to the endpoint associated with the entry. 


  operator endpoint_type() const;



[endsect]



[section:protocol_type ip::basic_resolver_entry::protocol_type]


The protocol type associated with the endpoint entry. 


  typedef InternetProtocol protocol_type;




[endsect]


[section:service_name ip::basic_resolver_entry::service_name]


Get the service name associated with the entry. 


  std::string ``[link networking_ts.reference.ip__basic_resolver_entry.service_name.overload1 service_name]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_entry.service_name.overload1 more...]]``

  template<
      class Allocator>
  std::basic_string< char, std::char_traits< char >, Allocator > ``[link networking_ts.reference.ip__basic_resolver_entry.service_name.overload2 service_name]``(
      const Allocator & alloc = Allocator()) const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_entry.service_name.overload2 more...]]``


[section:overload1 ip::basic_resolver_entry::service_name (1 of 2 overloads)]


Get the service name associated with the entry. 


  std::string service_name() const;



[endsect]



[section:overload2 ip::basic_resolver_entry::service_name (2 of 2 overloads)]


Get the service name associated with the entry. 


  template<
      class Allocator>
  std::basic_string< char, std::char_traits< char >, Allocator > service_name(
      const Allocator & alloc = Allocator()) const;



[endsect]


[endsect]


[endsect]

[section:ip__basic_resolver_iterator ip::basic_resolver_iterator]


An iterator over the entries produced by a resolver. 


  template<
      typename InternetProtocol>
  class basic_resolver_iterator


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.difference_type [*difference_type]]]
    [The type used for the distance between two iterators. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.reference [*reference]]]
    [The type of the result of applying operator*() to the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.value_type [*value_type]]]
    [The type of the value pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.basic_resolver_iterator [*basic_resolver_iterator]]]
    [Default constructor creates an end iterator. 

     Copy constructor. 

     Move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 

     Increment operator (postfix). ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_eq_ [*operator=]]]
    [Assignment operator. 

     Move-assignment operator. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.dereference [*dereference]]]
    []
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.equal [*equal]]]
    []
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.increment [*increment]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.index_ [*index_]]]
    []
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.values_ [*values_]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_iterator class template is used to define iterators over the results returned by a resolver.

The iterator's value\_type, obtained when the iterator is dereferenced, is: 

   const basic_resolver_entry<InternetProtocol> 





[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:basic_resolver_iterator ip::basic_resolver_iterator::basic_resolver_iterator]


Default constructor creates an end iterator. 


  ``[link networking_ts.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload1 basic_resolver_iterator]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload1 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload2 basic_resolver_iterator]``(
      const basic_resolver_iterator & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload2 more...]]``


Move constructor. 


  ``[link networking_ts.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload3 basic_resolver_iterator]``(
      basic_resolver_iterator && other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload3 more...]]``


[section:overload1 ip::basic_resolver_iterator::basic_resolver_iterator (1 of 3 overloads)]


Default constructor creates an end iterator. 


  basic_resolver_iterator();



[endsect]



[section:overload2 ip::basic_resolver_iterator::basic_resolver_iterator (2 of 3 overloads)]


Copy constructor. 


  basic_resolver_iterator(
      const basic_resolver_iterator & other);



[endsect]



[section:overload3 ip::basic_resolver_iterator::basic_resolver_iterator (3 of 3 overloads)]


Move constructor. 


  basic_resolver_iterator(
      basic_resolver_iterator && other);



[endsect]


[endsect]


[section:dereference ip::basic_resolver_iterator::dereference]



  const basic_resolver_entry< InternetProtocol > & dereference() const;



[endsect]



[section:difference_type ip::basic_resolver_iterator::difference_type]


The type used for the distance between two iterators. 


  typedef std::ptrdiff_t difference_type;




[endsect]



[section:equal ip::basic_resolver_iterator::equal]



  bool equal(
      const basic_resolver_iterator & other) const;



[endsect]



[section:increment ip::basic_resolver_iterator::increment]



  void increment();



[endsect]



[section:index_ ip::basic_resolver_iterator::index_]



  std::size_t index_;



[endsect]



[section:iterator_category ip::basic_resolver_iterator::iterator_category]


The iterator category. 


  typedef std::forward_iterator_tag iterator_category;




[endsect]



[section:operator__star_ ip::basic_resolver_iterator::operator *]


Dereference an iterator. 


  const basic_resolver_entry< InternetProtocol > & operator *() const;



[endsect]



[section:operator_not__eq_ ip::basic_resolver_iterator::operator!=]


Test two iterators for inequality. 


  friend bool operator!=(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);



[endsect]


[section:operator_plus__plus_ ip::basic_resolver_iterator::operator++]


Increment operator (prefix). 


  basic_resolver_iterator & ``[link networking_ts.reference.ip__basic_resolver_iterator.operator_plus__plus_.overload1 operator++]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_iterator.operator_plus__plus_.overload1 more...]]``


Increment operator (postfix). 


  basic_resolver_iterator ``[link networking_ts.reference.ip__basic_resolver_iterator.operator_plus__plus_.overload2 operator++]``(
      int );
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_iterator.operator_plus__plus_.overload2 more...]]``


[section:overload1 ip::basic_resolver_iterator::operator++ (1 of 2 overloads)]


Increment operator (prefix). 


  basic_resolver_iterator & operator++();



[endsect]



[section:overload2 ip::basic_resolver_iterator::operator++ (2 of 2 overloads)]


Increment operator (postfix). 


  basic_resolver_iterator operator++(
      int );



[endsect]


[endsect]


[section:operator_arrow_ ip::basic_resolver_iterator::operator->]


Dereference an iterator. 


  const basic_resolver_entry< InternetProtocol > * operator->() const;



[endsect]


[section:operator_eq_ ip::basic_resolver_iterator::operator=]


Assignment operator. 


  basic_resolver_iterator & ``[link networking_ts.reference.ip__basic_resolver_iterator.operator_eq_.overload1 operator=]``(
      const basic_resolver_iterator & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_iterator.operator_eq_.overload1 more...]]``


Move-assignment operator. 


  basic_resolver_iterator & ``[link networking_ts.reference.ip__basic_resolver_iterator.operator_eq_.overload2 operator=]``(
      basic_resolver_iterator && other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_iterator.operator_eq_.overload2 more...]]``


[section:overload1 ip::basic_resolver_iterator::operator= (1 of 2 overloads)]


Assignment operator. 


  basic_resolver_iterator & operator=(
      const basic_resolver_iterator & other);



[endsect]



[section:overload2 ip::basic_resolver_iterator::operator= (2 of 2 overloads)]


Move-assignment operator. 


  basic_resolver_iterator & operator=(
      basic_resolver_iterator && other);



[endsect]


[endsect]


[section:operator_eq__eq_ ip::basic_resolver_iterator::operator==]


Test two iterators for equality. 


  friend bool operator==(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);



[endsect]



[section:pointer ip::basic_resolver_iterator::pointer]


The type of the result of applying `operator->()` to the iterator. 


  typedef const basic_resolver_entry< InternetProtocol > * pointer;




[endsect]



[section:reference ip::basic_resolver_iterator::reference]


The type of the result of applying `operator*()` to the iterator. 


  typedef const basic_resolver_entry< InternetProtocol > & reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]]]
    [Default constructor. 

     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_entry class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:value_type ip::basic_resolver_iterator::value_type]


The type of the value pointed to by the iterator. 


  typedef basic_resolver_entry< InternetProtocol > value_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]]]
    [Default constructor. 

     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_entry class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:values_ ip::basic_resolver_iterator::values_]



  values_ptr_type values_;



[endsect]



[endsect]

[section:ip__basic_resolver_query ip::basic_resolver_query]


An query to be passed to a resolver. 


  template<
      typename InternetProtocol>
  class basic_resolver_query :
    public ip::resolver_query_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_query.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_query.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint query. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_query.basic_resolver_query [*basic_resolver_query]]]
    [Construct with specified service name for any protocol. 

     Construct with specified service name for a given protocol. 

     Construct with specified host name and service name for any protocol. 

     Construct with specified host name and service name for a given protocol. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_query.hints [*hints]]]
    [Get the hints associated with the query. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_query.host_name [*host_name]]]
    [Get the host name associated with the query. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_query.service_name [*service_name]]]
    [Get the service name associated with the query. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_query.address_configured [*address_configured]]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver_query.all_matching [*all_matching]]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver_query.canonical_name [*canonical_name]]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver_query.numeric_host [*numeric_host]]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver_query.numeric_service [*numeric_service]]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver_query.passive [*passive]]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver_query.v4_mapped [*v4_mapped]]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The std::experimental::net::ip::basic\_resolver\_query class template describes a query that can be passed to a resolver.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 




[section:address_configured ip::basic_resolver_query::address_configured]


['Inherited from ip::resolver_base.]


Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. 


  static const flags address_configured = implementation_defined;



[endsect]



[section:all_matching ip::basic_resolver_query::all_matching]


['Inherited from ip::resolver_base.]


If used with v4\_mapped, return all matching IPv6 and IPv4 addresses. 


  static const flags all_matching = implementation_defined;



[endsect]


[section:basic_resolver_query ip::basic_resolver_query::basic_resolver_query]


Construct with specified service name for any protocol. 


  ``[link networking_ts.reference.ip__basic_resolver_query.basic_resolver_query.overload1 basic_resolver_query]``(
      const std::string & service,
      resolver_query_base::flags resolve_flags = passive|address_configured);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_query.basic_resolver_query.overload1 more...]]``


Construct with specified service name for a given protocol. 


  ``[link networking_ts.reference.ip__basic_resolver_query.basic_resolver_query.overload2 basic_resolver_query]``(
      const protocol_type & protocol,
      const std::string & service,
      resolver_query_base::flags resolve_flags = passive|address_configured);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_query.basic_resolver_query.overload2 more...]]``


Construct with specified host name and service name for any protocol. 


  ``[link networking_ts.reference.ip__basic_resolver_query.basic_resolver_query.overload3 basic_resolver_query]``(
      const std::string & host,
      const std::string & service,
      resolver_query_base::flags resolve_flags = address_configured);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_query.basic_resolver_query.overload3 more...]]``


Construct with specified host name and service name for a given protocol. 


  ``[link networking_ts.reference.ip__basic_resolver_query.basic_resolver_query.overload4 basic_resolver_query]``(
      const protocol_type & protocol,
      const std::string & host,
      const std::string & service,
      resolver_query_base::flags resolve_flags = address_configured);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_query.basic_resolver_query.overload4 more...]]``


[section:overload1 ip::basic_resolver_query::basic_resolver_query (1 of 4 overloads)]


Construct with specified service name for any protocol. 


  basic_resolver_query(
      const std::string & service,
      resolver_query_base::flags resolve_flags = passive|address_configured);


This constructor is typically used to perform name resolution for local service binding.


[heading Parameters]
    

[variablelist
  
[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for local service binding.]]

]


[heading Remarks]
      
On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 




[endsect]



[section:overload2 ip::basic_resolver_query::basic_resolver_query (2 of 4 overloads)]


Construct with specified service name for a given protocol. 


  basic_resolver_query(
      const protocol_type & protocol,
      const std::string & service,
      resolver_query_base::flags resolve_flags = passive|address_configured);


This constructor is typically used to perform name resolution for local service binding with a specific protocol version.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for local service binding.]]

]


[heading Remarks]
      
On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 




[endsect]



[section:overload3 ip::basic_resolver_query::basic_resolver_query (3 of 4 overloads)]


Construct with specified host name and service name for any protocol. 


  basic_resolver_query(
      const std::string & host,
      const std::string & service,
      resolver_query_base::flags resolve_flags = address_configured);


This constructor is typically used to perform name resolution for communication with remote hosts.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload4 ip::basic_resolver_query::basic_resolver_query (4 of 4 overloads)]


Construct with specified host name and service name for a given protocol. 


  basic_resolver_query(
      const protocol_type & protocol,
      const std::string & host,
      const std::string & service,
      resolver_query_base::flags resolve_flags = address_configured);


This constructor is typically used to perform name resolution for communication with remote hosts.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]


[endsect]


[section:canonical_name ip::basic_resolver_query::canonical_name]


['Inherited from ip::resolver_base.]


Determine the canonical name of the host specified in the query. 


  static const flags canonical_name = implementation_defined;



[endsect]



[section:flags ip::basic_resolver_query::flags]


['Inherited from ip::resolver_base.]


A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;




[endsect]



[section:hints ip::basic_resolver_query::hints]


Get the hints associated with the query. 


  const std::experimental::net::detail::addrinfo_type & hints() const;



[endsect]



[section:host_name ip::basic_resolver_query::host_name]


Get the host name associated with the query. 


  std::string host_name() const;



[endsect]



[section:numeric_host ip::basic_resolver_query::numeric_host]


['Inherited from ip::resolver_base.]


Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. 


  static const flags numeric_host = implementation_defined;



[endsect]



[section:numeric_service ip::basic_resolver_query::numeric_service]


['Inherited from ip::resolver_base.]


Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. 


  static const flags numeric_service = implementation_defined;



[endsect]



[section:passive ip::basic_resolver_query::passive]


['Inherited from ip::resolver_base.]


Indicate that returned endpoint is intended for use as a locally bound socket endpoint. 


  static const flags passive = implementation_defined;



[endsect]



[section:protocol_type ip::basic_resolver_query::protocol_type]


The protocol type associated with the endpoint query. 


  typedef InternetProtocol protocol_type;




[endsect]



[section:service_name ip::basic_resolver_query::service_name]


Get the service name associated with the query. 


  std::string service_name() const;



[endsect]



[section:v4_mapped ip::basic_resolver_query::v4_mapped]


['Inherited from ip::resolver_base.]


If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. 


  static const flags v4_mapped = implementation_defined;



[endsect]



[endsect]

[section:ip__basic_resolver_results ip::basic_resolver_results]


A range of entries produced by a resolver. 


  template<
      typename InternetProtocol>
  class basic_resolver_results :
    ip::basic_resolver_iterator< InternetProtocol >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.const_iterator [*const_iterator]]]
    [The type of an iterator into the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.const_reference [*const_reference]]]
    [The type of a const reference to a value in the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.difference_type [*difference_type]]]
    [Type used to represent the distance between two iterators in the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the results. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.iterator [*iterator]]]
    [The type of an iterator into the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.protocol_type [*protocol_type]]]
    [The protocol type associated with the results. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.reference [*reference]]]
    [The type of a non-const reference to a value in the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.size_type [*size_type]]]
    [Type used to represent a count of the elements in the range. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_results.value_type [*value_type]]]
    [The type of a value in the results range. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_results.basic_resolver_results [*basic_resolver_results]]]
    [Default constructor creates an empty range. 

     Copy constructor. 

     Move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.begin [*begin]]]
    [Obtain a begin iterator for the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.cbegin [*cbegin]]]
    [Obtain a begin iterator for the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.cend [*cend]]]
    [Obtain an end iterator for the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.empty [*empty]]]
    [Determine whether the results range is empty. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.end [*end]]]
    [Obtain an end iterator for the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.max_size [*max_size]]]
    [Get the maximum number of entries permitted in a results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.operator_eq_ [*operator=]]]
    [Assignment operator. 

     Move-assignment operator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.size [*size]]]
    [Get the number of entries in the results range. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.swap [*swap]]]
    [Swap the results range with another. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_results.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_results.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_results class template is used to define a range over the results returned by a resolver.

The iterator's value\_type, obtained when a results iterator is dereferenced, is:

   const basic_resolver_entry<InternetProtocol> 





[heading Remarks]
      
For backward compatibility, [link networking_ts.reference.ip__basic_resolver_results `ip::basic_resolver_results`] is derived from [link networking_ts.reference.ip__basic_resolver_iterator `ip::basic_resolver_iterator`]. This derivation is deprecated.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 



[section:basic_resolver_results ip::basic_resolver_results::basic_resolver_results]


Default constructor creates an empty range. 


  ``[link networking_ts.reference.ip__basic_resolver_results.basic_resolver_results.overload1 basic_resolver_results]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_results.basic_resolver_results.overload1 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__basic_resolver_results.basic_resolver_results.overload2 basic_resolver_results]``(
      const basic_resolver_results & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_results.basic_resolver_results.overload2 more...]]``


Move constructor. 


  ``[link networking_ts.reference.ip__basic_resolver_results.basic_resolver_results.overload3 basic_resolver_results]``(
      basic_resolver_results && other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_results.basic_resolver_results.overload3 more...]]``


[section:overload1 ip::basic_resolver_results::basic_resolver_results (1 of 3 overloads)]


Default constructor creates an empty range. 


  basic_resolver_results();



[endsect]



[section:overload2 ip::basic_resolver_results::basic_resolver_results (2 of 3 overloads)]


Copy constructor. 


  basic_resolver_results(
      const basic_resolver_results & other);



[endsect]



[section:overload3 ip::basic_resolver_results::basic_resolver_results (3 of 3 overloads)]


Move constructor. 


  basic_resolver_results(
      basic_resolver_results && other);



[endsect]


[endsect]


[section:begin ip::basic_resolver_results::begin]


Obtain a begin iterator for the results range. 


  const_iterator begin() const;



[endsect]



[section:cbegin ip::basic_resolver_results::cbegin]


Obtain a begin iterator for the results range. 


  const_iterator cbegin() const;



[endsect]



[section:cend ip::basic_resolver_results::cend]


Obtain an end iterator for the results range. 


  const_iterator cend() const;



[endsect]



[section:const_iterator ip::basic_resolver_results::const_iterator]


The type of an iterator into the range. 


  typedef basic_resolver_iterator< protocol_type > const_iterator;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.difference_type [*difference_type]]]
    [The type used for the distance between two iterators. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.reference [*reference]]]
    [The type of the result of applying operator*() to the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.value_type [*value_type]]]
    [The type of the value pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.basic_resolver_iterator [*basic_resolver_iterator]]]
    [Default constructor creates an end iterator. 

     Copy constructor. 

     Move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 

     Increment operator (postfix). ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_eq_ [*operator=]]]
    [Assignment operator. 

     Move-assignment operator. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.dereference [*dereference]]]
    []
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.equal [*equal]]]
    []
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.increment [*increment]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.index_ [*index_]]]
    []
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.values_ [*values_]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_iterator class template is used to define iterators over the results returned by a resolver.

The iterator's value\_type, obtained when the iterator is dereferenced, is: 

   const basic_resolver_entry<InternetProtocol> 





[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:const_reference ip::basic_resolver_results::const_reference]


The type of a const reference to a value in the range. 


  typedef const value_type & const_reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]]]
    [Default constructor. 

     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_entry class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:difference_type ip::basic_resolver_results::difference_type]


Type used to represent the distance between two iterators in the range. 


  typedef std::ptrdiff_t difference_type;




[endsect]



[section:empty ip::basic_resolver_results::empty]


Determine whether the results range is empty. 


  bool empty() const;



[endsect]



[section:end ip::basic_resolver_results::end]


Obtain an end iterator for the results range. 


  const_iterator end() const;



[endsect]



[section:endpoint_type ip::basic_resolver_results::endpoint_type]


The endpoint type associated with the results. 


  typedef protocol_type::endpoint endpoint_type;




[endsect]



[section:iterator ip::basic_resolver_results::iterator]


The type of an iterator into the range. 


  typedef const_iterator iterator;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.difference_type [*difference_type]]]
    [The type used for the distance between two iterators. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.reference [*reference]]]
    [The type of the result of applying operator*() to the iterator. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_iterator.value_type [*value_type]]]
    [The type of the value pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.basic_resolver_iterator [*basic_resolver_iterator]]]
    [Default constructor creates an end iterator. 

     Copy constructor. 

     Move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 

     Increment operator (postfix). ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_eq_ [*operator=]]]
    [Assignment operator. 

     Move-assignment operator. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.dereference [*dereference]]]
    []
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.equal [*equal]]]
    []
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.increment [*increment]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.index_ [*index_]]]
    []
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.values_ [*values_]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_iterator.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_iterator class template is used to define iterators over the results returned by a resolver.

The iterator's value\_type, obtained when the iterator is dereferenced, is: 

   const basic_resolver_entry<InternetProtocol> 





[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:max_size ip::basic_resolver_results::max_size]


Get the maximum number of entries permitted in a results range. 


  size_type max_size() const;



[endsect]


[section:operator_not__eq_ ip::basic_resolver_results::operator!=]


Test two iterators for inequality. 


  friend bool ``[link networking_ts.reference.ip__basic_resolver_results.operator_not__eq_.overload1 operator!=]``(
      const basic_resolver_results & a,
      const basic_resolver_results & b);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_results.operator_not__eq_.overload1 more...]]``

  friend bool ``[link networking_ts.reference.ip__basic_resolver_results.operator_not__eq_.overload2 operator!=]``(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_results.operator_not__eq_.overload2 more...]]``


[section:overload1 ip::basic_resolver_results::operator!= (1 of 2 overloads)]


Test two iterators for inequality. 


  friend bool operator!=(
      const basic_resolver_results & a,
      const basic_resolver_results & b);



[endsect]



[section:overload2 ip::basic_resolver_results::operator!= (2 of 2 overloads)]


['Inherited from ip::basic_resolver.]


Test two iterators for inequality. 


  friend bool operator!=(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);



[endsect]


[endsect]

[section:operator_eq_ ip::basic_resolver_results::operator=]


Assignment operator. 


  basic_resolver_results & ``[link networking_ts.reference.ip__basic_resolver_results.operator_eq_.overload1 operator=]``(
      const basic_resolver_results & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_results.operator_eq_.overload1 more...]]``


Move-assignment operator. 


  basic_resolver_results & ``[link networking_ts.reference.ip__basic_resolver_results.operator_eq_.overload2 operator=]``(
      basic_resolver_results && other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_results.operator_eq_.overload2 more...]]``


[section:overload1 ip::basic_resolver_results::operator= (1 of 2 overloads)]


Assignment operator. 


  basic_resolver_results & operator=(
      const basic_resolver_results & other);



[endsect]



[section:overload2 ip::basic_resolver_results::operator= (2 of 2 overloads)]


Move-assignment operator. 


  basic_resolver_results & operator=(
      basic_resolver_results && other);



[endsect]


[endsect]

[section:operator_eq__eq_ ip::basic_resolver_results::operator==]


Test two iterators for equality. 


  friend bool ``[link networking_ts.reference.ip__basic_resolver_results.operator_eq__eq_.overload1 operator==]``(
      const basic_resolver_results & a,
      const basic_resolver_results & b);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_results.operator_eq__eq_.overload1 more...]]``

  friend bool ``[link networking_ts.reference.ip__basic_resolver_results.operator_eq__eq_.overload2 operator==]``(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__basic_resolver_results.operator_eq__eq_.overload2 more...]]``


[section:overload1 ip::basic_resolver_results::operator== (1 of 2 overloads)]


Test two iterators for equality. 


  friend bool operator==(
      const basic_resolver_results & a,
      const basic_resolver_results & b);



[endsect]



[section:overload2 ip::basic_resolver_results::operator== (2 of 2 overloads)]


['Inherited from ip::basic_resolver.]


Test two iterators for equality. 


  friend bool operator==(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);



[endsect]


[endsect]


[section:protocol_type ip::basic_resolver_results::protocol_type]


The protocol type associated with the results. 


  typedef InternetProtocol protocol_type;




[endsect]



[section:reference ip::basic_resolver_results::reference]


The type of a non-const reference to a value in the range. 


  typedef value_type & reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]]]
    [Default constructor. 

     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_entry class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:size ip::basic_resolver_results::size]


Get the number of entries in the results range. 


  size_type size() const;



[endsect]



[section:size_type ip::basic_resolver_results::size_type]


Type used to represent a count of the elements in the range. 


  typedef std::size_t size_type;




[endsect]



[section:swap ip::basic_resolver_results::swap]


Swap the results range with another. 


  void swap(
      basic_resolver_results & that);



[endsect]



[section:value_type ip::basic_resolver_results::value_type]


The type of a value in the results range. 


  typedef basic_resolver_entry< endpoint_type > value_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]]]
    [Default constructor. 

     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The std::experimental::net::ip::basic\_resolver\_entry class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[endsect]

[section:ip__host_name ip::host_name]


Get the current host name. 

    
  std::string ``[link networking_ts.reference.ip__host_name.overload1 host_name]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__host_name.overload1 more...]]``

  std::string ``[link networking_ts.reference.ip__host_name.overload2 host_name]``(
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__host_name.overload2 more...]]``


[section:overload1 ip::host_name (1 of 2 overloads)]


Get the current host name. 


  std::string host_name();



[endsect]



[section:overload2 ip::host_name (2 of 2 overloads)]


Get the current host name. 


  std::string host_name(
      std::error_code & ec);



[endsect]


[endsect]


[section:ip__multicast__enable_loopback ip::multicast::enable_loopback]


Socket option determining whether outgoing multicast packets will be received on the same socket if it is a member of the multicast group. 


  typedef implementation_defined enable_loopback;



Implements the IPPROTO\_IP/IP\_MULTICAST\_LOOP socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::ip::multicast::enable_loopback option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::ip::multicast::enable_loopback option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:ip__multicast__hops ip::multicast::hops]


Socket option for time-to-live associated with outgoing multicast packets. 


  typedef implementation_defined hops;



Implements the IPPROTO\_IP/IP\_MULTICAST\_TTL socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::ip::multicast::hops option(4);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::ip::multicast::hops option;
   socket.get_option(option);
   int ttl = option.value();








[endsect]



[section:ip__multicast__join_group ip::multicast::join_group]


Socket option to join a multicast group on a specified interface. 


  typedef implementation_defined join_group;



Implements the IPPROTO\_IP/IP\_ADD\_MEMBERSHIP socket option.


[heading Examples]
  
Setting the option to join a multicast group: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::ip::address multicast_address =
     std::experimental::net::ip::address::from_string("225.0.0.1");
   std::experimental::net::ip::multicast::join_group option(multicast_address);
   socket.set_option(option);








[endsect]



[section:ip__multicast__leave_group ip::multicast::leave_group]


Socket option to leave a multicast group on a specified interface. 


  typedef implementation_defined leave_group;



Implements the IPPROTO\_IP/IP\_DROP\_MEMBERSHIP socket option.


[heading Examples]
  
Setting the option to leave a multicast group: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::ip::address multicast_address =
     std::experimental::net::ip::address::from_string("225.0.0.1");
   std::experimental::net::ip::multicast::leave_group option(multicast_address);
   socket.set_option(option);








[endsect]



[section:ip__multicast__outbound_interface ip::multicast::outbound_interface]


Socket option for local interface to use for outgoing multicast packets. 


  typedef implementation_defined outbound_interface;



Implements the IPPROTO\_IP/IP\_MULTICAST\_IF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::ip::address_v4 local_interface =
     std::experimental::net::ip::address_v4::from_string("1.2.3.4");
   std::experimental::net::ip::multicast::outbound_interface option(local_interface);
   socket.set_option(option);








[endsect]


[section:ip__network_v4 ip::network_v4]


Represents an IPv4 network. 


  class network_v4


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__network_v4.address [*address]]]
    [Obtain the address object specified when the network object was created. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.broadcast [*broadcast]]]
    [Obtain an address object that represents the network's broadcast address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.canonical [*canonical]]]
    [Obtain the true network address, omitting any host bits. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.hosts [*hosts]]]
    [Obtain an address range corresponding to the hosts in the network. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.is_host [*is_host]]]
    [Test if network is a valid host address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.is_subnet_of [*is_subnet_of]]]
    [Test if a network is a real subnet of another network. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.netmask [*netmask]]]
    [Obtain the netmask that was specified when the network object was created. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.network [*network]]]
    [Obtain an address object that represents the network address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.network_v4 [*network_v4]]]
    [Default constructor. 

     Construct a network based on the specified address and prefix length. 

     Construct network based on the specified address and netmask. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.operator_eq_ [*operator=]]]
    [Assign from another network. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.prefix_length [*prefix_length]]]
    [Obtain the prefix length that was specified when the network object was created. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.to_string [*to_string]]]
    [Get the network as an address in dotted decimal format. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__network_v4.operator_not__eq_ [*operator!=]]]
    [Compare two networks for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v4.operator_eq__eq_ [*operator==]]]
    [Compare two networks for equality. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__network_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from a string containing IP address and prefix length. ]
  ]
  
]

The std::experimental::net::ip::network\_v4 class provides the ability to use and manipulate IP version 4 networks.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 




[section:address ip::network_v4::address]


Obtain the address object specified when the network object was created. 


  address_v4 address() const;



[endsect]



[section:broadcast ip::network_v4::broadcast]


Obtain an address object that represents the network's broadcast address. 


  address_v4 broadcast() const;



[endsect]



[section:canonical ip::network_v4::canonical]


Obtain the true network address, omitting any host bits. 


  network_v4 canonical() const;



[endsect]



[section:hosts ip::network_v4::hosts]


Obtain an address range corresponding to the hosts in the network. 


  address_v4_range hosts() const;



[endsect]



[section:is_host ip::network_v4::is_host]


Test if network is a valid host address. 


  bool is_host() const;



[endsect]



[section:is_subnet_of ip::network_v4::is_subnet_of]


Test if a network is a real subnet of another network. 


  bool is_subnet_of(
      const network_v4 & other) const;



[endsect]


[section:make_network_v4 ip::network_v4::make_network_v4]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 ``[link networking_ts.reference.ip__network_v4.make_network_v4.overload1 make_network_v4]``(
      const char * str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.make_network_v4.overload1 more...]]``

  network_v4 ``[link networking_ts.reference.ip__network_v4.make_network_v4.overload2 make_network_v4]``(
      const char * str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.make_network_v4.overload2 more...]]``

  network_v4 ``[link networking_ts.reference.ip__network_v4.make_network_v4.overload3 make_network_v4]``(
      const std::string & str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.make_network_v4.overload3 more...]]``

  network_v4 ``[link networking_ts.reference.ip__network_v4.make_network_v4.overload4 make_network_v4]``(
      const std::string & str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.make_network_v4.overload4 more...]]``

  network_v4 ``[link networking_ts.reference.ip__network_v4.make_network_v4.overload5 make_network_v4]``(
      string_view str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.make_network_v4.overload5 more...]]``

  network_v4 ``[link networking_ts.reference.ip__network_v4.make_network_v4.overload6 make_network_v4]``(
      string_view str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.make_network_v4.overload6 more...]]``


[section:overload1 ip::network_v4::make_network_v4 (1 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      const char * str);



[endsect]



[section:overload2 ip::network_v4::make_network_v4 (2 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      const char * str,
      std::error_code & ec);



[endsect]



[section:overload3 ip::network_v4::make_network_v4 (3 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      const std::string & str);



[endsect]



[section:overload4 ip::network_v4::make_network_v4 (4 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      const std::string & str,
      std::error_code & ec);



[endsect]



[section:overload5 ip::network_v4::make_network_v4 (5 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      string_view str);



[endsect]



[section:overload6 ip::network_v4::make_network_v4 (6 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      string_view str,
      std::error_code & ec);



[endsect]


[endsect]


[section:netmask ip::network_v4::netmask]


Obtain the netmask that was specified when the network object was created. 


  address_v4 netmask() const;



[endsect]



[section:network ip::network_v4::network]


Obtain an address object that represents the network address. 


  address_v4 network() const;



[endsect]


[section:network_v4 ip::network_v4::network_v4]


Default constructor. 


  ``[link networking_ts.reference.ip__network_v4.network_v4.overload1 network_v4]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.network_v4.overload1 more...]]``


Construct a network based on the specified address and prefix length. 


  ``[link networking_ts.reference.ip__network_v4.network_v4.overload2 network_v4]``(
      const address_v4 & addr,
      unsigned short prefix_len);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.network_v4.overload2 more...]]``


Construct network based on the specified address and netmask. 


  ``[link networking_ts.reference.ip__network_v4.network_v4.overload3 network_v4]``(
      const address_v4 & addr,
      const address_v4 & mask);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.network_v4.overload3 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__network_v4.network_v4.overload4 network_v4]``(
      const network_v4 & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.network_v4.overload4 more...]]``


[section:overload1 ip::network_v4::network_v4 (1 of 4 overloads)]


Default constructor. 


  network_v4();



[endsect]



[section:overload2 ip::network_v4::network_v4 (2 of 4 overloads)]


Construct a network based on the specified address and prefix length. 


  network_v4(
      const address_v4 & addr,
      unsigned short prefix_len);



[endsect]



[section:overload3 ip::network_v4::network_v4 (3 of 4 overloads)]


Construct network based on the specified address and netmask. 


  network_v4(
      const address_v4 & addr,
      const address_v4 & mask);



[endsect]



[section:overload4 ip::network_v4::network_v4 (4 of 4 overloads)]


Copy constructor. 


  network_v4(
      const network_v4 & other);



[endsect]


[endsect]


[section:operator_not__eq_ ip::network_v4::operator!=]


Compare two networks for inequality. 


  friend bool operator!=(
      const network_v4 & a,
      const network_v4 & b);



[endsect]



[section:operator_eq_ ip::network_v4::operator=]


Assign from another network. 


  network_v4 & operator=(
      const network_v4 & other);



[endsect]



[section:operator_eq__eq_ ip::network_v4::operator==]


Compare two networks for equality. 


  friend bool operator==(
      const network_v4 & a,
      const network_v4 & b);



[endsect]



[section:prefix_length ip::network_v4::prefix_length]


Obtain the prefix length that was specified when the network object was created. 


  unsigned short prefix_length() const;



[endsect]


[section:to_string ip::network_v4::to_string]


Get the network as an address in dotted decimal format. 


  std::string ``[link networking_ts.reference.ip__network_v4.to_string.overload1 to_string]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.to_string.overload1 more...]]``

  std::string ``[link networking_ts.reference.ip__network_v4.to_string.overload2 to_string]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v4.to_string.overload2 more...]]``


[section:overload1 ip::network_v4::to_string (1 of 2 overloads)]


Get the network as an address in dotted decimal format. 


  std::string to_string() const;



[endsect]



[section:overload2 ip::network_v4::to_string (2 of 2 overloads)]


Get the network as an address in dotted decimal format. 


  std::string to_string(
      std::error_code & ec) const;



[endsect]


[endsect]


[endsect]

[section:ip__network_v6 ip::network_v6]


Represents an IPv6 network. 


  class network_v6


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__network_v6.address [*address]]]
    [Obtain the address object specified when the network object was created. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.canonical [*canonical]]]
    [Obtain the true network address, omitting any host bits. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.hosts [*hosts]]]
    [Obtain an address range corresponding to the hosts in the network. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.is_host [*is_host]]]
    [Test if network is a valid host address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.is_subnet_of [*is_subnet_of]]]
    [Test if a network is a real subnet of another network. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.network [*network]]]
    [Obtain an address object that represents the network address. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.network_v6 [*network_v6]]]
    [Default constructor. 

     Construct a network based on the specified address and prefix length. 

     Copy constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.operator_eq_ [*operator=]]]
    [Assign from another network. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.prefix_length [*prefix_length]]]
    [Obtain the prefix length that was specified when the network object was created. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.to_string [*to_string]]]
    [Get the network as an address in dotted decimal format. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__network_v6.operator_not__eq_ [*operator!=]]]
    [Compare two networks for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__network_v6.operator_eq__eq_ [*operator==]]]
    [Compare two networks for equality. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__network_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from a string containing IP address and prefix length. ]
  ]
  
]

The std::experimental::net::ip::network\_v6 class provides the ability to use and manipulate IP version 6 networks.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 




[section:address ip::network_v6::address]


Obtain the address object specified when the network object was created. 


  address_v6 address() const;



[endsect]



[section:canonical ip::network_v6::canonical]


Obtain the true network address, omitting any host bits. 


  network_v6 canonical() const;



[endsect]



[section:hosts ip::network_v6::hosts]


Obtain an address range corresponding to the hosts in the network. 


  address_v6_range hosts() const;



[endsect]



[section:is_host ip::network_v6::is_host]


Test if network is a valid host address. 


  bool is_host() const;



[endsect]



[section:is_subnet_of ip::network_v6::is_subnet_of]


Test if a network is a real subnet of another network. 


  bool is_subnet_of(
      const network_v6 & other) const;



[endsect]


[section:make_network_v6 ip::network_v6::make_network_v6]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 ``[link networking_ts.reference.ip__network_v6.make_network_v6.overload1 make_network_v6]``(
      const char * str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.make_network_v6.overload1 more...]]``

  network_v6 ``[link networking_ts.reference.ip__network_v6.make_network_v6.overload2 make_network_v6]``(
      const char * str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.make_network_v6.overload2 more...]]``

  network_v6 ``[link networking_ts.reference.ip__network_v6.make_network_v6.overload3 make_network_v6]``(
      const std::string & str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.make_network_v6.overload3 more...]]``

  network_v6 ``[link networking_ts.reference.ip__network_v6.make_network_v6.overload4 make_network_v6]``(
      const std::string & str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.make_network_v6.overload4 more...]]``

  network_v6 ``[link networking_ts.reference.ip__network_v6.make_network_v6.overload5 make_network_v6]``(
      string_view str);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.make_network_v6.overload5 more...]]``

  network_v6 ``[link networking_ts.reference.ip__network_v6.make_network_v6.overload6 make_network_v6]``(
      string_view str,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.make_network_v6.overload6 more...]]``


[section:overload1 ip::network_v6::make_network_v6 (1 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      const char * str);



[endsect]



[section:overload2 ip::network_v6::make_network_v6 (2 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      const char * str,
      std::error_code & ec);



[endsect]



[section:overload3 ip::network_v6::make_network_v6 (3 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      const std::string & str);



[endsect]



[section:overload4 ip::network_v6::make_network_v6 (4 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      const std::string & str,
      std::error_code & ec);



[endsect]



[section:overload5 ip::network_v6::make_network_v6 (5 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      string_view str);



[endsect]



[section:overload6 ip::network_v6::make_network_v6 (6 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      string_view str,
      std::error_code & ec);



[endsect]


[endsect]


[section:network ip::network_v6::network]


Obtain an address object that represents the network address. 


  address_v6 network() const;



[endsect]


[section:network_v6 ip::network_v6::network_v6]


Default constructor. 


  ``[link networking_ts.reference.ip__network_v6.network_v6.overload1 network_v6]``();
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.network_v6.overload1 more...]]``


Construct a network based on the specified address and prefix length. 


  ``[link networking_ts.reference.ip__network_v6.network_v6.overload2 network_v6]``(
      const address_v6 & addr,
      unsigned short prefix_len);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.network_v6.overload2 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.ip__network_v6.network_v6.overload3 network_v6]``(
      const network_v6 & other);
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.network_v6.overload3 more...]]``


[section:overload1 ip::network_v6::network_v6 (1 of 3 overloads)]


Default constructor. 


  network_v6();



[endsect]



[section:overload2 ip::network_v6::network_v6 (2 of 3 overloads)]


Construct a network based on the specified address and prefix length. 


  network_v6(
      const address_v6 & addr,
      unsigned short prefix_len);



[endsect]



[section:overload3 ip::network_v6::network_v6 (3 of 3 overloads)]


Copy constructor. 


  network_v6(
      const network_v6 & other);



[endsect]


[endsect]


[section:operator_not__eq_ ip::network_v6::operator!=]


Compare two networks for inequality. 


  friend bool operator!=(
      const network_v6 & a,
      const network_v6 & b);



[endsect]



[section:operator_eq_ ip::network_v6::operator=]


Assign from another network. 


  network_v6 & operator=(
      const network_v6 & other);



[endsect]



[section:operator_eq__eq_ ip::network_v6::operator==]


Compare two networks for equality. 


  friend bool operator==(
      const network_v6 & a,
      const network_v6 & b);



[endsect]



[section:prefix_length ip::network_v6::prefix_length]


Obtain the prefix length that was specified when the network object was created. 


  unsigned short prefix_length() const;



[endsect]


[section:to_string ip::network_v6::to_string]


Get the network as an address in dotted decimal format. 


  std::string ``[link networking_ts.reference.ip__network_v6.to_string.overload1 to_string]``() const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.to_string.overload1 more...]]``

  std::string ``[link networking_ts.reference.ip__network_v6.to_string.overload2 to_string]``(
      std::error_code & ec) const;
  ``  [''''&raquo;''' [link networking_ts.reference.ip__network_v6.to_string.overload2 more...]]``


[section:overload1 ip::network_v6::to_string (1 of 2 overloads)]


Get the network as an address in dotted decimal format. 


  std::string to_string() const;



[endsect]



[section:overload2 ip::network_v6::to_string (2 of 2 overloads)]


Get the network as an address in dotted decimal format. 


  std::string to_string(
      std::error_code & ec) const;



[endsect]


[endsect]


[endsect]

[section:ip__resolver_base ip::resolver_base]


The [link networking_ts.reference.ip__resolver_base `ip::resolver_base`] class is used as a base for the [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`] class templates to provide a common place to define the flag constants. 


  class resolver_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__resolver_base.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__resolver_base._resolver_base [*~resolver_base]]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__resolver_base.address_configured [*address_configured]]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_base.all_matching [*all_matching]]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_base.canonical_name [*canonical_name]]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_base.numeric_host [*numeric_host]]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_base.numeric_service [*numeric_service]]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_base.passive [*passive]]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_base.v4_mapped [*v4_mapped]]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]


[section:address_configured ip::resolver_base::address_configured]


Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. 


  static const flags address_configured = implementation_defined;



[endsect]



[section:all_matching ip::resolver_base::all_matching]


If used with v4\_mapped, return all matching IPv6 and IPv4 addresses. 


  static const flags all_matching = implementation_defined;



[endsect]



[section:canonical_name ip::resolver_base::canonical_name]


Determine the canonical name of the host specified in the query. 


  static const flags canonical_name = implementation_defined;



[endsect]



[section:flags ip::resolver_base::flags]


A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;




[endsect]



[section:numeric_host ip::resolver_base::numeric_host]


Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. 


  static const flags numeric_host = implementation_defined;



[endsect]



[section:numeric_service ip::resolver_base::numeric_service]


Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. 


  static const flags numeric_service = implementation_defined;



[endsect]



[section:passive ip::resolver_base::passive]


Indicate that returned endpoint is intended for use as a locally bound socket endpoint. 


  static const flags passive = implementation_defined;



[endsect]



[section:v4_mapped ip::resolver_base::v4_mapped]


If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. 


  static const flags v4_mapped = implementation_defined;



[endsect]



[section:_resolver_base ip::resolver_base::~resolver_base]


Protected destructor to prevent deletion through this type. 


  ~resolver_base();



[endsect]



[endsect]

[section:ip__resolver_query_base ip::resolver_query_base]


The [link networking_ts.reference.ip__resolver_query_base `ip::resolver_query_base`] class is used as a base for the [link networking_ts.reference.ip__basic_resolver_query `ip::basic_resolver_query`] class templates to provide a common place to define the flag constants. 


  class resolver_query_base :
    public ip::resolver_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__resolver_query_base.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__resolver_query_base._resolver_query_base [*~resolver_query_base]]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__resolver_query_base.address_configured [*address_configured]]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_query_base.all_matching [*all_matching]]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_query_base.canonical_name [*canonical_name]]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_query_base.numeric_host [*numeric_host]]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_query_base.numeric_service [*numeric_service]]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_query_base.passive [*passive]]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link networking_ts.reference.ip__resolver_query_base.v4_mapped [*v4_mapped]]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]


[section:address_configured ip::resolver_query_base::address_configured]


['Inherited from ip::resolver_base.]


Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. 


  static const flags address_configured = implementation_defined;



[endsect]



[section:all_matching ip::resolver_query_base::all_matching]


['Inherited from ip::resolver_base.]


If used with v4\_mapped, return all matching IPv6 and IPv4 addresses. 


  static const flags all_matching = implementation_defined;



[endsect]



[section:canonical_name ip::resolver_query_base::canonical_name]


['Inherited from ip::resolver_base.]


Determine the canonical name of the host specified in the query. 


  static const flags canonical_name = implementation_defined;



[endsect]



[section:flags ip::resolver_query_base::flags]


['Inherited from ip::resolver_base.]


A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;




[endsect]



[section:numeric_host ip::resolver_query_base::numeric_host]


['Inherited from ip::resolver_base.]


Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. 


  static const flags numeric_host = implementation_defined;



[endsect]



[section:numeric_service ip::resolver_query_base::numeric_service]


['Inherited from ip::resolver_base.]


Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. 


  static const flags numeric_service = implementation_defined;



[endsect]



[section:passive ip::resolver_query_base::passive]


['Inherited from ip::resolver_base.]


Indicate that returned endpoint is intended for use as a locally bound socket endpoint. 


  static const flags passive = implementation_defined;



[endsect]



[section:v4_mapped ip::resolver_query_base::v4_mapped]


['Inherited from ip::resolver_base.]


If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. 


  static const flags v4_mapped = implementation_defined;



[endsect]



[section:_resolver_query_base ip::resolver_query_base::~resolver_query_base]


Protected destructor to prevent deletion through this type. 


  ~resolver_query_base();



[endsect]



[endsect]

[section:ip__tcp ip::tcp]


Encapsulates the flags needed for TCP. 


  class tcp


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__tcp.acceptor [*acceptor]]]
    [The TCP acceptor type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__tcp.endpoint [*endpoint]]]
    [The type of a TCP endpoint. ]
  
  ]

  [

    [[link networking_ts.reference.ip__tcp.iostream [*iostream]]]
    [The TCP iostream type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__tcp.no_delay [*no_delay]]]
    [Socket option for disabling the Nagle algorithm. ]
  
  ]

  [

    [[link networking_ts.reference.ip__tcp.resolver [*resolver]]]
    [The TCP resolver type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__tcp.socket [*socket]]]
    [The TCP socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__tcp.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link networking_ts.reference.ip__tcp.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link networking_ts.reference.ip__tcp.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
  [
    [[link networking_ts.reference.ip__tcp.v4 [*v4]]]
    [Construct to represent the IPv4 TCP protocol. ]
  ]
  
  [
    [[link networking_ts.reference.ip__tcp.v6 [*v6]]]
    [Construct to represent the IPv6 TCP protocol. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__tcp.operator_not__eq_ [*operator!=]]]
    [Compare two protocols for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__tcp.operator_eq__eq_ [*operator==]]]
    [Compare two protocols for equality. ]
  ]
  
]

The std::experimental::net::ip::tcp class contains flags necessary for TCP sockets.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Safe.





[section:acceptor ip::tcp::acceptor]


The TCP acceptor type. 


  typedef basic_socket_acceptor< tcp > acceptor;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_socket_acceptor.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.native_handle_type [*native_handle_type]]]
    [The native representation of an acceptor. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_acceptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket_acceptor.accept [*accept]]]
    [Accept a new connection. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.assign [*assign]]]
    [Assigns an existing native acceptor to the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.async_accept [*async_accept]]]
    [Start an asynchronous accept. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.async_wait [*async_wait]]]
    [Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.basic_socket_acceptor [*basic_socket_acceptor]]]
    [Construct an acceptor without opening it. 

     Construct an open acceptor. 

     Construct an acceptor opened on the given endpoint. 

     Construct a basic_socket_acceptor on an existing native acceptor. 

     Move-construct a basic_socket_acceptor from another. 

     Move-construct a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.bind [*bind]]]
    [Bind the acceptor to the given local endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.get_option [*get_option]]]
    [Get an option from the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.io_control [*io_control]]]
    [Perform an IO control command on the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.is_open [*is_open]]]
    [Determine whether the acceptor is open. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.listen [*listen]]]
    [Place the acceptor into the state where it will listen for new connections. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.native_handle [*native_handle]]]
    [Get the native acceptor representation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native acceptor implementation. 

     Sets the non-blocking mode of the native acceptor implementation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the acceptor. 

     Sets the non-blocking mode of the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.open [*open]]]
    [Open the acceptor using the specified protocol. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_acceptor from another. 

     Move-assign a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.release [*release]]]
    [Release ownership of the underlying native acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.set_option [*set_option]]]
    [Set an option on the acceptor. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor.wait [*wait]]]
    [Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_acceptor._basic_socket_acceptor [*~basic_socket_acceptor]]]
    [Destroys the acceptor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket_acceptor.max_listen_connections [*max_listen_connections]]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link networking_ts.reference.basic_socket_acceptor.message_do_not_route [*message_do_not_route]]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link networking_ts.reference.basic_socket_acceptor.message_end_of_record [*message_end_of_record]]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link networking_ts.reference.basic_socket_acceptor.message_out_of_band [*message_out_of_band]]]
    [Process out-of-band data. ]
  ]

  [
    [[link networking_ts.reference.basic_socket_acceptor.message_peek [*message_peek]]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link networking_ts.reference.basic_socket_acceptor `basic_socket_acceptor`] class template is used for accepting new socket connections.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.


[heading Example]
  
Opening a socket acceptor with the SO\_REUSEADDR option enabled: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context);
   std::experimental::net::ip::tcp::endpoint endpoint(std::experimental::net::ip::tcp::v4(), port);
   acceptor.open(endpoint.protocol());
   acceptor.set_option(std::experimental::net::ip::tcp::acceptor::reuse_address(true));
   acceptor.bind(endpoint);
   acceptor.listen();








[endsect]



[section:endpoint ip::tcp::endpoint]


The type of a TCP endpoint. 


  typedef basic_endpoint< tcp > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_endpoint.address [*address]]]
    [Get the IP address associated with the endpoint. 

     Set the IP address associated with the endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.basic_endpoint [*basic_endpoint]]]
    [Default constructor. 

     Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR_ANY or in6addr_any). This constructor would typically be used for accepting new connections. 

     Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 

     Copy constructor. 

     Move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. 

     Move-assign from another endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.port [*port]]]
    [Get the port associated with the endpoint. The port number is always in the host's byte order. 

     Set the port associated with the endpoint. The port number is always in the host's byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

The std::experimental::net::ip::basic\_endpoint class template describes an endpoint that may be associated with a particular socket.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.






[endsect]



[section:family ip::tcp::family]


Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:iostream ip::tcp::iostream]


The TCP iostream type. 


  typedef basic_socket_iostream< tcp > iostream;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_socket_iostream.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.duration [*duration]]]
    [The duration type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.duration_type [*duration_type]]]
    [(Deprecated: Use duration.) The duration type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.time_point [*time_point]]]
    [The time type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_socket_iostream.time_type [*time_type]]]
    [(Deprecated: Use time_point.) The time type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_socket_iostream.basic_socket_iostream [*basic_socket_iostream]]]
    [Construct a basic_socket_iostream without establishing a connection. 

     Construct a basic_socket_iostream from the supplied socket. 

     Move-construct a basic_socket_iostream from another. 

     Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.close [*close]]]
    [Close the connection. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.connect [*connect]]]
    [Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.error [*error]]]
    [Get the last error associated with the stream. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.expires_after [*expires_after]]]
    [Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.expires_at [*expires_at]]]
    [Set the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.expiry [*expiry]]]
    [Get the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_iostream from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.rdbuf [*rdbuf]]]
    [Return a pointer to the underlying streambuf. ]
  ]
  
  [
    [[link networking_ts.reference.basic_socket_iostream.socket [*socket]]]
    [Get a reference to the underlying socket. ]
  ]
  
]



[endsect]



[section:no_delay ip::tcp::no_delay]


Socket option for disabling the Nagle algorithm. 


  typedef implementation_defined no_delay;



Implements the IPPROTO\_TCP/TCP\_NODELAY socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::ip::tcp::no_delay option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::ip::tcp::no_delay option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:operator_not__eq_ ip::tcp::operator!=]


Compare two protocols for inequality. 


  friend bool operator!=(
      const tcp & p1,
      const tcp & p2);



[endsect]



[section:operator_eq__eq_ ip::tcp::operator==]


Compare two protocols for equality. 


  friend bool operator==(
      const tcp & p1,
      const tcp & p2);



[endsect]



[section:protocol ip::tcp::protocol]


Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]



[section:resolver ip::tcp::resolver]


The TCP resolver type. 


  typedef basic_resolver< tcp > resolver;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.results_type [*results_type]]]
    [The results type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver.async_resolve [*async_resolve]]]
    [Asynchronously perform forward resolution of a query to a list of entries. 

     Asynchronously perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.basic_resolver [*basic_resolver]]]
    [Constructor. 

     Move-construct a basic_resolver from another. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the resolver. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.operator_eq_ [*operator=]]]
    [Move-assign a basic_resolver from another. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.resolve [*resolve]]]
    [Perform forward resolution of a query to a list of entries. 

     Perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver._basic_resolver [*~basic_resolver]]]
    [Destroys the resolver. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver.address_configured [*address_configured]]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.all_matching [*all_matching]]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.canonical_name [*canonical_name]]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.numeric_host [*numeric_host]]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.numeric_service [*numeric_service]]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.passive [*passive]]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.v4_mapped [*v4_mapped]]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`] class template provides the ability to resolve a query to a list of endpoints.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:socket ip::tcp::socket]


The TCP socket type. 


  typedef basic_stream_socket< tcp > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_stream_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link networking_ts.reference.basic_stream_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_stream_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.basic_stream_socket [*basic_stream_socket]]]
    [Construct a basic_stream_socket without opening it. 

     Construct and open a basic_stream_socket. 

     Construct a basic_stream_socket, opening it and binding it to the given local endpoint. 

     Construct a basic_stream_socket on an existing native socket. 

     Move-construct a basic_stream_socket from another. 

     Move-construct a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 

     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 

     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_socket from another. 

     Move-assign a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.read_some [*read_some]]]
    [Read some data from the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.receive [*receive]]]
    [Receive some data on the socket. 

     Receive some data on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket.write_some [*write_some]]]
    [Write some data to the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_stream_socket._basic_stream_socket [*~basic_stream_socket]]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_stream_socket.max_listen_connections [*max_listen_connections]]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link networking_ts.reference.basic_stream_socket.message_do_not_route [*message_do_not_route]]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link networking_ts.reference.basic_stream_socket.message_end_of_record [*message_end_of_record]]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link networking_ts.reference.basic_stream_socket.message_out_of_band [*message_out_of_band]]]
    [Process out-of-band data. ]
  ]

  [
    [[link networking_ts.reference.basic_stream_socket.message_peek [*message_peek]]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] class template provides asynchronous and blocking stream-oriented socket functionality.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.






[endsect]



[section:type ip::tcp::type]


Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[section:v4 ip::tcp::v4]


Construct to represent the IPv4 TCP protocol. 


  static tcp v4();



[endsect]



[section:v6 ip::tcp::v6]


Construct to represent the IPv6 TCP protocol. 


  static tcp v6();



[endsect]



[endsect]

[section:ip__udp ip::udp]


Encapsulates the flags needed for UDP. 


  class udp


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__udp.endpoint [*endpoint]]]
    [The type of a UDP endpoint. ]
  
  ]

  [

    [[link networking_ts.reference.ip__udp.resolver [*resolver]]]
    [The UDP resolver type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__udp.socket [*socket]]]
    [The UDP socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__udp.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link networking_ts.reference.ip__udp.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link networking_ts.reference.ip__udp.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
  [
    [[link networking_ts.reference.ip__udp.v4 [*v4]]]
    [Construct to represent the IPv4 UDP protocol. ]
  ]
  
  [
    [[link networking_ts.reference.ip__udp.v6 [*v6]]]
    [Construct to represent the IPv6 UDP protocol. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__udp.operator_not__eq_ [*operator!=]]]
    [Compare two protocols for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__udp.operator_eq__eq_ [*operator==]]]
    [Compare two protocols for equality. ]
  ]
  
]

The std::experimental::net::ip::udp class contains flags necessary for UDP sockets.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Safe.





[section:endpoint ip::udp::endpoint]


The type of a UDP endpoint. 


  typedef basic_endpoint< udp > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_endpoint.address [*address]]]
    [Get the IP address associated with the endpoint. 

     Set the IP address associated with the endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.basic_endpoint [*basic_endpoint]]]
    [Default constructor. 

     Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR_ANY or in6addr_any). This constructor would typically be used for accepting new connections. 

     Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 

     Copy constructor. 

     Move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. 

     Move-assign from another endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.port [*port]]]
    [Get the port associated with the endpoint. The port number is always in the host's byte order. 

     Set the port associated with the endpoint. The port number is always in the host's byte order. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

The std::experimental::net::ip::basic\_endpoint class template describes an endpoint that may be associated with a particular socket.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.






[endsect]



[section:family ip::udp::family]


Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:operator_not__eq_ ip::udp::operator!=]


Compare two protocols for inequality. 


  friend bool operator!=(
      const udp & p1,
      const udp & p2);



[endsect]



[section:operator_eq__eq_ ip::udp::operator==]


Compare two protocols for equality. 


  friend bool operator==(
      const udp & p1,
      const udp & p2);



[endsect]



[section:protocol ip::udp::protocol]


Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]



[section:resolver ip::udp::resolver]


The UDP resolver type. 


  typedef basic_resolver< udp > resolver;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.ip__basic_resolver.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.ip__basic_resolver.results_type [*results_type]]]
    [The results type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver.async_resolve [*async_resolve]]]
    [Asynchronously perform forward resolution of a query to a list of entries. 

     Asynchronously perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.basic_resolver [*basic_resolver]]]
    [Constructor. 

     Move-construct a basic_resolver from another. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the resolver. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.operator_eq_ [*operator=]]]
    [Move-assign a basic_resolver from another. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver.resolve [*resolve]]]
    [Perform forward resolution of a query to a list of entries. 

     Perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link networking_ts.reference.ip__basic_resolver._basic_resolver [*~basic_resolver]]]
    [Destroys the resolver. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.ip__basic_resolver.address_configured [*address_configured]]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.all_matching [*all_matching]]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.canonical_name [*canonical_name]]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.numeric_host [*numeric_host]]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.numeric_service [*numeric_service]]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.passive [*passive]]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link networking_ts.reference.ip__basic_resolver.v4_mapped [*v4_mapped]]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link networking_ts.reference.ip__basic_resolver `ip::basic_resolver`] class template provides the ability to resolve a query to a list of endpoints.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:socket ip::udp::socket]


The UDP socket type. 


  typedef basic_datagram_socket< udp > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_datagram_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link networking_ts.reference.basic_datagram_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_datagram_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.basic_datagram_socket [*basic_datagram_socket]]]
    [Construct a basic_datagram_socket without opening it. 

     Construct and open a basic_datagram_socket. 

     Construct a basic_datagram_socket, opening it and binding it to the given local endpoint. 

     Construct a basic_datagram_socket on an existing native socket. 

     Move-construct a basic_datagram_socket from another. 

     Move-construct a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 

     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 

     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_datagram_socket from another. 

     Move-assign a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.receive_from [*receive_from]]]
    [Receive a datagram with the endpoint of the sender. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.send_to [*send_to]]]
    [Send a datagram to the specified endpoint. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link networking_ts.reference.basic_datagram_socket._basic_datagram_socket [*~basic_datagram_socket]]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_datagram_socket.max_listen_connections [*max_listen_connections]]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link networking_ts.reference.basic_datagram_socket.message_do_not_route [*message_do_not_route]]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link networking_ts.reference.basic_datagram_socket.message_end_of_record [*message_end_of_record]]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link networking_ts.reference.basic_datagram_socket.message_out_of_band [*message_out_of_band]]]
    [Process out-of-band data. ]
  ]

  [
    [[link networking_ts.reference.basic_datagram_socket.message_peek [*message_peek]]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] class template provides asynchronous and blocking datagram-oriented socket functionality.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe. 





[endsect]



[section:type ip::udp::type]


Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[section:v4 ip::udp::v4]


Construct to represent the IPv4 UDP protocol. 


  static udp v4();



[endsect]



[section:v6 ip::udp::v6]


Construct to represent the IPv6 UDP protocol. 


  static udp v6();



[endsect]



[endsect]


[section:ip__unicast__hops ip::unicast::hops]


Socket option for time-to-live associated with outgoing unicast packets. 


  typedef implementation_defined hops;



Implements the IPPROTO\_IP/IP\_UNICAST\_TTL socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::ip::unicast::hops option(4);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::ip::unicast::hops option;
   socket.get_option(option);
   int ttl = option.value();








[endsect]



[section:ip__v4_mapped_t ip::v4_mapped_t]


Tag type used for distinguishing overloads that deal in IPv4-mapped IPv6 addresses. 


  enum v4_mapped_t


[heading Values]
[variablelist

  [
    [v4_mapped]
    []
  ]

]



[endsect]



[section:ip__v6_only ip::v6_only]


Socket option for determining whether an IPv6 socket supports IPv6 communication only. 


  typedef implementation_defined v6_only;



Implements the IPPROTO\_IPV6/IP\_V6ONLY socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::ip::v6_only option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::ip::v6_only option;
   socket.get_option(option);
   bool v6_only = option.value();








[endsect]


[section:is_const_buffer_sequence is_const_buffer_sequence]


Trait to determine whether a type satisfies the ConstBufferSequence requirements. 


  template<
      typename T>
  struct is_const_buffer_sequence



[endsect]

[section:is_dynamic_buffer is_dynamic_buffer]


Trait to determine whether a type satisfies the DynamicBuffer requirements. 


  template<
      typename T>
  struct is_dynamic_buffer



[endsect]

[section:is_endpoint_sequence is_endpoint_sequence]


Type trait used to determine whether a type is an endpoint sequence that can be used with with `connect` and `async_connect`. 


  template<
      typename T>
  struct is_endpoint_sequence


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.is_endpoint_sequence.value [*value]]]
    [The value member is true if the type may be used as an endpoint sequence. ]
  ]

]


[section:value is_endpoint_sequence::value]


The value member is true if the type may be used as an endpoint sequence. 


  static const bool value;



[endsect]



[endsect]

[section:is_executor is_executor]


The [link networking_ts.reference.is_executor `is_executor`] trait detects whether a type T meets the Executor type requirements. 


  template<
      typename T>
  struct is_executor


Class template `is_executor` is a UnaryTypeTrait that is derived from `true_type` if the type `T` meets the syntactic requirements for Executor, otherwise `false_type`. 


[endsect]

[section:is_match_condition is_match_condition]


Type trait used to determine whether a type can be used as a match condition function with read\_until and async\_read\_until. 


  template<
      typename T>
  struct is_match_condition


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.is_match_condition.value [*value]]]
    [The value member is true if the type may be used as a match condition. ]
  ]

]


[section:value is_match_condition::value]


The value member is true if the type may be used as a match condition. 


  static const bool value;



[endsect]



[endsect]

[section:is_mutable_buffer_sequence is_mutable_buffer_sequence]


Trait to determine whether a type satisfies the MutableBufferSequence requirements. 


  template<
      typename T>
  struct is_mutable_buffer_sequence



[endsect]

[section:make_work_guard make_work_guard]


Create an [link networking_ts.reference.executor_work_guard `executor_work_guard`]  object. 

    
  template<
      typename Executor>
  executor_work_guard< Executor > ``[link networking_ts.reference.make_work_guard.overload1 make_work_guard]``(
      const Executor & ex,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.make_work_guard.overload1 more...]]``

  template<
      typename ExecutionContext>
  executor_work_guard< typename ExecutionContext::executor_type > ``[link networking_ts.reference.make_work_guard.overload2 make_work_guard]``(
      ExecutionContext & ctx,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.make_work_guard.overload2 more...]]``

  template<
      typename T>
  executor_work_guard< typename associated_executor< T >::type > ``[link networking_ts.reference.make_work_guard.overload3 make_work_guard]``(
      const T & t,
      typename enable_if<!is_executor< T >::value &&!is_convertible< T &, execution_context & >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.make_work_guard.overload3 more...]]``

  template<
      typename T,
      typename Executor>
  executor_work_guard< typename associated_executor< T, Executor >::type > ``[link networking_ts.reference.make_work_guard.overload4 make_work_guard]``(
      const T & t,
      const Executor & ex,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.make_work_guard.overload4 more...]]``

  template<
      typename T,
      typename ExecutionContext>
  executor_work_guard< typename associated_executor< T, typename ExecutionContext::executor_type >::type > ``[link networking_ts.reference.make_work_guard.overload5 make_work_guard]``(
      const T & t,
      ExecutionContext & ctx,
      typename enable_if<!is_executor< T >::value &&!is_convertible< T &, execution_context & >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.make_work_guard.overload5 more...]]``


[section:overload1 make_work_guard (1 of 5 overloads)]


Create an [link networking_ts.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename Executor>
  executor_work_guard< Executor > make_work_guard(
      const Executor & ex,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);



[endsect]



[section:overload2 make_work_guard (2 of 5 overloads)]


Create an [link networking_ts.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename ExecutionContext>
  executor_work_guard< typename ExecutionContext::executor_type > make_work_guard(
      ExecutionContext & ctx,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);



[endsect]



[section:overload3 make_work_guard (3 of 5 overloads)]


Create an [link networking_ts.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename T>
  executor_work_guard< typename associated_executor< T >::type > make_work_guard(
      const T & t,
      typename enable_if<!is_executor< T >::value &&!is_convertible< T &, execution_context & >::value >::type *  = 0);



[endsect]



[section:overload4 make_work_guard (4 of 5 overloads)]


Create an [link networking_ts.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename T,
      typename Executor>
  executor_work_guard< typename associated_executor< T, Executor >::type > make_work_guard(
      const T & t,
      const Executor & ex,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);



[endsect]



[section:overload5 make_work_guard (5 of 5 overloads)]


Create an [link networking_ts.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename T,
      typename ExecutionContext>
  executor_work_guard< typename associated_executor< T, typename ExecutionContext::executor_type >::type > make_work_guard(
      const T & t,
      ExecutionContext & ctx,
      typename enable_if<!is_executor< T >::value &&!is_convertible< T &, execution_context & >::value >::type *  = 0);



[endsect]


[endsect]

[section:mutable_buffer mutable_buffer]


Holds a buffer that can be modified. 


  class mutable_buffer


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.mutable_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.mutable_buffer [*mutable_buffer]]]
    [Construct an empty buffer. 

     Construct a buffer to represent a given memory range. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.mutable_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link networking_ts.reference.mutable_buffer `mutable_buffer`] class provides a safe representation of a buffer that can be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   std::experimental::net::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 


[section:data mutable_buffer::data]


Get a pointer to the beginning of the memory range. 


  void * data() const;



[endsect]


[section:mutable_buffer mutable_buffer::mutable_buffer]


Construct an empty buffer. 


  ``[link networking_ts.reference.mutable_buffer.mutable_buffer.overload1 mutable_buffer]``();
  ``  [''''&raquo;''' [link networking_ts.reference.mutable_buffer.mutable_buffer.overload1 more...]]``


Construct a buffer to represent a given memory range. 


  ``[link networking_ts.reference.mutable_buffer.mutable_buffer.overload2 mutable_buffer]``(
      void * data,
      std::size_t size);
  ``  [''''&raquo;''' [link networking_ts.reference.mutable_buffer.mutable_buffer.overload2 more...]]``


[section:overload1 mutable_buffer::mutable_buffer (1 of 2 overloads)]


Construct an empty buffer. 


  mutable_buffer();



[endsect]



[section:overload2 mutable_buffer::mutable_buffer (2 of 2 overloads)]


Construct a buffer to represent a given memory range. 


  mutable_buffer(
      void * data,
      std::size_t size);



[endsect]


[endsect]

[section:operator_plus_ mutable_buffer::operator+]


Create a new modifiable buffer that is offset from the start of another. 


  mutable_buffer ``[link networking_ts.reference.mutable_buffer.operator_plus_.overload1 operator+]``(
      const mutable_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link networking_ts.reference.mutable_buffer.operator_plus_.overload1 more...]]``

  mutable_buffer ``[link networking_ts.reference.mutable_buffer.operator_plus_.overload2 operator+]``(
      std::size_t n,
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link networking_ts.reference.mutable_buffer.operator_plus_.overload2 more...]]``


[section:overload1 mutable_buffer::operator+ (1 of 2 overloads)]


Create a new modifiable buffer that is offset from the start of another. 


  mutable_buffer operator+(
      const mutable_buffer & b,
      std::size_t n);



[endsect]



[section:overload2 mutable_buffer::operator+ (2 of 2 overloads)]


Create a new modifiable buffer that is offset from the start of another. 


  mutable_buffer operator+(
      std::size_t n,
      const mutable_buffer & b);



[endsect]


[endsect]


[section:operator_plus__eq_ mutable_buffer::operator+=]


Move the start of the buffer by the specified number of bytes. 


  mutable_buffer & operator+=(
      std::size_t n);



[endsect]



[section:size mutable_buffer::size]


Get the size of the memory range. 


  std::size_t size() const;



[endsect]



[endsect]

[section:null_buffers null_buffers]


(Deprecated: Use the socket/descriptor wait() and async\_wait() member functions.) An implementation of both the ConstBufferSequence and MutableBufferSequence concepts to represent a null buffer sequence. 


  class null_buffers


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.null_buffers.const_iterator [*const_iterator]]]
    [A random-access iterator type that may be used to read elements. ]
  
  ]

  [

    [[link networking_ts.reference.null_buffers.value_type [*value_type]]]
    [The type for each element in the list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.null_buffers.begin [*begin]]]
    [Get a random-access iterator to the first element. ]
  ]
  
  [
    [[link networking_ts.reference.null_buffers.end [*end]]]
    [Get a random-access iterator for one past the last element. ]
  ]
  
]


[section:begin null_buffers::begin]


Get a random-access iterator to the first element. 


  const_iterator begin() const;



[endsect]



[section:const_iterator null_buffers::const_iterator]


A random-access iterator type that may be used to read elements. 


  typedef const mutable_buffer * const_iterator;




[endsect]



[section:end null_buffers::end]


Get a random-access iterator for one past the last element. 


  const_iterator end() const;



[endsect]



[section:value_type null_buffers::value_type]


The type for each element in the list of buffers. 


  typedef mutable_buffer value_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.mutable_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.mutable_buffer [*mutable_buffer]]]
    [Construct an empty buffer. 

     Construct a buffer to represent a given memory range. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link networking_ts.reference.mutable_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.mutable_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link networking_ts.reference.mutable_buffer `mutable_buffer`] class provides a safe representation of a buffer that can be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   std::experimental::net::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 



[endsect]



[endsect]

[section:post post]


Submits a completion token or function object for execution. 

    
  template<
      typename CompletionToken>
  DEDUCED ``[link networking_ts.reference.post.overload1 post]``(
      CompletionToken && token);
  ``  [''''&raquo;''' [link networking_ts.reference.post.overload1 more...]]``

  template<
      typename Executor,
      typename CompletionToken>
  DEDUCED ``[link networking_ts.reference.post.overload2 post]``(
      const Executor & ex,
      CompletionToken && token,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.post.overload2 more...]]``

  template<
      typename ExecutionContext,
      typename CompletionToken>
  DEDUCED ``[link networking_ts.reference.post.overload3 post]``(
      ExecutionContext & ctx,
      CompletionToken && token,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.post.overload3 more...]]``


[section:overload1 post (1 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename CompletionToken>
  DEDUCED post(
      CompletionToken && token);


This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from `post()`.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex` by performing `get_associated_executor(handler)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Performs `ex.post(std::move(handler), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload2 post (2 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename Executor,
      typename CompletionToken>
  DEDUCED post(
      const Executor & ex,
      CompletionToken && token,
      typename enable_if< is_executor< Executor >::value >::type *  = 0);


This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from `post()`.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex1` by performing `get_associated_executor(handler)`.


* Creates a work object `w` by performing `make_work(ex1)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Constructs a function object `f` with a function call operator that performs `ex1.dispatch(std::move(handler), alloc)` followed by `w.reset()`.


* Performs `Executor(ex).post(std::move(f), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload3 post (3 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename ExecutionContext,
      typename CompletionToken>
  DEDUCED post(
      ExecutionContext & ctx,
      CompletionToken && token,
      typename enable_if< is_convertible< ExecutionContext &, execution_context & >::value >::type *  = 0);



[heading Return Value]
      
`post(ctx.get_executor(), forward<CompletionToken>(token))`. 




[endsect]


[endsect]

[section:read read]


Attempt to read a certain amount of data from a stream before returning. 

      
  template<
      typename SyncReadStream,
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.read.overload1 read]``(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.read.overload1 more...]]``

  template<
      typename SyncReadStream,
      typename MutableBufferSequence>
  std::size_t ``[link networking_ts.reference.read.overload2 read]``(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      std::error_code & ec,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.read.overload2 more...]]``

  template<
      typename SyncReadStream,
      typename MutableBufferSequence,
      typename CompletionCondition>
  std::size_t ``[link networking_ts.reference.read.overload3 read]``(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.read.overload3 more...]]``

  template<
      typename SyncReadStream,
      typename MutableBufferSequence,
      typename CompletionCondition>
  std::size_t ``[link networking_ts.reference.read.overload4 read]``(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      std::error_code & ec,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.read.overload4 more...]]``

  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t ``[link networking_ts.reference.read.overload5 read]``(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.read.overload5 more...]]``

  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t ``[link networking_ts.reference.read.overload6 read]``(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      std::error_code & ec,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.read.overload6 more...]]``

  template<
      typename SyncReadStream,
      typename DynamicBuffer,
      typename CompletionCondition>
  std::size_t ``[link networking_ts.reference.read.overload7 read]``(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.read.overload7 more...]]``

  template<
      typename SyncReadStream,
      typename DynamicBuffer,
      typename CompletionCondition>
  std::size_t ``[link networking_ts.reference.read.overload8 read]``(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      std::error_code & ec,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.read.overload8 more...]]``


[section:overload1 read (1 of 8 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename SyncReadStream,
      typename MutableBufferSequence>
  std::size_t read(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  
To read into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::read(s, std::experimental::net::buffer(data, size)); 


See the `std::experimental::net::buffer`  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::read(
       s, buffers,
       std::experimental::net::transfer_all()); 







[endsect]



[section:overload2 read (2 of 8 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename SyncReadStream,
      typename MutableBufferSequence>
  std::size_t read(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      std::error_code & ec,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Example]
  
To read into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::read(s, std::experimental::net::buffer(data, size), ec); 


See the `std::experimental::net::buffer`  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::read(
       s, buffers,
       std::experimental::net::transfer_all(), ec); 







[endsect]



[section:overload3 read (3 of 8 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename SyncReadStream,
      typename MutableBufferSequence,
      typename CompletionCondition>
  std::size_t read(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  
To read into a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::read(s, std::experimental::net::buffer(data, size),
       std::experimental::net::transfer_at_least(32)); 


See the `std::experimental::net::buffer`  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload4 read (4 of 8 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename SyncReadStream,
      typename MutableBufferSequence,
      typename CompletionCondition>
  std::size_t read(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      std::error_code & ec,
      typename enable_if< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type *  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload5 read (5 of 8 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::read(
       s, buffers,
       std::experimental::net::transfer_all()); 







[endsect]



[section:overload6 read (6 of 8 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      std::error_code & ec,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::read(
       s, buffers,
       std::experimental::net::transfer_all(), ec); 







[endsect]



[section:overload7 read (7 of 8 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename SyncReadStream,
      typename DynamicBuffer,
      typename CompletionCondition>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 read (8 of 8 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename SyncReadStream,
      typename DynamicBuffer,
      typename CompletionCondition>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      std::error_code & ec,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]


[endsect]

[section:read_until read_until]


Read data into a dynamic buffer sequence, or into a streambuf, until it contains a delimiter, matches a regular expression, or a function object indicates a match. 

      
  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t ``[link networking_ts.reference.read_until.overload1 read_until]``(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      char delim);
  ``  [''''&raquo;''' [link networking_ts.reference.read_until.overload1 more...]]``

  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t ``[link networking_ts.reference.read_until.overload2 read_until]``(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      char delim,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.read_until.overload2 more...]]``

  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t ``[link networking_ts.reference.read_until.overload3 read_until]``(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      string_view delim);
  ``  [''''&raquo;''' [link networking_ts.reference.read_until.overload3 more...]]``

  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t ``[link networking_ts.reference.read_until.overload4 read_until]``(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      string_view delim,
      std::error_code & ec);
  ``  [''''&raquo;''' [link networking_ts.reference.read_until.overload4 more...]]``


[section:overload1 read_until (1 of 4 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      char delim);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter character.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a `std::string` until a newline is encountered: 

   std::string data;
   std::string n = std::experimental::net::read_until(s,
       std::experimental::net::dynamic_buffer(data), '\n');
   std::string line = data.substr(0, n);
   data.erase(0, n); 


After the `read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload2 read_until (2 of 4 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      char delim,
      std::error_code & ec);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter character.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine. 




[endsect]



[section:overload3 read_until (3 of 4 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      string_view delim);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter string.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   std::string n = std::experimental::net::read_until(s,
       std::experimental::net::dynamic_buffer(data), "\r\n");
   std::string line = data.substr(0, n);
   data.erase(0, n); 


After the `read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload4 read_until (4 of 4 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename SyncReadStream,
      typename DynamicBuffer>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer && buffers,
      string_view delim,
      std::error_code & ec);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter string.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine. 




[endsect]


[endsect]


[section:resolver_errc__try_again resolver_errc::try_again]



  const error::netdb_errors try_again = error::host_not_found_try_again;



[endsect]


[section:service_already_exists service_already_exists]


Exception thrown when trying to add a duplicate service to an [link networking_ts.reference.execution_context `execution_context`]. 


  class service_already_exists


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.service_already_exists.service_already_exists [*service_already_exists]]]
    []
  ]
  
]


[section:service_already_exists service_already_exists::service_already_exists]



  service_already_exists();



[endsect]



[endsect]

[section:socket_base socket_base]


The [link networking_ts.reference.socket_base `socket_base`] class is used as a base for the [link networking_ts.reference.basic_stream_socket `basic_stream_socket`] and [link networking_ts.reference.basic_datagram_socket `basic_datagram_socket`] class templates so that we have a common place to define the shutdown\_type and enum. 


  class socket_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.socket_base.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link networking_ts.reference.socket_base.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.socket_base._socket_base [*~socket_base]]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.socket_base.max_listen_connections [*max_listen_connections]]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link networking_ts.reference.socket_base.message_do_not_route [*message_do_not_route]]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link networking_ts.reference.socket_base.message_end_of_record [*message_end_of_record]]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link networking_ts.reference.socket_base.message_out_of_band [*message_out_of_band]]]
    [Process out-of-band data. ]
  ]

  [
    [[link networking_ts.reference.socket_base.message_peek [*message_peek]]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]


[section:broadcast socket_base::broadcast]


Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:bytes_readable socket_base::bytes_readable]


IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();








[endsect]



[section:debug socket_base::debug]


Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:do_not_route socket_base::do_not_route]


Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::udp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:enable_connection_aborted socket_base::enable_connection_aborted]


Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with std::experimental::net::error::connection\_aborted. By default the option is false.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]



[section:keep_alive socket_base::keep_alive]


Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();








[endsect]



[section:linger socket_base::linger]


Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();








[endsect]



[section:max_listen_connections socket_base::max_listen_connections]


The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route socket_base::message_do_not_route]


Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record socket_base::message_end_of_record]


Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags socket_base::message_flags]


Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;




[endsect]



[section:message_out_of_band socket_base::message_out_of_band]


Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek socket_base::message_peek]


Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:out_of_band_inline socket_base::out_of_band_inline]


Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context);
   ...
   std::experimental::net::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();








[endsect]



[section:receive_buffer_size socket_base::receive_buffer_size]


Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:receive_low_watermark socket_base::receive_low_watermark]


Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:reuse_address socket_base::reuse_address]


Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::acceptor acceptor(io_context); 
   ...
   std::experimental::net::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();








[endsect]



[section:send_buffer_size socket_base::send_buffer_size]


Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:send_low_watermark socket_base::send_low_watermark]


Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   std::experimental::net::ip::tcp::socket socket(io_context); 
   ...
   std::experimental::net::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();








[endsect]



[section:shutdown_type socket_base::shutdown_type]


Different ways a socket may be shutdown. 


  enum shutdown_type


[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]



[section:wait_type socket_base::wait_type]


Wait types. 


  enum wait_type


[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_socket_base socket_base::~socket_base]


Protected destructor to prevent deletion through this type. 


  ~socket_base();



[endsect]



[endsect]


[section:steady_timer steady_timer]


Typedef for a timer based on the steady clock. 


  typedef basic_waitable_timer< chrono::steady_clock > steady_timer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_waitable_timer.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.duration [*duration]]]
    [The duration type of the clock. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.time_point [*time_point]]]
    [The time point type of the clock. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.traits_type [*traits_type]]]
    [The wait traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_waitable_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.basic_waitable_timer [*basic_waitable_timer]]]
    [Constructor. 

     Constructor to set a particular expiry time as an absolute time. 

     Constructor to set a particular expiry time relative to now. 

     Move-construct a basic_waitable_timer from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expires_after [*expires_after]]]
    [Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expires_at [*expires_at]]]
    [Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expiry [*expiry]]]
    [Get the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_waitable_timer from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer._basic_waitable_timer [*~basic_waitable_timer]]]
    [Destroys the timer. ]
  ]
  
]

The [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the std::experimental::net::steady\_timer, std::experimental::net::system\_timer or std::experimental::net::high\_resolution\_timer typedefs.


[heading Remarks]
      
This waitable timer functionality is for use with the C++11 standard library's `<chrono>` facility, or with the Boost.Chrono library.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait (C++11): 

   // Construct a timer without setting an expiry time.
   std::experimental::net::steady_timer timer(io_context);

   // Set an expiry time relative to now.
   timer.expires_after(std::chrono::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait (C++11): 

   void handler(const std::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   std::experimental::net::steady_timer timer(io_context,
       std::chrono::steady_clock::now() + std::chrono::seconds(60));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active waitable timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_after(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const std::error_code& e)
   {
     if (e != std::experimental::net::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The std::experimental::net::basic\_waitable\_timer::expires\_after() function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the std::error\_code passed to it contains the value std::experimental::net::error::operation\_aborted. 




This typedef uses the C++11 `<chrono>` standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] template directly: 

   typedef basic_waitable_timer<boost::chrono::steady_clock> timer;





[endsect]


[section:strand strand]


Provides serialised function invocation for any executor type. 


  template<
      typename Executor>
  class strand


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.strand.inner_executor_type [*inner_executor_type]]]
    [The type of the underlying executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.strand.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.strand.defer [*defer]]]
    [Request the strand to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.strand.dispatch [*dispatch]]]
    [Request the strand to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.strand.get_inner_executor [*get_inner_executor]]]
    [Obtain the underlying executor. ]
  ]
  
  [
    [[link networking_ts.reference.strand.on_work_finished [*on_work_finished]]]
    [Inform the strand that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.strand.on_work_started [*on_work_started]]]
    [Inform the strand that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.strand.operator_eq_ [*operator=]]]
    [Assignment operator. 

     Converting assignment operator. 

     Move assignment operator. 

     Converting move assignment operator. ]
  ]
  
  [
    [[link networking_ts.reference.strand.post [*post]]]
    [Request the strand to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.strand.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the strand is running in the current thread. ]
  ]
  
  [
    [[link networking_ts.reference.strand.strand [*strand]]]
    [Default constructor. 

     Construct a strand for the specified executor. 

     Copy constructor. 

     Converting constructor. 

     Move constructor. 

     Converting move constructor. ]
  ]
  
  [
    [[link networking_ts.reference.strand._strand [*~strand]]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.strand.operator_not__eq_ [*operator!=]]]
    [Compare two strands for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.strand.operator_eq__eq_ [*operator==]]]
    [Compare two strands for equality. ]
  ]
  
]


[section:context strand::context]


Obtain the underlying execution context. 


  execution_context & context() const;



[endsect]



[section:defer strand::defer]


Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void defer(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled by the underlying executor's defer function.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:dispatch strand::dispatch]


Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void dispatch(
      Function && f,
      const Allocator & a) const;


This function is used to ask the strand to execute the given function object on its underlying executor. The function object will be executed inside this function if the strand is not otherwise busy and if the underlying executor's `dispatch()` function is also able to execute the function before returning.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:get_inner_executor strand::get_inner_executor]


Obtain the underlying executor. 


  inner_executor_type get_inner_executor() const;



[endsect]



[section:inner_executor_type strand::inner_executor_type]


The type of the underlying executor. 


  typedef Executor inner_executor_type;




[endsect]



[section:on_work_finished strand::on_work_finished]


Inform the strand that some work is no longer outstanding. 


  void on_work_finished() const;


The strand delegates this call to its underlying executor. 


[endsect]



[section:on_work_started strand::on_work_started]


Inform the strand that it has some outstanding work to do. 


  void on_work_started() const;


The strand delegates this call to its underlying executor. 


[endsect]



[section:operator_not__eq_ strand::operator!=]


Compare two strands for inequality. 


  friend bool operator!=(
      const strand & a,
      const strand & b);


Two strands are equal if they refer to the same ordered, non-concurrent state. 


[endsect]


[section:operator_eq_ strand::operator=]


Assignment operator. 


  strand & ``[link networking_ts.reference.strand.operator_eq_.overload1 operator=]``(
      const strand & other);
  ``  [''''&raquo;''' [link networking_ts.reference.strand.operator_eq_.overload1 more...]]``


Converting assignment operator. 


  template<
      class OtherExecutor>
  strand & ``[link networking_ts.reference.strand.operator_eq_.overload2 operator=]``(
      const strand< OtherExecutor > & other);
  ``  [''''&raquo;''' [link networking_ts.reference.strand.operator_eq_.overload2 more...]]``


Move assignment operator. 


  strand & ``[link networking_ts.reference.strand.operator_eq_.overload3 operator=]``(
      strand && other);
  ``  [''''&raquo;''' [link networking_ts.reference.strand.operator_eq_.overload3 more...]]``


Converting move assignment operator. 


  template<
      class OtherExecutor>
  strand & ``[link networking_ts.reference.strand.operator_eq_.overload4 operator=]``(
      const strand< OtherExecutor > && other);
  ``  [''''&raquo;''' [link networking_ts.reference.strand.operator_eq_.overload4 more...]]``


[section:overload1 strand::operator= (1 of 4 overloads)]


Assignment operator. 


  strand & operator=(
      const strand & other);



[endsect]



[section:overload2 strand::operator= (2 of 4 overloads)]


Converting assignment operator. 


  template<
      class OtherExecutor>
  strand & operator=(
      const strand< OtherExecutor > & other);


This assignment operator is only valid if the `OtherExecutor` type is convertible to `Executor`. 


[endsect]



[section:overload3 strand::operator= (3 of 4 overloads)]


Move assignment operator. 


  strand & operator=(
      strand && other);



[endsect]



[section:overload4 strand::operator= (4 of 4 overloads)]


Converting move assignment operator. 


  template<
      class OtherExecutor>
  strand & operator=(
      const strand< OtherExecutor > && other);


This assignment operator is only valid if the `OtherExecutor` type is convertible to `Executor`. 


[endsect]


[endsect]


[section:operator_eq__eq_ strand::operator==]


Compare two strands for equality. 


  friend bool operator==(
      const strand & a,
      const strand & b);


Two strands are equal if they refer to the same ordered, non-concurrent state. 


[endsect]



[section:post strand::post]


Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void post(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled by the underlying executor's defer function.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:running_in_this_thread strand::running_in_this_thread]


Determine whether the strand is running in the current thread. 


  bool running_in_this_thread() const;



[heading Return Value]
      
`true` if the current thread is executing a function that was submitted to the strand using `post()`, `dispatch()` or `defer()`. Otherwise returns `false`. 




[endsect]


[section:strand strand::strand]


Default constructor. 


  ``[link networking_ts.reference.strand.strand.overload1 strand]``();
  ``  [''''&raquo;''' [link networking_ts.reference.strand.strand.overload1 more...]]``


Construct a strand for the specified executor. 


  explicit ``[link networking_ts.reference.strand.strand.overload2 strand]``(
      const Executor & e);
  ``  [''''&raquo;''' [link networking_ts.reference.strand.strand.overload2 more...]]``


Copy constructor. 


  ``[link networking_ts.reference.strand.strand.overload3 strand]``(
      const strand & other);
  ``  [''''&raquo;''' [link networking_ts.reference.strand.strand.overload3 more...]]``


Converting constructor. 


  template<
      class OtherExecutor>
  ``[link networking_ts.reference.strand.strand.overload4 strand]``(
      const strand< OtherExecutor > & other);
  ``  [''''&raquo;''' [link networking_ts.reference.strand.strand.overload4 more...]]``


Move constructor. 


  ``[link networking_ts.reference.strand.strand.overload5 strand]``(
      strand && other);
  ``  [''''&raquo;''' [link networking_ts.reference.strand.strand.overload5 more...]]``


Converting move constructor. 


  template<
      class OtherExecutor>
  ``[link networking_ts.reference.strand.strand.overload6 strand]``(
      strand< OtherExecutor > && other);
  ``  [''''&raquo;''' [link networking_ts.reference.strand.strand.overload6 more...]]``


[section:overload1 strand::strand (1 of 6 overloads)]


Default constructor. 


  strand();


This constructor is only valid if the underlying executor type is default constructible. 


[endsect]



[section:overload2 strand::strand (2 of 6 overloads)]


Construct a strand for the specified executor. 


  strand(
      const Executor & e);



[endsect]



[section:overload3 strand::strand (3 of 6 overloads)]


Copy constructor. 


  strand(
      const strand & other);



[endsect]



[section:overload4 strand::strand (4 of 6 overloads)]


Converting constructor. 


  template<
      class OtherExecutor>
  strand(
      const strand< OtherExecutor > & other);


This constructor is only valid if the `OtherExecutor` type is convertible to `Executor`. 


[endsect]



[section:overload5 strand::strand (5 of 6 overloads)]


Move constructor. 


  strand(
      strand && other);



[endsect]



[section:overload6 strand::strand (6 of 6 overloads)]


Converting move constructor. 


  template<
      class OtherExecutor>
  strand(
      strand< OtherExecutor > && other);


This constructor is only valid if the `OtherExecutor` type is convertible to `Executor`. 


[endsect]


[endsect]


[section:_strand strand::~strand]


Destructor. 


  ~strand();



[endsect]



[endsect]

[section:system_context system_context]


The executor context for the system executor. 


  class system_context :
    public execution_context


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.system_context.executor_type [*executor_type]]]
    [The executor type associated with the context. ]
  
  ]

  [

    [[link networking_ts.reference.system_context.fork_event [*fork_event]]]
    [Fork-related event notifications. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.system_context.get_executor [*get_executor]]]
    [Obtain an executor for the context. ]
  ]
  
  [
    [[link networking_ts.reference.system_context.join [*join]]]
    [Join all threads in the system thread pool. ]
  ]
  
  [
    [[link networking_ts.reference.system_context.notify_fork [*notify_fork]]]
    [Notify the execution_context of a fork-related event. ]
  ]
  
  [
    [[link networking_ts.reference.system_context.stop [*stop]]]
    [Signal all threads in the system thread pool to stop. ]
  ]
  
  [
    [[link networking_ts.reference.system_context.stopped [*stopped]]]
    [Determine whether the system thread pool has been stopped. ]
  ]
  
  [
    [[link networking_ts.reference.system_context._system_context [*~system_context]]]
    [Destructor shuts down all threads in the system thread pool. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.system_context.destroy [*destroy]]]
    [Destroys all services in the context. ]
  ]
  
  [
    [[link networking_ts.reference.system_context.shutdown [*shutdown]]]
    [Shuts down all services in the context. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.system_context.add_service [*add_service]]]
    [(Deprecated: Use make_service().) Add a service object to the execution_context. ]
  ]
  
  [
    [[link networking_ts.reference.system_context.has_service [*has_service]]]
    [Determine if an execution_context contains a specified service type. ]
  ]
  
  [
    [[link networking_ts.reference.system_context.make_service [*make_service]]]
    [Creates a service object and adds it to the execution_context. ]
  ]
  
  [
    [[link networking_ts.reference.system_context.use_service [*use_service]]]
    [Obtain the service object corresponding to the given type. ]
  ]
  
]


[section:add_service system_context::add_service]


['Inherited from execution_context.]


(Deprecated: Use `make_service()`.) Add a service object to the [link networking_ts.reference.execution_context `execution_context`]. 


  template<
      typename Service>
  friend void add_service(
      execution_context & e,
      Service * svc);


This function is used to add a service to the [link networking_ts.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

[[svc][The service object. On success, ownership of the service object is transferred to the [link networking_ts.reference.execution_context `execution_context`]. When the [link networking_ts.reference.execution_context `execution_context`] object is destroyed, it will destroy the service object by performing:
``
   delete static_cast<execution_context::service*>(svc) 
``
]]

]


[heading Exceptions]
    

[variablelist
  
[[std::experimental::net::service_already_exists][Thrown if a service of the given type is already present in the [link networking_ts.reference.execution_context `execution_context`].]]

[[std::experimental::net::invalid_service_owner][Thrown if the service's owning [link networking_ts.reference.execution_context `execution_context`] is not the [link networking_ts.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]

]




[endsect]



[section:destroy system_context::destroy]


['Inherited from execution_context.]


Destroys all services in the context. 


  void destroy();


This function is implemented as follows:


* For each service object `svc` in the [link networking_ts.reference.execution_context `execution_context`] set, in reverse order * of the beginning of service object lifetime, performs `delete static_cast<execution_context::service*>(svc)`. 




[endsect]



[section:executor_type system_context::executor_type]


The executor type associated with the context. 


  typedef system_executor executor_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.system_executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.defer [*defer]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.dispatch [*dispatch]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.on_work_finished [*on_work_finished]]]
    [Inform the executor that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.on_work_started [*on_work_started]]]
    [Inform the executor that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.post [*post]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.system_executor.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]

The system executor represents an execution context where functions are permitted to run on arbitrary threads. The `post()` and `defer()` functions schedule the function to run on an unspecified system thread pool, and `dispatch()` invokes the function immediately. 



[endsect]



[section:fork_event system_context::fork_event]


['Inherited from execution_context.]


Fork-related event notifications. 


  enum fork_event


[heading Values]
[variablelist

  [
    [fork_prepare]
    [Notify the context that the process is about to fork. ]
  ]

  [
    [fork_parent]
    [Notify the context that the process has forked and is the parent. ]
  ]

  [
    [fork_child]
    [Notify the context that the process has forked and is the child. ]
  ]

]



[endsect]



[section:get_executor system_context::get_executor]


Obtain an executor for the context. 


  executor_type get_executor();



[endsect]



[section:has_service system_context::has_service]


['Inherited from execution_context.]


Determine if an [link networking_ts.reference.execution_context `execution_context`] contains a specified service type. 


  template<
      typename Service>
  friend bool has_service(
      execution_context & e);


This function is used to determine whether the [link networking_ts.reference.execution_context `execution_context`] contains a service object corresponding to the given service type.


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
A boolean indicating whether the [link networking_ts.reference.execution_context `execution_context`] contains the service. 




[endsect]



[section:join system_context::join]


Join all threads in the system thread pool. 


  void join();



[endsect]



[section:make_service system_context::make_service]


['Inherited from execution_context.]


Creates a service object and adds it to the [link networking_ts.reference.execution_context `execution_context`]. 


  template<
      typename Service,
      typename... Args>
  friend Service & make_service(
      execution_context & e,
      Args &&... args);


This function is used to add a service to the [link networking_ts.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

[[args][Zero or more arguments to be passed to the service constructor.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::experimental::net::service_already_exists][Thrown if a service of the given type is already present in the [link networking_ts.reference.execution_context `execution_context`]. ]]

]




[endsect]



[section:notify_fork system_context::notify_fork]


['Inherited from execution_context.]


Notify the [link networking_ts.reference.execution_context `execution_context`] of a fork-related event. 


  void notify_fork(
      fork_event event);


This function is used to inform the [link networking_ts.reference.execution_context `execution_context`] that the process is about to fork, or has just forked. This allows the [link networking_ts.reference.execution_context `execution_context`], and the services it contains, to perform any necessary housekeeping to ensure correct operation following a fork.

This function must not be called while any other [link networking_ts.reference.execution_context `execution_context`] function, or any function associated with the execution\_context's derived class, is being called in another thread. It is, however, safe to call this function from within a completion handler, provided no other thread is accessing the [link networking_ts.reference.execution_context `execution_context`] or its derived class.


[heading Parameters]
    

[variablelist
  
[[event][A fork-related event.]]

]


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. If the notification fails the [link networking_ts.reference.execution_context `execution_context`] object should no longer be used and should be destroyed.]]

]


[heading Example]
  
The following code illustrates how to incorporate the `notify_fork()` function: 

   my_execution_context.notify_fork(execution_context::fork_prepare);
   if (fork() == 0)
   {
     // This is the child process.
     my_execution_context.notify_fork(execution_context::fork_child);
   }
   else
   {
     // This is the parent process.
     my_execution_context.notify_fork(execution_context::fork_parent);
   } 





[heading Remarks]
      
For each service object `svc` in the [link networking_ts.reference.execution_context `execution_context`] set, performs `svc->notify_fork();`. When processing the fork\_prepare event, services are visited in reverse order of the beginning of service object lifetime. Otherwise, services are visited in order of the beginning of service object lifetime. 




[endsect]



[section:shutdown system_context::shutdown]


['Inherited from execution_context.]


Shuts down all services in the context. 


  void shutdown();


This function is implemented as follows:


* For each service object `svc` in the [link networking_ts.reference.execution_context `execution_context`] set, in reverse order of the beginning of service object lifetime, performs `svc->shutdown()`. 




[endsect]



[section:stop system_context::stop]


Signal all threads in the system thread pool to stop. 


  void stop();



[endsect]



[section:stopped system_context::stopped]


Determine whether the system thread pool has been stopped. 


  bool stopped() const;



[endsect]


[section:use_service system_context::use_service]


Obtain the service object corresponding to the given type. 


  template<
      typename Service>
  friend Service & ``[link networking_ts.reference.system_context.use_service.overload1 use_service]``(
      execution_context & e);
  ``  [''''&raquo;''' [link networking_ts.reference.system_context.use_service.overload1 more...]]``

  template<
      typename Service>
  friend Service & ``[link networking_ts.reference.system_context.use_service.overload2 use_service]``(
      io_context & ioc);
  ``  [''''&raquo;''' [link networking_ts.reference.system_context.use_service.overload2 more...]]``


[section:overload1 system_context::use_service (1 of 2 overloads)]


['Inherited from execution_context.]


Obtain the service object corresponding to the given type. 


  template<
      typename Service>
  friend Service & use_service(
      execution_context & e);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link networking_ts.reference.execution_context `execution_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[e][The [link networking_ts.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. 




[endsect]



[section:overload2 system_context::use_service (2 of 2 overloads)]


['Inherited from execution_context.]


Obtain the service object corresponding to the given type. 


  template<
      typename Service>
  friend Service & use_service(
      io_context & ioc);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link networking_ts.reference.io_context `io_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[ioc][The [link networking_ts.reference.io_context `io_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller.


[heading Remarks]
      
This overload is preserved for backwards compatibility with services that inherit from [link networking_ts.reference.io_context__service `io_context::service`]. 




[endsect]


[endsect]


[section:_system_context system_context::~system_context]


Destructor shuts down all threads in the system thread pool. 


  ~system_context();



[endsect]



[endsect]

[section:system_executor system_executor]


An executor that uses arbitrary threads. 


  class system_executor


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.system_executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.defer [*defer]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.dispatch [*dispatch]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.on_work_finished [*on_work_finished]]]
    [Inform the executor that some work is no longer outstanding. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.on_work_started [*on_work_started]]]
    [Inform the executor that it has some outstanding work to do. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.post [*post]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.system_executor.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link networking_ts.reference.system_executor.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]

The system executor represents an execution context where functions are permitted to run on arbitrary threads. The `post()` and `defer()` functions schedule the function to run on an unspecified system thread pool, and `dispatch()` invokes the function immediately. 


[section:context system_executor::context]


Obtain the underlying execution context. 


  system_context & context() const;



[endsect]



[section:defer system_executor::defer]


Request the system executor to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void defer(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled to run on an unspecified system thread pool.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:dispatch system_executor::dispatch]


Request the system executor to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void dispatch(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will always be executed inside this function.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:on_work_finished system_executor::on_work_finished]


Inform the executor that some work is no longer outstanding. 


  void on_work_finished() const;


For the system executor, this is a no-op. 


[endsect]



[section:on_work_started system_executor::on_work_started]


Inform the executor that it has some outstanding work to do. 


  void on_work_started() const;


For the system executor, this is a no-op. 


[endsect]



[section:operator_not__eq_ system_executor::operator!=]


Compare two executors for inequality. 


  friend bool operator!=(
      const system_executor & ,
      const system_executor & );


System executors always compare equal. 


[endsect]



[section:operator_eq__eq_ system_executor::operator==]


Compare two executors for equality. 


  friend bool operator==(
      const system_executor & ,
      const system_executor & );


System executors always compare equal. 


[endsect]



[section:post system_executor::post]


Request the system executor to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void post(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled to run on an unspecified system thread pool.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[endsect]


[section:system_timer system_timer]


Typedef for a timer based on the system clock. 


  typedef basic_waitable_timer< chrono::system_clock > system_timer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.basic_waitable_timer.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.duration [*duration]]]
    [The duration type of the clock. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.time_point [*time_point]]]
    [The time point type of the clock. ]
  
  ]

  [

    [[link networking_ts.reference.basic_waitable_timer.traits_type [*traits_type]]]
    [The wait traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.basic_waitable_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.basic_waitable_timer [*basic_waitable_timer]]]
    [Constructor. 

     Constructor to set a particular expiry time as an absolute time. 

     Constructor to set a particular expiry time relative to now. 

     Move-construct a basic_waitable_timer from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expires_after [*expires_after]]]
    [Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expires_at [*expires_at]]]
    [Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.expiry [*expiry]]]
    [Get the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_waitable_timer from another. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link networking_ts.reference.basic_waitable_timer._basic_waitable_timer [*~basic_waitable_timer]]]
    [Destroys the timer. ]
  ]
  
]

The [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the std::experimental::net::steady\_timer, std::experimental::net::system\_timer or std::experimental::net::high\_resolution\_timer typedefs.


[heading Remarks]
      
This waitable timer functionality is for use with the C++11 standard library's `<chrono>` facility, or with the Boost.Chrono library.


[heading Thread Safety]
  
[*Distinct] [*objects:] Safe.

[*Shared] [*objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait (C++11): 

   // Construct a timer without setting an expiry time.
   std::experimental::net::steady_timer timer(io_context);

   // Set an expiry time relative to now.
   timer.expires_after(std::chrono::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait (C++11): 

   void handler(const std::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   std::experimental::net::steady_timer timer(io_context,
       std::chrono::steady_clock::now() + std::chrono::seconds(60));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active waitable timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_after(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const std::error_code& e)
   {
     if (e != std::experimental::net::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The std::experimental::net::basic\_waitable\_timer::expires\_after() function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the std::error\_code passed to it contains the value std::experimental::net::error::operation\_aborted. 




This typedef uses the C++11 `<chrono>` standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] template directly: 

   typedef basic_waitable_timer<boost::chrono::system_clock> timer;





[endsect]



[section:transfer_all transfer_all]


Return a completion condition function object that indicates that a read or write operation should continue until all of the data has been transferred, or until an error occurs. 


  unspecified transfer_all();


This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.


[heading Example]
  
Reading until a buffer is full: 

   boost::array<char, 128> buf;
   std::error_code ec;
   std::size_t n = std::experimental::net::read(
       sock, std::experimental::net::buffer(buf),
       std::experimental::net::transfer_all(), ec);
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     // n == 128
   }







[endsect]



[section:transfer_at_least transfer_at_least]


Return a completion condition function object that indicates that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs. 


  unspecified transfer_at_least(
      std::size_t minimum);


This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.


[heading Example]
  
Reading until a buffer is full or contains at least 64 bytes: 

   boost::array<char, 128> buf;
   std::error_code ec;
   std::size_t n = std::experimental::net::read(
       sock, std::experimental::net::buffer(buf),
       std::experimental::net::transfer_at_least(64), ec);
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     // n >= 64 && n <= 128
   }







[endsect]



[section:transfer_exactly transfer_exactly]


Return a completion condition function object that indicates that a read or write operation should continue until an exact number of bytes has been transferred, or until an error occurs. 


  unspecified transfer_exactly(
      std::size_t size);


This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.


[heading Example]
  
Reading until a buffer is full or contains exactly 64 bytes: 

   boost::array<char, 128> buf;
   std::error_code ec;
   std::size_t n = std::experimental::net::read(
       sock, std::experimental::net::buffer(buf),
       std::experimental::net::transfer_exactly(64), ec);
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     // n == 64
   }







[endsect]



[section:use_future use_future]


A special value, similar to std::nothrow. 


  constexpr use_future_t use_future;


See the documentation for std::experimental::net::use\_future\_t for a usage example. 


[endsect]


[section:use_future_t use_future_t]


Class used to specify that an asynchronous operation should return a future. 


  template<
      typename Allocator = std::allocator<void>>
  class use_future_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link networking_ts.reference.use_future_t.allocator_type [*allocator_type]]]
    [The allocator type. The allocator is used when constructing the std::promise object for a given asynchronous operation. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.use_future_t.get_allocator [*get_allocator]]]
    [Obtain allocator. ]
  ]
  
  [
    [[link networking_ts.reference.use_future_t.operator_lb__rb_ [*operator()]]]
    [Wrap a function object in a packaged task. ]
  ]
  
  [
    [[link networking_ts.reference.use_future_t.rebind [*rebind]]]
    [Specify an alternate allocator. ]
  ]
  
  [
    [[link networking_ts.reference.use_future_t.use_future_t [*use_future_t]]]
    [Construct using default-constructed allocator. 

     Construct using specified allocator. ]
  ]
  
]

The [link networking_ts.reference.use_future_t `use_future_t`] class is used to indicate that an asynchronous operation should return a std::future object. A [link networking_ts.reference.use_future_t `use_future_t`] object may be passed as a handler to an asynchronous operation, typically using the special value `std::experimental::net::use_future`. For example:



   std::future<std::size_t> my_future
     = my_socket.async_read_some(my_buffer, std::experimental::net::use_future); 




The initiating function (async\_read\_some in the above example) returns a future that will receive the result of the operation. If the operation completes with an error\_code indicating failure, it is converted into a system\_error and passed back to the caller via the future. 


[section:allocator_type use_future_t::allocator_type]


The allocator type. The allocator is used when constructing the `std::promise` object for a given asynchronous operation. 


  typedef Allocator allocator_type;




[endsect]



[section:get_allocator use_future_t::get_allocator]


Obtain allocator. 


  allocator_type get_allocator() const;



[endsect]



[section:operator_lb__rb_ use_future_t::operator()]


Wrap a function object in a packaged task. 


  template<
      typename Function>
  unspecified operator()(
      Function && f) const;


The `package` function is used to adapt a function object as a packaged task. When this adapter is passed as a completion token to an asynchronous operation, the result of the function object is retuned via a std::future.


[heading Example]
  




   std::future<std::size_t> fut =
     my_socket.async_read_some(buffer,
       use_future([](std::error_code ec, std::size_t n)
         {
           return ec ? 0 : n;
         }));
   ...
   std::size_t n = fut.get(); 





[endsect]



[section:rebind use_future_t::rebind]


Specify an alternate allocator. 


  template<
      typename OtherAllocator>
  use_future_t< OtherAllocator > rebind(
      const OtherAllocator & allocator) const;



[endsect]


[section:use_future_t use_future_t::use_future_t]


Construct using default-constructed allocator. 


  constexpr ``[link networking_ts.reference.use_future_t.use_future_t.overload1 use_future_t]``();
  ``  [''''&raquo;''' [link networking_ts.reference.use_future_t.use_future_t.overload1 more...]]``


Construct using specified allocator. 


  explicit ``[link networking_ts.reference.use_future_t.use_future_t.overload2 use_future_t]``(
      const Allocator & allocator);
  ``  [''''&raquo;''' [link networking_ts.reference.use_future_t.use_future_t.overload2 more...]]``


[section:overload1 use_future_t::use_future_t (1 of 2 overloads)]


Construct using default-constructed allocator. 


  constexpr use_future_t();



[endsect]



[section:overload2 use_future_t::use_future_t (2 of 2 overloads)]


Construct using specified allocator. 


  use_future_t(
      const Allocator & allocator);



[endsect]


[endsect]


[endsect]

[section:uses_executor uses_executor]


The [link networking_ts.reference.uses_executor `uses_executor`] trait detects whether a type T has an associated executor that is convertible from type Executor. 


  template<
      typename T,
      typename Executor>
  struct uses_executor


Meets the BinaryTypeTrait requirements. The Asio library provides a definition that is derived from false\_type. A program may specialize this template to derive from true\_type for a user-defined type T that can be constructed with an executor, where the first argument of a constructor has type [link networking_ts.reference.executor_arg_t `executor_arg_t`] and the second argument is convertible from type Executor. 


[endsect]

[section:wait_traits wait_traits]


Wait traits suitable for use with the [link networking_ts.reference.basic_waitable_timer `basic_waitable_timer`] class template. 


  template<
      typename Clock>
  struct wait_traits


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link networking_ts.reference.wait_traits.to_wait_duration [*to_wait_duration]]]
    [Convert a clock duration into a duration used for waiting. ]
  ]
  
]

[section:to_wait_duration wait_traits::to_wait_duration]


Convert a clock duration into a duration used for waiting. 


  static Clock::duration ``[link networking_ts.reference.wait_traits.to_wait_duration.overload1 to_wait_duration]``(
      const typename Clock::duration & d);
  ``  [''''&raquo;''' [link networking_ts.reference.wait_traits.to_wait_duration.overload1 more...]]``

  static Clock::duration ``[link networking_ts.reference.wait_traits.to_wait_duration.overload2 to_wait_duration]``(
      const typename Clock::time_point & t);
  ``  [''''&raquo;''' [link networking_ts.reference.wait_traits.to_wait_duration.overload2 more...]]``


[section:overload1 wait_traits::to_wait_duration (1 of 2 overloads)]


Convert a clock duration into a duration used for waiting. 


  static Clock::duration to_wait_duration(
      const typename Clock::duration & d);



[heading Return Value]
      
`d`. 




[endsect]



[section:overload2 wait_traits::to_wait_duration (2 of 2 overloads)]


Convert a clock duration into a duration used for waiting. 


  static Clock::duration to_wait_duration(
      const typename Clock::time_point & t);



[heading Return Value]
      
`d`. 




[endsect]


[endsect]


[endsect]

[section:write write]


Write a certain amount of data to a stream before returning. 

      
  template<
      typename SyncWriteStream,
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.write.overload1 write]``(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.write.overload1 more...]]``

  template<
      typename SyncWriteStream,
      typename ConstBufferSequence>
  std::size_t ``[link networking_ts.reference.write.overload2 write]``(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      std::error_code & ec,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.write.overload2 more...]]``

  template<
      typename SyncWriteStream,
      typename ConstBufferSequence,
      typename CompletionCondition>
  std::size_t ``[link networking_ts.reference.write.overload3 write]``(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.write.overload3 more...]]``

  template<
      typename SyncWriteStream,
      typename ConstBufferSequence,
      typename CompletionCondition>
  std::size_t ``[link networking_ts.reference.write.overload4 write]``(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      std::error_code & ec,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.write.overload4 more...]]``

  template<
      typename SyncWriteStream,
      typename DynamicBuffer>
  std::size_t ``[link networking_ts.reference.write.overload5 write]``(
      SyncWriteStream & s,
      DynamicBuffer && buffers,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.write.overload5 more...]]``

  template<
      typename SyncWriteStream,
      typename DynamicBuffer>
  std::size_t ``[link networking_ts.reference.write.overload6 write]``(
      SyncWriteStream & s,
      DynamicBuffer && buffers,
      std::error_code & ec,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.write.overload6 more...]]``

  template<
      typename SyncWriteStream,
      typename DynamicBuffer,
      typename CompletionCondition>
  std::size_t ``[link networking_ts.reference.write.overload7 write]``(
      SyncWriteStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.write.overload7 more...]]``

  template<
      typename SyncWriteStream,
      typename DynamicBuffer,
      typename CompletionCondition>
  std::size_t ``[link networking_ts.reference.write.overload8 write]``(
      SyncWriteStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      std::error_code & ec,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);
  ``  [''''&raquo;''' [link networking_ts.reference.write.overload8 more...]]``


[section:overload1 write (1 of 8 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename SyncWriteStream,
      typename ConstBufferSequence>
  std::size_t write(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  
To write a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::write(s, std::experimental::net::buffer(data, size)); 


See the `std::experimental::net::buffer`  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::write(
       s, buffers,
       std::experimental::net::transfer_all()); 







[endsect]



[section:overload2 write (2 of 8 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename SyncWriteStream,
      typename ConstBufferSequence>
  std::size_t write(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      std::error_code & ec,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Example]
  
To write a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::write(s, std::experimental::net::buffer(data, size), ec); 


See the `std::experimental::net::buffer`  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::write(
       s, buffers,
       std::experimental::net::transfer_all(), ec); 







[endsect]



[section:overload3 write (3 of 8 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename SyncWriteStream,
      typename ConstBufferSequence,
      typename CompletionCondition>
  std::size_t write(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Example]
  
To write a single data buffer use the `std::experimental::net::buffer`  function as follows: 

   std::experimental::net::write(s, std::experimental::net::buffer(data, size),
       std::experimental::net::transfer_at_least(32)); 


See the `std::experimental::net::buffer`  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload4 write (4 of 8 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename SyncWriteStream,
      typename ConstBufferSequence,
      typename CompletionCondition>
  std::size_t write(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      std::error_code & ec,
      typename enable_if< is_const_buffer_sequence< ConstBufferSequence >::value >::type *  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload5 write (5 of 8 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename SyncWriteStream,
      typename DynamicBuffer>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer && buffers,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::write(
       s, buffers,
       std::experimental::net::transfer_all()); 







[endsect]



[section:overload6 write (6 of 8 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename SyncWriteStream,
      typename DynamicBuffer>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer && buffers,
      std::error_code & ec,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   std::experimental::net::write(
       s, buffers,
       std::experimental::net::transfer_all(), ec); 







[endsect]



[section:overload7 write (7 of 8 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename SyncWriteStream,
      typename DynamicBuffer,
      typename CompletionCondition>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[std::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 write (8 of 8 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename SyncWriteStream,
      typename DynamicBuffer,
      typename CompletionCondition>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer && buffers,
      CompletionCondition completion_condition,
      std::error_code & ec,
      typename enable_if< is_dynamic_buffer< DynamicBuffer >::value >::type *  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const std::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]


[endsect]

[endsect]